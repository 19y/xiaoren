[{"题干":"mybatis中定义别名使用到的具体标签是","选项F":"","选项E":"","选项D":"otherAlias","答案":"A","选项C":"othername","选项B":"secondname","选项A":"typeAlias","类型":"1-单选"},{"题干":"mybatis代表新增标签的是","选项F":"","选项E":"","选项D":"<select><select/>","答案":"A","选项C":"resultMap","选项B":"<update><update/>","选项A":"<insert><insert/>","类型":"1-单选"},{"题干":"mybatis动态sql中不包含的标签是","选项F":"","选项E":"","选项D":"if","答案":"A","选项C":"where","选项B":"set","选项A":"dynamic","类型":"1-单选"},{"题干":"查询出生日期是在1988年之前的如果使用构建查询，则用到的关键字是","选项F":"","选项E":"","选项D":"LessThan","答案":"B","选项C":"NotLike","选项B":"Before","选项A":"Between","类型":"1-单选"},{"题干":"mybatis动态sql中标签错误的是","选项F":"","选项E":"","选项D":"ADD","答案":"D","选项C":"where","选项B":"if","选项A":"choose","类型":"1-单选"},{"题干":"<update id=\"updateUserById\" parameterType=\"com.ys.po.User\">\n    update user u\n        <set>\n            <if test=\"username != null and username != ''\">\n                u.username = #{username},\n            </if>\n            <if test=\"sex != null and sex != ''\">\n                u.sex = #{sex}\n            </if>\n        </set>    \n     where id=#{id}\n</update>","选项F":"","选项E":"","选项D":"如果第一个条件不为空，第二个条件sex为空 那么 sql 语句为：update user u set u.username = ? ,u.sex =null where id=?","答案":"B","选项C":"如果第一个条件不为空，第二个条件sex为空 那么 sql 语句为：update user u set u.username = ? ,u.sex = ? where id=?","选项B":"如果第一个条件 username 为空，那么 sql 语句相当于为：\nupdate user u set  u.sex=? where id=?","选项A":"如果第一个条件 username 为空，那么 sql 语句相当于为：\nupdate user u set u.username =null AND  u.sex=? where id=?\n会自动将名字赋空","类型":"1-单选"},{"题干":"看下面一段动态sql,下面说话不正确的是\n<select\u00A0id=\"selectUser\"\u00A0parameterType=\"com.ys.vo.UserVo\"\u00A0resultType=\"com.ys.po.User\">\n\u00A0\u00A0\u00A0\u00A0select\u00A0*\u00A0from\u00A0user\n\u00A0\u00A0\u00A0\u00A0<where>\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0<foreach\u00A0collection=\"ids\"\u00A0item=\"id\"\u00A0open=\"and\u00A0(\"\u00A0close=\")\"\u00A0separator=\"or\">\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0id=#{id}\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0</foreach>\n\u00A0\u00A0\u00A0\u00A0</where>\n</select>","选项F":"","选项E":"","选项D":"没有这种动态sql\u00A0的写法，纯属编造","答案":"D","选项C":"close:结束时拼接的字符串","选项B":"separator:遍历对象之间需要拼接的字符串","选项A":"collection:指定输入对象中的集合属性","类型":"1-单选"},{"题干":"在Springmvc中@RequestMapping标记的作用说法如下那个选项正确","选项F":"","选项E":"","选项D":"制定重定向地址","答案":"C","选项C":"指定请求的地址","选项B":"制定转发地址","选项A":"获取前台数据","类型":"1-单选"},{"题干":"ssm里所使用的springMVC的核心控制器的名称下列选项中正确的一项是?","选项F":"","选项E":"","选项D":"Action","答案":"A","选项C":"DispatcherAction","选项B":"DispatcherFilter","选项A":"DispatcherServlet","类型":"1-单选"},{"题干":"可以正确的获取类加载器的方法是","选项F":"","选项E":"","选项D":"getModify();","答案":"C","选项C":"getClassLoader();","选项B":"newInstance();","选项A":"getSuperclass();","类型":"1-单选"},{"题干":"关于通过反射获取方法正确的是","选项F":"","选项E":"","选项D":"new Too().getClass().getConstractors();","答案":"C","选项C":"new Too().getClass().getMethods();","选项B":"Too.class.getPackage();","选项A":"Too.class.getFields();","类型":"1-单选"},{"题干":"在 spring的 TransactionDefinition接口中PROPAGATION_SUPPORTS 含义为？","选项F":"","选项E":"","选项D":"新建事务，如果当前存在事务，把当前事务挂起","答案":"B","选项C":"支持当前事务，如果当前没有事务，就抛出异常","选项B":"支持当前事务，如果当前没有事务，就以非事务方式执行","选项A":"支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择","类型":"1-单选"},{"题干":"哪一个方法可以通过反射获取父类","选项F":"","选项E":"","选项D":"getSuperclass();","答案":"D","选项C":"newInstance();","选项B":"getMethod();","选项A":"getClassLoader();","类型":"1-单选"},{"题干":"SSM框架整合的时候依赖注入最常使用并且可以按照名称注入的是选项正确的是?","选项F":"","选项E":"","选项D":"@RequestMapping","答案":"A","选项C":"@service","选项B":"@Autowired","选项A":"@Resource","类型":"1-单选"},{"题干":"在SpringMVC框架中关于网络资源视图解析器的描述正确的是选项是?","选项F":"","选项E":"","选项D":"后缀没有任何的意义","答案":"A","选项C":"前缀没有任何的意义","选项B":"没有特定的解析规则","选项A":"视图解析的规则是前缀+方法的返回值+后缀","类型":"1-单选"},{"题干":"在SSM框架整合的时候SpringMVC框架配置文件中建议扫描的包结构的选项正确的是?","选项F":"","选项E":"","选项D":"dto","答案":"C","选项C":"controller","选项B":"service","选项A":"mapper","类型":"1-单选"},{"题干":"SpringMVC中，哪个是处理request\u00A0body部分的注解","选项F":"","选项E":"","选项D":"@SessionAttributes","答案":"C","选项C":"@RequestBody","选项B":"@RequestHeader","选项A":"@ModelAttribute","类型":"1-单选"},{"题干":"SpringMVC中通用的注解是以下哪个选项","选项F":"","选项E":"","选项D":"@Repository","答案":"B","选项C":"@Service","选项B":"@Component","选项A":"@Controller","类型":"1-单选"},{"题干":"在ssm框架使用关于SpringMVC，SpringMvc中有个类把视图和数据都合并的一起的，名字是（）","选项F":"","选项E":"","选项D":"Model","答案":"A","选项C":"ModelMap","选项B":"RedirectView","选项A":"ModelAndView","类型":"1-单选"},{"题干":"在ssm框架使用SpringMVC的控制器返回Json数据要用的注解是哪个","选项F":"","选项E":"","选项D":"PathVariable","答案":"B","选项C":"RequestParam","选项B":"ResponseBody","选项A":"Autowired","类型":"1-单选"},{"题干":"在ssm框架使用中关于SpringMVC，核心控制器DispatcherServlet的作用，以下说法正确的包括（）","选项F":"","选项E":"","选项D":"初始化上下文应用对象ApplicationContext","答案":"BCD","选项C":"加载配置文件","选项B":"它负责接收HTTP请求","选项A":"实现业务操作","类型":"2-多选"},{"题干":"在ssm框架使用中SpringMVC框架中，ModelAndView对象描述正确的是（）","选项F":"","选项E":"","选项D":"控制层的方法的返回值可以是ModelAndView","答案":"ABCD","选项C":"称之为模型视图对象","选项B":"可以添加指定的对象，然后再跳转的JSP视图中取到所存放的值","选项A":"可以用来设置去往哪一个页面","类型":"2-多选"},{"题干":"在ssm框架使用中SpringMVC框架中拦截器的实现方式是（）","选项F":"","选项E":"","选项D":"继承InterceptorAdapter类","答案":"AB","选项C":"实现Interceptor接口","选项B":"继承HandleInterceptorAdapter类","选项A":"实现HandleInterceptor接口","类型":"2-多选"},{"题干":"在ssm框架使用中SpringMVC框架中控制器组件包括（）","选项F":"","选项E":"","选项D":"ModelAndView","答案":"ABC","选项C":"处理业务的Controller组件","选项B":"HandlerMapping组件","选项A":"核心控制器DispatcherServlet","类型":"2-多选"},{"题干":"在ssm框架使用中SpringMVC框架提供了丰富的前台参数值获取方案，以下不是获取前台数据的方式是（）","选项F":"","选项E":"","选项D":"RequestMapping","答案":"BD","选项C":"参数","选项B":"ActionForm","选项A":"getParameter","类型":"2-多选"},{"题干":"在ssm框架使用中SpringMVC框架拦截器可以实现的功能有（）","选项F":"","选项E":"","选项D":"日志记录","答案":"ABCD","选项C":"可以解决静态资源被拦截","选项B":"性能监测","选项A":"登录验证","类型":"2-多选"},{"题干":"在ssm框架使用中mybatis动态sql中包含的标签是","选项F":"","选项E":"","选项D":"if","答案":"BCD","选项C":"where","选项B":"set","选项A":"dynamic","类型":"2-多选"},{"题干":"mybatis取值的方式不包含如下那些选项","选项F":"","选项E":"","选项D":"&{}","答案":"CD","选项C":"!{}","选项B":"#{}","选项A":"${}","类型":"2-多选"},{"题干":"下面有关mybatis中取值符号$和#说法错误的是","选项F":"","选项E":"","选项D":"$方式无法防止Sql注入","答案":"AB","选项C":"#方式能够很大程度防止sql注入","选项B":"$比#更好","选项A":"两种符号功能一样","类型":"2-多选"},{"题干":"选项中哪些可以通过反射获取","选项F":"","选项E":"","选项D":"共有方法","答案":"ABCD","选项C":"构造","选项B":"私有属性","选项A":"私有方法","类型":"2-多选"},{"题干":"在ssm框架使用关于SpringMVC，Controller类默认Scope是单例（singleton）的。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"在ssm框架使用关于SpringMVC，SpringMVC把所有的Controller请求都提交给DispatcherServlet，它会委托应用系","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"在ssm框架使用关于SpringMVC，SpringMVC把所有的Controller请求都提交给DispatcherServlet，它会委托应用系统的HandlerMapping模块负责负责对请求交给特定的Controller进行真正的处理工作。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"在ssm框架使用关于SpringMVC，SpringMVC通过一套MVC注解，让POJO成为处理请求的控制器，而无须实现任何接口。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"在ssm框架使用关于SpringMVC，SpingMVC中的控制器的注解可以使用Controller。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"SSM整合时使用中springmvc框架的控制器组件包括前端控制器DispatcherServlet、HandlerMapping和Controller的说法是否正确?","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"在ssm框架使用中关于SpringMVC，Springmvc属于spring框架的一部分。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"在ssm框架使用中关于SpringMVC，SpringMVC采用了松散耦合可插拔组件结构，比其他MVC框架更具扩展性和灵活性。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"在ssm框架使用中除了SpringMVC，还可以用其它方式实现文件上传下载功能。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"在ssm框架使用中SpringMVC中的Controller默认Scope不是单例（singleton）的。","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"}]