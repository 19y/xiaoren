[{"题干":"ssm框架整合时一般使用的控制层框架是","选项F":"","选项E":"","选项D":"mybatis","答案":"A","选项C":"struts2","选项B":"spring","选项A":"springmvc","类型":"1-单选"},{"题干":"对于参数contextConfigLocation的解释正确的是","选项F":"","选项E":"","选项D":"声明框架核心配置文件的位置及其名称","答案":"D","选项C":"没有任何意义","选项B":"声明框架核心配置文件的位置","选项A":"声明框架核心配置文件的名称","类型":"1-单选"},{"题干":"对于web.xml中代码classpath:springmvc.xml中classpath解释正确的是","选项F":"","选项E":"","选项D":"指的是路径web-inf","答案":"C","选项C":"classpath指的是类路径，即src","选项B":"classpath指的是项目的根路径","选项A":"声明配置文件的名称","类型":"1-单选"},{"题干":"SSM框架整合时使用的持久层框架是","选项F":"","选项E":"","选项D":"ibatis","答案":"A","选项C":"jdbc","选项B":"hibernate","选项A":"mybatis","类型":"1-单选"},{"题干":"关于resultMap描述正确的是","选项F":"","选项E":"","选项D":"既可以作为属性，也可以作为标签使用","答案":"D","选项C":"resultMap属于insert标签的一个属性，用来接收返回值","选项B":"仅仅是select标签当中的一个属性","选项A":"仅仅是一个标签","类型":"1-单选"},{"题干":"1533177992870mybatis新增数据之后，如果想得到影响的记录条数，以下说法正确的是","选项F":"","选项E":"","选项D":"可以直接在后台代码中接收，但是不能通过insert标签中属性resultType来进行声明","答案":"D","选项C":"返回值可以声明为resultType=\"int\"","选项B":"新增如果有返回值就必须在insert标签中通过对应的属性来进行声明","选项A":"在insert标签中使用resultType来接收新增的返回值","类型":"1-单选"},{"题干":"mybatis一对一配置应该使用的标签是","选项F":"","选项E":"","选项D":"association","答案":"D","选项C":"sql","选项B":"resultMap","选项A":"collction","类型":"1-单选"},{"题干":"resultType和resultMap区别错误的是（\u00A0\u00A0）","选项F":"","选项E":"","选项D":"resultType跟resultMap不可以同时存在","答案":"B","选项C":"在MyBatis进行查询映射时，其实查询出来的每一个属性都是放在一个对应的Map里面的，其中键是属性名，值则是其对应的值","选项B":"返回类型是resultMap时不需要配置对应的resultMap标签","选项A":"返回类型是resultType时不需要配置对应的resultMap标签","类型":"1-单选"},{"题干":"mybatis中#和$的区别说法不正确的是（\u00A0\u00A0）","选项F":"","选项E":"","选项D":"使用#接收值的语法是#{value}","答案":"C","选项C":"模糊查询时候，接收值必须使用#","选项B":"#可以防止sql的注入","选项A":"能用#就尽量少使用$","类型":"1-单选"},{"题干":"Mybatis中配置方言的标签是：（）","选项F":"","选项E":"","选项D":"property","答案":"D","选项C":"beans","选项B":"properties","选项A":"bean","类型":"1-单选"},{"题干":"1535011712304SSM整合时一般使用的控制层框架是","选项F":"","选项E":"","选项D":"mybatis","答案":"A","选项C":"struts2","选项B":"spring","选项A":"springmvc","类型":"1-单选"},{"题干":"1535011848673Context初始化参数名contextConfigLocation的解释正确的是","选项F":"","选项E":"","选项D":"声明框架核心配置文件的位置及其名称","答案":"D","选项C":"没有任何意义","选项B":"声明框架核心配置文件的位置","选项A":"声明框架核心配置文件的名称","类型":"1-单选"},{"题干":"1535012571820在web.xml配置过程中classpath:springmvc.xml中classpath解释正确的是","选项F":"","选项E":"","选项D":"指的是路径web-inf","答案":"C","选项C":"classpath指的是类路径，即src","选项B":"classpath指的是项目的根路径","选项A":"声明配置文件的名称","类型":"1-单选"},{"题干":"1535011691589SSM整合时一般使用的持久层框架是","选项F":"","选项E":"","选项D":"ibatis","答案":"A","选项C":"jdbc","选项B":"hibernate","选项A":"mybatis","类型":"1-单选"},{"题干":"以下resultMap描述正确的是","选项F":"","选项E":"","选项D":"既可以作为属性，也可以作为标签使用","答案":"D","选项C":"resultMap属于insert标签的一个属性，用来接收返回值","选项B":"仅仅是select标签当中的一个属性","选项A":"仅仅是一个标签","类型":"1-单选"},{"题干":"1534905861199在Mybatis新增数据之后，为了得到影响的记录条数，以下说法正确的是","选项F":"","选项E":"","选项D":"可以直接在后台代码中接收，但是不能通过insert标签中属性resultType来进行声明","答案":"D","选项C":"返回值可以声明为resultType=\"int\"","选项B":"新增如果有返回值就必须在insert标签中通过对应的属性来进行声明","选项A":"在insert标签中使用resultType来接收新增的返回值","类型":"1-单选"},{"题干":"mybatis关联映射一对一配置应该使用的标签是","选项F":"","选项E":"","选项D":"association","答案":"D","选项C":"sql","选项B":"resultMap","选项A":"collction","类型":"1-单选"},{"题干":"属性resultType和属性resultMap区别错误的是（  ）","选项F":"","选项E":"","选项D":"resultType跟resultMap不可以同时存在","答案":"B","选项C":"在MyBatis进行查询映射时，其实查询出来的每一个属性都是放在一个对应的Map里面的，其中键是属性名，值则是其对应的值","选项B":"返回类型是resultMap时不需要配置对应的resultMap标签","选项A":"返回类型是resultType时不需要配置对应的resultMap标签","类型":"1-单选"},{"题干":"在Mybatis中#和$的区别说法不正确的是（  ）","选项F":"","选项E":"","选项D":"使用#接收值的语法是#{value}","答案":"C","选项C":"模糊查询时候，接收值必须使用#","选项B":"#可以防止sql的注入","选项A":"能用#就尽量少使用$","类型":"1-单选"},{"题干":"1535011517342在Mybatis中配置方言的标签是：（）","选项F":"","选项E":"","选项D":"property","答案":"D","选项C":"beans","选项B":"properties","选项A":"bean","类型":"1-单选"},{"题干":"抽象类与接口区别的说法，以下描述不对的是（）：","选项F":"","选项E":"","选项D":"D 接口中不定义任何与实现相关的内容，在抽象类中可以定义具有具体实现的方法","答案":"B","选项C":"C 接口是对行为的抽象，如：“可以飞” 是个接口，它是对各种可飞的实体的行为的抽象","选项B":"B 抽象类比接口定义更灵活，可以完全代替接口","选项A":"A 抽象类是对实体的抽象，如交通工具就是一个抽象类，它是对各式各样的交通工具的抽象","类型":"1-单选"},{"题干":"抽象说法错误的是：：","选项F":"","选项E":"","选项D":"D  抽象类不能直接实例化对象","答案":"C","选项C":"C  抽象类，必须有抽象方法","选项B":"B  有抽象方法的类，需要定义为抽象类","选项A":"A  抽象方法不可以有{}实现","类型":"1-单选"},{"题干":"关于接口中的成员变量可以使用的访问修饰符是（  ）。","选项F":"","选项E":"","选项D":"private","答案":"A","选项C":"default","选项B":"protected","选项A":"public","类型":"1-单选"},{"题干":"如果方法不需要返回值时，方法的返回值类型应该是：：","选项F":"","选项E":"","选项D":"D  void","答案":"D","选项C":"C  null","选项B":"B  \"\"","选项A":"A  不写","类型":"1-单选"},{"题干":"关于声明抽象类和抽象方法用到的关键字是（）。","选项F":"","选项E":"","选项D":"extends","答案":"A","选项C":"interface","选项B":"class","选项A":"abstract","类型":"1-单选"},{"题干":"接口的定义和实现，以下描述正确的是()。","选项F":"","选项E":"","选项D":"如果一个类实现一个接口，则必须实现该接口中的所有方法，但方法不必声明为 public。","答案":"A","选项C":"如果一个接口由多个类来实现，则这些类在实现该接口中的方法时应采用统一的代码。","选项B":"接口定义中的变量都必须写明 final 和 static。","选项A":"接口定义中的方法都只有定义没有实现。","类型":"1-单选"},{"题干":"关于接口的说法中正确的是（  ）。","选项F":"","选项E":"","选项D":"一个接口可以有多个父接口","答案":"D","选项C":"接口之间不能有继承关系","选项B":"一个类不可以实现多个接口","选项A":"一个接口只能有一个父接口","类型":"1-单选"},{"题干":"以下代码，从选项中选择正确重写父类方法的选项（  ）。\nclass A {\nprotected int method1(int a, int b) { return 0; }\n}\npublic class B extends A{ \n//选项中选择...\n}","选项F":"","选项E":"","选项D":"protected int method1(int a, long b) { return 0; }","答案":"B","选项C":"protected long method1(int a, int b) { return 0; }","选项B":"public int method1(int a, int b) { return 0; }","选项A":"private int method1(int a, int b) { return 0; }","类型":"1-单选"},{"题干":"关于接口说法正确的是：：","选项F":"","选项E":"","选项D":"D  接口中的属性可以定义为private","答案":"C","选项C":"C  接口中的属性都是常量，不能修改值","选项B":"B  接口中的方法可以定义为private","选项A":"A  接口中的方法都是抽象的，所以必须显式的用abstract修饰，不能有实现","类型":"1-单选"},{"题干":"对于抽象类的使用描述有误的是()。","选项F":"","选项E":"","选项D":"抽象类里只可以定义常量，不可以定义普通变量。","答案":"D","选项C":"抽象类声明的对象必须依靠子类进行实例化才能使用。","选项B":"不能直接实例化抽象类","选项A":"可以使用抽象类来声明对象","类型":"1-单选"},{"题干":"有关接口的说法中正确的是()。","选项F":"","选项E":"","选项D":"普通类实现一个接口必须实现接口的所有方法。","答案":"D","选项C":"接口之间不能有继承关系。","选项B":"一个类不可以实现多个接口。","选项A":"接口与抽象类是相同的概念。","类型":"1-单选"},{"题干":"对抽象类描述正确的是（  ）。","选项F":"","选项E":"","选项D":"既不能用以创建对象，也不可用来派生新类","答案":"B","选项C":"既可用以创建对象，也可用以派生新类","选项B":"只能用以派生新类，不能用以创建对象","选项A":"只能用以创建对象，不能用以派生新类","类型":"1-单选"},{"题干":"封装的目的：：","选项F":"","选项E":"","选项D":"D  私有化数据，可以保证数据的安全性","答案":"D","选项C":"C  代码复用","选项B":"B  简化代码","选项A":"A  所有的方法都必须是公共的方法，提供访问","类型":"1-单选"},{"题干":"接口或类定义正确的是（  ）。","选项F":"","选项E":"","选项D":"public class A { \nprivate int x; \npublic getx(){ return x; } \n}","答案":"C","选项C":"public abstract class A { \nprivate int x; \npublic abstract int getx(); \npublic int amethod() { return 0; }\n}","选项B":"public class A { \nprivate int x;\npublic abstract int getx(); \n}","选项A":"public interface A { \nprivate int x;\npublic int getx() { return x; }\n}","类型":"1-单选"},{"题干":"对面向接口编程的说法错误的是()。","选项F":"","选项E":"","选项D":"提高可维护性降低耦合","答案":"B","选项C":"提高编程的灵活性","选项B":"增加了代码量，并且封装了具体实现，很难理解，这是语言设计的缺陷","选项A":"更加抽象 ，更加面向对象","类型":"1-单选"},{"题干":"int j=1;\n  for( int i=j++; i&lt;3; i++){\n     System.out.print(i);\n  }\n输出结果是：：","选项F":"","选项E":"","选项D":"D  2","答案":"B","选项C":"C  234","选项B":"B  12","选项A":"A  123","类型":"1-单选"},{"题干":"说法中正确的是（  ）。","选项F":"","选项E":"","选项D":"对于抽象方法方法体可有可无","答案":"C","选项C":"抽象方法没有方法体","选项B":"abstract修饰符可修饰字段、方法和类","选项A":"抽象方法的方法体必须用一对大括号{ }包住","类型":"1-单选"},{"题干":"对于接口是Java面向对象的实现机制之一，以下关于接口的说法中正确的是（  ）。","选项F":"","选项E":"","选项D":"在Java中一个类可只能有一个父类，也只能实现一个接口","答案":"B","选项C":"在Java中一个类可以有多个父类，但是只能实现一个接口","选项B":"在Java中一个类可只能有一个父类，但是可以实现多个接口","选项A":"Java中一个类可以有多个父类，也可以实现多个接口","类型":"1-单选"},{"题干":"1535505171整合ssm框架时一般使用的控制层框架是","选项F":"","选项E":"","选项D":"mybatis","答案":"A","选项C":"struts2","选项B":"spring","选项A":"springmvc","类型":"1-单选"},{"题干":"1535505171有关参数contextConfigLocation的解释如下那个选项正确","选项F":"","选项E":"","选项D":"声明框架核心配置文件的位置及其名称","答案":"D","选项C":"没有任何意义","选项B":"声明框架核心配置文件的位置","选项A":"声明框架核心配置文件的名称","类型":"1-单选"},{"题干":"1535505171在web.xml中代码classpath:springmvc.xml中classpath解释正确的是","选项F":"","选项E":"","选项D":"指的是路径web-inf","答案":"C","选项C":"classpath指的是类路径，即src","选项B":"classpath指的是项目的根路径","选项A":"声明配置文件的名称","类型":"1-单选"},{"题干":"1535505171SSM框架整合时使用如下那个持久层框架","选项F":"","选项E":"","选项D":"ibatis","答案":"A","选项C":"jdbc","选项B":"hibernate","选项A":"mybatis","类型":"1-单选"},{"题干":"1535505171Mybatis中配置方言的标签是如下选项的那个","选项F":"","选项E":"","选项D":"property","答案":"D","选项C":"beans","选项B":"properties","选项A":"bean","类型":"1-单选"},{"题干":"1535505171对于resultMap描述下面那个选项正确","选项F":"","选项E":"","选项D":"既可以作为属性，也可以作为标签使用","答案":"D","选项C":"resultMap属于insert标签的一个属性，用来接收返回值","选项B":"仅仅是select标签当中的一个属性","选项A":"仅仅是一个标签","类型":"1-单选"},{"题干":"1535505171关于Spring MVC的核心控制器DispatcherServlet的作用，以下说法错误的是？","选项F":"","选项E":"","选项D":"初始化上下应用对象ApplicationContext","答案":"C","选项C":"实现业务操作","选项B":"加载配置文件","选项A":"它负责接收HTTP请求","类型":"1-单选"},{"题干":"1535505171应该使用的如下那个标签去配置mybatis关联映射一对一映射","选项F":"","选项E":"","选项D":"association","答案":"D","选项C":"sql","选项B":"resultMap","选项A":"collction","类型":"1-单选"},{"题干":"1535505171描述属性resultType和属性resultMap区别时候错误说法的是如下那个选项？","选项F":"","选项E":"","选项D":"resultType跟resultMap不可以同时存在","答案":"B","选项C":"在MyBatis进行查询映射时，其实查询出来的每一个属性都是放在一个对应的Map里面的，其中键是属性名，值则是其对应的值","选项B":"返回类型是resultMap时不需要配置对应的resultMap标签","选项A":"返回类型是resultType时不需要配置对应的resultMap标签","类型":"1-单选"},{"题干":"1535505171在Mybatis中#和$的区别下面那个选项描述错误（  ）","选项F":"","选项E":"","选项D":"使用#接收值的语法是#{value}","答案":"C","选项C":"模糊查询时候，接收值必须使用#","选项B":"#可以防止sql的注入","选项A":"能用#就尽量少使用$","类型":"1-单选"},{"题干":"整合ssm框架时一般使用的控制层框架是","选项F":"","选项E":"","选项D":"mybatis","答案":"A","选项C":"struts2","选项B":"spring","选项A":"springmvc","类型":"1-单选"},{"题干":"有关参数contextConfigLocation的解释如下那个选项正确","选项F":"","选项E":"","选项D":"声明框架核心配置文件的位置及其名称","答案":"D","选项C":"没有任何意义","选项B":"声明框架核心配置文件的位置","选项A":"声明框架核心配置文件的名称","类型":"1-单选"},{"题干":"在web.xml中代码classpath:springmvc.xml中classpath解释正确的是","选项F":"","选项E":"","选项D":"指的是路径web-inf","答案":"C","选项C":"classpath指的是类路径，即src","选项B":"classpath指的是项目的根路径","选项A":"声明配置文件的名称","类型":"1-单选"},{"题干":"SSM框架整合时使用如下那个持久层框架","选项F":"","选项E":"","选项D":"ibatis","答案":"A","选项C":"jdbc","选项B":"hibernate","选项A":"mybatis","类型":"1-单选"},{"题干":"Mybatis中配置方言的标签是如下选项的那个","选项F":"","选项E":"","选项D":"property","答案":"D","选项C":"beans","选项B":"properties","选项A":"bean","类型":"1-单选"},{"题干":"对于resultMap描述下面那个选项正确","选项F":"","选项E":"","选项D":"既可以作为属性，也可以作为标签使用","答案":"D","选项C":"resultMap属于insert标签的一个属性，用来接收返回值","选项B":"仅仅是select标签当中的一个属性","选项A":"仅仅是一个标签","类型":"1-单选"},{"题干":"关于Spring MVC的核心控制器DispatcherServlet的作用，以下说法错误的是？","选项F":"","选项E":"","选项D":"初始化上下应用对象ApplicationContext","答案":"C","选项C":"实现业务操作","选项B":"加载配置文件","选项A":"它负责接收HTTP请求","类型":"1-单选"},{"题干":"应该使用的如下那个标签去配置mybatis关联映射一对一映射","选项F":"","选项E":"","选项D":"association","答案":"D","选项C":"sql","选项B":"resultMap","选项A":"collction","类型":"1-单选"},{"题干":"描述属性resultType和属性resultMap区别时候错误说法的是如下那个选项？","选项F":"","选项E":"","选项D":"resultType跟resultMap不可以同时存在","答案":"B","选项C":"在MyBatis进行查询映射时，其实查询出来的每一个属性都是放在一个对应的Map里面的，其中键是属性名，值则是其对应的值","选项B":"返回类型是resultMap时不需要配置对应的resultMap标签","选项A":"返回类型是resultType时不需要配置对应的resultMap标签","类型":"1-单选"},{"题干":"在Mybatis中#和$的区别下面那个选项描述错误（  ）","选项F":"","选项E":"","选项D":"使用#接收值的语法是#{value}","答案":"C","选项C":"模糊查询时候，接收值必须使用#","选项B":"#可以防止sql的注入","选项A":"能用#就尽量少使用$","类型":"1-单选"},{"题干":"Springmvc中自定义拦截器的标签是","选项F":"","选项E":"","选项D":"mvc:interceptor","答案":"BD","选项C":"property","选项B":"bean","选项A":"mvc:interceptors","类型":"2-多选"},{"题干":"关于springmvc以下描述正确的是","选项F":"","选项E":"","选项D":"apache公司的产品","答案":"AB","选项C":"属于Jboss组织的产品","选项B":"典型的、优秀的、开源的控制层框架","选项A":"springmvc属于spring的一部分","类型":"2-多选"},{"题干":"以下哪些标签是springmvc核心配置文件中可以存在的标签","选项F":"","选项E":"","选项D":"mvc:annotation-driven","答案":"ABCD","选项C":"property","选项B":"beans","选项A":"bean","类型":"2-多选"},{"题干":"关于属于事务特性的是","选项F":"","选项E":"","选项D":"原子性","答案":"ABCD","选项C":"隔离性","选项B":"持久性","选项A":"一致性","类型":"2-多选"},{"题干":"mybatis的特点有","选项F":"","选项E":"","选项D":"mybatis的执行效率低于hibernate","答案":"ABC","选项C":"开发简单，尤其是对于新手，可以快速的入门","选项B":"orm框架，但是不是全自动的orm框架","选项A":"优秀的持久层框架","类型":"2-多选"},{"题干":"1535011616179在Springmvc中自定义拦截器的标签是","选项F":"","选项E":"","选项D":"mvc:interceptor","答案":"BD","选项C":"property","选项B":"bean","选项A":"mvc:interceptors","类型":"2-多选"},{"题干":"1535011728910关于springmvc以下描述正确的是","选项F":"","选项E":"","选项D":"apache公司的产品","答案":"AB","选项C":"属于Jboss组织的产品","选项B":"典型的、优秀的、开源的控制层框架","选项A":"springmvc属于spring的一部分","类型":"2-多选"},{"题干":"1535011546332以下哪些标签是springmvc核心配置文件中可以存在的标签","选项F":"","选项E":"","选项D":"mvc:annotation-driven","答案":"ABCD","选项C":"property","选项B":"beans","选项A":"bean","类型":"2-多选"},{"题干":"1535011756912以下属于事务特性的是","选项F":"","选项E":"","选项D":"原子性","答案":"ABCD","选项C":"隔离性","选项B":"持久性","选项A":"一致性","类型":"2-多选"},{"题干":"1535011802318以下描述Mybatis的特点有","选项F":"","选项E":"","选项D":"mybatis的执行效率低于hibernate","答案":"ABC","选项C":"开发简单，尤其是对于新手，可以快速的入门","选项B":"orm框架，但是不是全自动的orm框架","选项A":"优秀的持久层框架","类型":"2-多选"},{"题干":"修饰符可用于修饰接口中的变量的有（  ）。","选项F":"","选项E":"","选项D":"abstract","答案":"BC","选项C":"final","选项B":"static","选项A":"protected","类型":"2-多选"},{"题干":"修饰符可以用于修饰接口中的变量的是","选项F":"","选项E":"","选项D":"abstract","答案":"BC","选项C":"final","选项B":"static","选项A":"protectde","类型":"2-多选"},{"题干":"关于super说法错误的是：","选项F":"","选项E":"","选项D":"D  super代表当前类实例","答案":"BCD","选项C":"C  super()代表调用本类无参数构造方法","选项B":"B  super()和this()可以在同一个构造方法中同时使用，互不影响","选项A":"A  默认情况下，类的所有构造方法默认都有super(),表示默认调用父类无参数构造方法","类型":"2-多选"},{"题干":"访问修饰符说法正确的是：","选项F":"","选项E":"","选项D":"D protected访问范围为不同包的子类","答案":"ABCD","选项C":"C public任何范围可访问","选项B":"B default为相同包内可访问","选项A":"A private只能在本类内访问","类型":"2-多选"},{"题干":"代码是调用父类构造器的有（  ）。","选项F":"","选项E":"","选项D":"super.say();","答案":"AC","选项C":"super();","选项B":"super.say(\"小王\");","选项A":"super(\"小王\");","类型":"2-多选"},{"题干":"修饰符可以用于修饰接口中的方法的有（  ）。","选项F":"","选项E":"","选项D":"abstract","答案":"AD","选项C":"final","选项B":"static","选项A":"public","类型":"2-多选"},{"题干":"修饰符可以用于修饰接口中的方法的是","选项F":"","选项E":"","选项D":"abstract","答案":"AD","选项C":"final","选项B":"static","选项A":"public","类型":"2-多选"},{"题干":"下面学生类Student的构造方法正确的是：：","选项F":"","选项E":"","选项D":"D Student(){}","答案":"CD","选项C":"C public Student(){}","选项B":"B public student(String name){}","选项A":"A public void Student(){}","类型":"2-多选"},{"题干":"下列对抽象类的描述正确的有（  ）。","选项F":"","选项E":"","选项D":"不能通过抽象类本身进行实例化对象","答案":"BD","选项C":"不能使用抽象类声明对象","选项B":"抽象类里面有构造器","选项A":"抽象类里面没有构造器","类型":"2-多选"},{"题干":"关于重写，遵循的规则以下选项描述正确的有（）：","选项F":"","选项E":"","选项D":"D 普通方法能被重写，父类中的final方法不能被重写。","答案":"ACD","选项C":"C 重写方法必须和被重写方法具有相同的参数列表，返回类型必须和被重写方法的返回类型相同或者是返回类型的子类型。","选项B":"B final修饰的方法是可以被子类重写","选项A":"A 重写方法的访问控制修饰符不能比被重写方法更严格（比如一个在父类中声明为public的方法重写成一个protected的方法）","类型":"2-多选"},{"题干":"关于this说法正确的是：：","选项F":"","选项E":"","选项D":"D this可以在成员方法中使用","答案":"BD","选项C":"C this代表父类的实例","选项B":"B this代表当前类的实例","选项A":"A this可以在静态方法中使用","类型":"2-多选"},{"题干":"static说法正确的是：：","选项F":"","选项E":"","选项D":"D 静态方法可以直接使用成员变量","答案":"ABC","选项C":"C 静态方法可以直接使用静态变量","选项B":"B 静态变量被类的所有对象共享","选项A":"A 成员方法可以直接使用静态变量","类型":"2-多选"},{"题干":"1535505171关于Spring MVC的核心控制器DispatcherServlet的作用，以下说法正确的是？","选项F":"","选项E":"","选项D":"初始化上下应用对象ApplicationContext","答案":"ABD","选项C":"实现业务操作","选项B":"加载配置文件","选项A":"它负责接收HTTP请求","类型":"2-多选"},{"题干":"1535505171描述属性resultType和属性resultMap区别时候正确说法的是如下那些选项？","选项F":"","选项E":"","选项D":"resultType跟resultMap不可以同时存在","答案":"ACD","选项C":"在MyBatis进行查询映射时，其实查询出来的每一个属性都是放在一个对应的Map里面的，其中键是属性名，值则是其对应的值","选项B":"返回类型是resultMap时不需要配置对应的resultMap标签","选项A":"返回类型是resultType时不需要配置对应的resultMap标签","类型":"2-多选"},{"题干":"1535505171在Mybatis中#和$的区别下面那个选项描述正确的选项有哪些","选项F":"","选项E":"","选项D":"使用#接收值的语法是#{value}","答案":"ABCD","选项C":"模糊查询时候，接收值可以使用#","选项B":"#可以防止sql的注入","选项A":"能用#就尽量少使用$","类型":"2-多选"},{"题干":"1535505171Springmvc中自定义拦截器的标签包含如下那些选项","选项F":"","选项E":"","选项D":"mvc:interceptor","答案":"BD","选项C":"property","选项B":"bean","选项A":"mvc:interceptors","类型":"2-多选"},{"题干":"1535505171对于springmvc以下描述正确的是","选项F":"","选项E":"","选项D":"apache公司的产品","答案":"AB","选项C":"属于Jboss组织的产品","选项B":"典型的、优秀的、开源的控制层框架","选项A":"springmvc属于spring的一部分","类型":"2-多选"},{"题干":"1535505171springmvc核心配置文件中可以存在以下哪些标签","选项F":"","选项E":"","选项D":"mvc:annotation-driven","答案":"ABCD","选项C":"property","选项B":"beans","选项A":"bean","类型":"2-多选"},{"题干":"1535505171以下对于属于事务特性描述正确的是","选项F":"","选项E":"","选项D":"原子性","答案":"ABCD","选项C":"隔离性","选项B":"持久性","选项A":"一致性","类型":"2-多选"},{"题干":"1535505171对于mybatis的特点说法正确的是","选项F":"","选项E":"","选项D":"mybatis的执行效率低于hibernate","答案":"ABC","选项C":"开发简单，尤其是对于新手，可以快速的入门","选项B":"orm框架，但是不是全自动的orm框架","选项A":"优秀的持久层框架","类型":"2-多选"},{"题干":"关于Spring MVC的核心控制器DispatcherServlet的作用，以下说法正确的是？","选项F":"","选项E":"","选项D":"初始化上下应用对象ApplicationContext","答案":"ABD","选项C":"实现业务操作","选项B":"加载配置文件","选项A":"它负责接收HTTP请求","类型":"2-多选"},{"题干":"描述属性resultType和属性resultMap区别时候正确说法的是如下那些选项？","选项F":"","选项E":"","选项D":"resultType跟resultMap不可以同时存在","答案":"ACD","选项C":"在MyBatis进行查询映射时，其实查询出来的每一个属性都是放在一个对应的Map里面的，其中键是属性名，值则是其对应的值","选项B":"返回类型是resultMap时不需要配置对应的resultMap标签","选项A":"返回类型是resultType时不需要配置对应的resultMap标签","类型":"2-多选"},{"题干":"在Mybatis中#和$的区别下面那个选项描述正确的选项有哪些","选项F":"","选项E":"","选项D":"使用#接收值的语法是#{value}","答案":"ABCD","选项C":"模糊查询时候，接收值可以使用#","选项B":"#可以防止sql的注入","选项A":"能用#就尽量少使用$","类型":"2-多选"},{"题干":"Springmvc中自定义拦截器的标签包含如下那些选项","选项F":"","选项E":"","选项D":"mvc:interceptor","答案":"BD","选项C":"property","选项B":"bean","选项A":"mvc:interceptors","类型":"2-多选"},{"题干":"对于springmvc以下描述正确的是","选项F":"","选项E":"","选项D":"apache公司的产品","答案":"AB","选项C":"属于Jboss组织的产品","选项B":"典型的、优秀的、开源的控制层框架","选项A":"springmvc属于spring的一部分","类型":"2-多选"},{"题干":"springmvc核心配置文件中可以存在以下哪些标签","选项F":"","选项E":"","选项D":"mvc:annotation-driven","答案":"ABCD","选项C":"property","选项B":"beans","选项A":"bean","类型":"2-多选"},{"题干":"以下对于属于事务特性描述正确的是","选项F":"","选项E":"","选项D":"原子性","答案":"ABCD","选项C":"隔离性","选项B":"持久性","选项A":"一致性","类型":"2-多选"},{"题干":"对于mybatis的特点说法正确的是","选项F":"","选项E":"","选项D":"mybatis的执行效率低于hibernate","答案":"ABC","选项C":"开发简单，尤其是对于新手，可以快速的入门","选项B":"orm框架，但是不是全自动的orm框架","选项A":"优秀的持久层框架","类型":"2-多选"},{"题干":"ssm框架中的控制层指的肯定是springmvc","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"mybatis是一个优秀的持久层框架","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"springmvc默认的核心配置文件的名称是action-servlet.xml","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"springmvc核心控制器的本质是一个filter","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"框架是软件的半成品，可以提高开发效率","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"1535012801483ssm框架整合过程中的控制层指的肯定是springmvc","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"mybatis是使用标准SQL实现ORM的一个优秀的持久层框架","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"springmvc默认的核心配置文件的名是action-servlet.xml","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"springmvc核心控制器的本质是一个过滤器","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"框架是软件的半成品，可以提高开发效率，可重用性好","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"实现接口的类不可以是抽象类。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"如果一个类可以实现多个接口，接口可以实现“多重继承”。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"构造方法是可以继承的。","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"1535505171在ssm框架中的控制层指的肯定是springmvc","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"1535505171mybatis是一个优秀的持久层ORM框架","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"1535505171springmvc默认的核心配置文件的名字为action-servlet.xml","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"1535505171springmvc核心控制器的本质是DispatcherServlet","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"1535505171框架是软件面向领域的可复用的半成品，可以提高开发效率","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"1535505171mybatis是使用标准SQL实现ORM的一个优秀的全自动持久层框架","选项F":"","选项E":"","选项D":"","答案":"B ","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"1535505171springmvc默认的核心配置文件的名为action-servlet.xml","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"1535505171springmvc核心控制器的本质就是一个过滤器","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"1535505171框架是软件的半成品，可以提高开发效率，可重用性好，有利于开发速度，普通程序员只要关系业务逻辑的编写","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"在ssm框架中的控制层指的肯定是springmvc","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"mybatis是一个优秀的持久层ORM框架","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"springmvc默认的核心配置文件的名字为action-servlet.xml","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"springmvc核心控制器的本质是DispatcherServlet","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"框架是软件面向领域的可复用的半成品，可以提高开发效率","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"mybatis是使用标准SQL实现ORM的一个优秀的全自动持久层框架","选项F":"","选项E":"","选项D":"","答案":"B ","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"springmvc默认的核心配置文件的名为action-servlet.xml","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"springmvc核心控制器的本质就是一个过滤器","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"框架是软件的半成品，可以提高开发效率，可重用性好，有利于开发速度，普通程序员只要关系业务逻辑的编写","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"}]