[{"题干":"事务管理在Spring与Hibernate整合后的正确方式是（）","选项F":"","选项E":"","选项D":"不支持使用注解","答案":"C","选项C":"在Service层通过AOP进行声明式的事务管理","选项B":"不用事务控制管理","选项A":"在DAO层进行控制管理","类型":"1-单选"},{"题干":"在Spring与Hibernate整合后获取Session的正确方法是（）","选项F":"","选项E":"","选项D":"getSession","答案":"A","选项C":"setNewSession","选项B":"openNewSession","选项A":"getCurrentSession","类型":"1-单选"},{"题干":"在Spring与Hibernate整合后，以下对数据源的描述正确的是（）","选项F":"","选项E":"","选项D":"不能配置多数据源，只能配置一个数据源","答案":"A","选项C":"数据源用于事务控制","选项B":"不用配置数据源","选项A":"可以使用数据库连接池作为数据源","类型":"1-单选"},{"题干":"以下对事务管理器在使用时描述正确的是（）","选项F":"","选项E":"","选项D":"声明式事务最大的优点就是需要通过编程的方式管理事务","答案":"C","选项C":"如果默认引入，事务管理器的名称必须是transactionManager","选项B":"事务管理器可以默认引入，其名称没有约定","选项A":"声明式事务管理无需使用事务管理器","类型":"1-单选"},{"题干":"在Spring与Hibernate整合后关于Hibernate框架配置文件的说法正确的是（）","选项F":"","选项E":"","选项D":"Hibernate配置文件可有可无","答案":"D","选项C":"Hiberante配置文件绝对不能存在，可以通过spring配置文件进行配置","选项B":"Hiberante配置文件如果存在，文件名必须是hibernate.cfg.xml","选项A":"Hibernate配置文件必须有，存在WEB-INF目录下","类型":"1-单选"},{"题干":"以下哪个选项是对事务传播特性Propagation.REQUIRED的正确描述（）","选项F":"","选项E":"","选项D":"新建事务，如果当前存在事务，把当前事务挂起。","答案":"C","选项C":"业务方法要在事务中运行，如果有事务就在当前事务中运行，如果没有事务则创建一个新事务","选项B":"业务方法不需要在事务中运行，如果存在事务则抛出异常","选项A":"业务方法要在事务中运行，如果没有事务则抛出异常","类型":"1-单选"},{"题干":"Spring与Hibernate整合时在配置Hibernate事务管理器时，以下说法正确的是（  ）。","选项F":"","选项E":"","选项D":"要注入transactionProxyFactoryBean","答案":"B","选项C":"要注入baseHibernateDao","选项B":"要注入sessionFactory","选项A":"要注入dataSource","类型":"1-单选"},{"题干":"事务管理器的bean名字是transactionManager,在进行声明式事务控制管理时可以在Service实现类上使用注解@Transactional,此时需要在Spring与Hibernate整合的配置文件中加入（）","选项F":"","选项E":"","选项D":"<tx:annotation-driven transaction-manager=\"transactionManager\"/>","答案":"D","选项C":"<util:annotation-driven transaction-manager=\"transactionManager\"/>","选项B":"<aop:annotation-driven transaction-manager=\"transactionManager\"/>","选项A":"<mvc:annotation-driven transaction-manager=\"transactionManager\"/>","类型":"1-单选"},{"题干":"关于spring与Hibernate整合，下列说法错误的是（）","选项F":"","选项E":"","选项D":"Spring提供HibernateDaoSupport类来简化Hibernate的使用","答案":"A","选项C":"通过Spring，在DAO类中无须实例化SessionFactory，而是通过注入获得","选项B":"通过Spring，在控制层(业务逻辑层)代码中无须直接实例化DAO类，而是通过注入获得","选项A":"通过Spring与Hibernate集成，以Spring管理程序的依赖关系，将SessionFactory注入DataSource","类型":"1-单选"},{"题干":"以下对声明式的事务管理说法正确的是（）","选项F":"","选项E":"","选项D":"增加了使用Hibernate的难度","答案":"B","选项C":"增加代码量","选项B":"提高开发效率","选项A":"降低开发效率","类型":"1-单选"},{"题干":"在Spring中可以通过以下哪种方式实现依赖注入","选项F":"","选项E":"","选项D":"setter方法","答案":"D","选项C":"getter方法","选项B":"自定义赋值方法","选项A":"静态方法","类型":"1-单选"},{"题干":"关于spring与Hibernate整合，HibernateTemplate的作用是什么","选项F":"","选项E":"","选项D":"增加了使用Hibernate的难度","答案":"B","选项C":"增加代码量","选项B":"提高开发效率","选项A":"降低开发效率","类型":"1-单选"},{"题干":"关于spring与Hibernate整合，HibernateDaoSupport类提供了哪种方法获得HibernateTemplate对象","选项F":"","选项E":"","选项D":"setHibernateTemplate","答案":"C","选项C":"getHibernateTemplate","选项B":"currentSession","选项A":"createHibernateTemplate","类型":"1-单选"},{"题干":"关于spring与Hibernate整合，Spring包装Hibernate之后的Hibernate的DAO应该继承哪个类","选项F":"","选项E":"","选项D":"Session","答案":"A","选项C":"SessionFactory","选项B":"HibernateDao","选项A":"HibernateDaoSupport","类型":"1-单选"},{"题干":"关于spring与Hibernate整合，HibernateTemplate的方法中哪个方法不改变数据","选项F":"","选项E":"","选项D":"save","答案":"A","选项C":"delete","选项B":"update","选项A":"get","类型":"1-单选"},{"题干":"关于spring与Hibernate整合，HibernateDaoSupport中获取当前session的方法是","选项F":"","选项E":"","选项D":"getCurrentSessession","答案":"D","选项C":"getSession","选项B":"currentSession","选项A":"setCurrentSession","类型":"1-单选"},{"题干":"Spring默认的代理方式是","选项F":"","选项E":"","选项D":"java代理","答案":"B","选项C":"静态代理","选项B":"JDK动态代理","选项A":"CgLib代理","类型":"1-单选"},{"题干":"关于spring与Hibernate整合，HibernateTemplate的方法中哪个方法删除集合内全部持久化类实例","选项F":"","选项E":"","选项D":"save","答案":"A","选项C":"update","选项B":"delete","选项A":"deleteAll","类型":"1-单选"},{"题干":"关于spring与Hibernate整合，Spring包装Hibernate之后，关于find方法说法正确的是","选项F":"","选项E":"","选项D":"参数是Collection对象","答案":"B","选项C":"参数是DetachedCriteria对象","选项B":"参数是HQL语句","选项A":"参数是Restrictions对象","类型":"1-单选"},{"题干":"关于spring与Hibernate整合，HibernateDaoSupport中获取Hibernate的SessionFactory的方法是","选项F":"","选项E":"","选项D":"getFactory","答案":"B","选项C":"setSessionFactory","选项B":"getSessionFactory","选项A":"getCurrentSessionFactory","类型":"1-单选"},{"题干":"以下哪些方法是Session的方法（）","选项F":"","选项E":"","选项D":"save","答案":"BCD","选项C":"delete","选项B":"update","选项A":"list","类型":"2-多选"},{"题干":"以下属于Spring与Hibernate整合的重要步骤的有（）","选项F":"","选项E":"","选项D":"在Dao中注入SessionFactory","答案":"ABCD","选项C":"在Spring配置文件中配置事务管理器的bean","选项B":"在Spring配置文件中配置SessionFactory的bean","选项A":"在Spring配置文件中配置数据源的bean","类型":"2-多选"},{"题干":"以下方法中不能更新数据库表的方法是（）","选项F":"","选项E":"","选项D":"get","答案":"CD","选项C":"find","选项B":"saveOrUpdate","选项A":"update","类型":"2-多选"},{"题干":"Spring与Hibernate整合时，Spring框架的ORM模块提供支持，通过Spring包装Hibernate，包括的优点有（）","选项F":"","选项E":"","选项D":"声明式的事务管理","答案":"ACD","选项C":"通用的代码管理","选项B":"异常封装","选项A":"测试简单","类型":"2-多选"},{"题干":"Spring与Hibernate整合时没有用到如下哪些Spring的模块（）","选项F":"","选项E":"","选项D":"Spring Web模块","答案":"CD","选项C":"Spring MVC模块","选项B":"Spring ORM模块","选项A":"Spring核心模块","类型":"2-多选"},{"题干":"关于spring与Hibernate整合，HibernateTemplate常用的方法有哪些","选项F":"","选项E":"","选项D":"save","答案":"ABCD","选项C":"delete","选项B":"update","选项A":"find","类型":"2-多选"},{"题干":"在Spring中可以为bean的哪些属性赋值","选项F":"","选项E":"","选项D":"普通属性","答案":"ABCD","选项C":"集合","选项B":"Properties","选项A":"Map","类型":"2-多选"},{"题干":"Spring包装Hibernate之后，能够来保存数据的方法有","选项F":"","选项E":"","选项D":"merge()","答案":"AC","选项C":"saveOrUpdate()","选项B":"load()","选项A":"save()","类型":"2-多选"},{"题干":"关于spring与Hibernate整合，使用Spring简化Hibernate的开发，需要的步骤是","选项F":"","选项E":"","选项D":"在Spring的配置文件中为Dao注入SessionFactory","答案":"ABD","选项C":"Dao接口的实现类提供SessionFactory的set/get方法","选项B":"在Dao接口的实现类继承HibernateDaoSupport","选项A":"在Spring配置文件ApplicationContext.xml创建一个名为SessionFactory的bean类的\n实现是org.Springframework.orm.hibemate3.LoactionFactoryBean","类型":"2-多选"},{"题干":"关于spring与Hibernate整合，对Hibernate的支持用到的Spring的模块中哪些不是主要的模块","选项F":"","选项E":"","选项D":"Spring\u00A0Web模块","答案":"ACD","选项C":"Spring\u00A0MVC模块","选项B":"Spring\u00A0ORM模块","选项A":"Spring\u00A0Context模块","类型":"2-多选"},{"题干":"SSH整合时为了防止Session提前关闭而导致延迟加载失败只能放弃Hibernate的延迟加载策略，而改变为立即加载。","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Hibernate中实现双向多对一关联配置后，在对关联对象生成JSON数据时不会产生任何不利的影响，也无需对重复引用问题进行处理。","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Spring与Hibernate整合过程中事务的控制可以采用声明式的事务管理配置文件方式配置或者在service层使用注解@Transactional","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"事务的传播特性确定了业务方式使用事务的方式。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"在Spring与Hibernate整合后DAO实现类可以继承HiberanteDaoSupport类，并允许注入HibernateTemplate或者SessionFactory。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"关于spring与Hibernate整合，HibernateTemplate是Hibernate\u00A0Session的轻量级封装","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Spring AOP中注解@Transactional的属性中包括rollback","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"关于spring与Hibernate整合，HibernateDaoSupport继承了HibernateTemplate类","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"关于spring与Hibernate整合，在Spring集成Hibernate必须使用HibernateDaoSupport类","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"关于spring与Hibernate整合，HibernateTemplate不支持setFirstResult方法","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"}]