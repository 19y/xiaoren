[{"题干":"以下属于Hibernate立即加载方法的是（）","选项F":"","选项E":"","选项D":"getTransaction()","答案":"A","选项C":"createQuery()","选项B":"load()","选项A":"get()","类型":"1-单选"},{"题干":"查询的HQL语句中,from关键字后面应该跟什么（）","选项F":"","选项E":"","选项D":"条件","答案":"C","选项C":"类名","选项B":"表的别名","选项A":"表名","类型":"1-单选"},{"题干":"HQL语句的特点描述正确的是（）","选项F":"","选项E":"","选项D":"只能查询","答案":"C","选项C":"面向对象","选项B":"面向数据库","选项A":"使用复杂","类型":"1-单选"},{"题干":"HQL条件查询的关键字是（）","选项F":"","选项E":"","选项D":"like","答案":"C","选项C":"where","选项B":"as","选项A":"from","类型":"1-单选"},{"题干":"Hibernate核心配置文件中注册映射文件信息的是哪个标签（）","选项F":"","选项E":"","选项D":"hibernate-configuration","答案":"B","选项C":"session-factory","选项B":"mapping","选项A":"property","类型":"1-单选"},{"题干":"事务的隔离级别中Read Uncommitted容易出现的问题是（）","选项F":"","选项E":"","选项D":"不读","答案":"B","选项C":"不可重复读","选项B":"脏读","选项A":"幻读","类型":"1-单选"},{"题干":"Mysql默认的事务隔离级别是（）","选项F":"","选项E":"","选项D":"Serializable 序列化","答案":"C","选项C":"Repeatable Read 重复读","选项B":"Read Committed 读已提交","选项A":"Read Uncommitted 读未提交","类型":"1-单选"},{"题干":"Hibernate中执行查询的方法是（）","选项F":"","选项E":"","选项D":"list()","答案":"D","选项C":"select()","选项B":"createQuery()","选项A":"save()","类型":"1-单选"},{"题干":"Hibernate执行save()方法后，加入到Session的缓存中，其操作的对象应该属于哪种状态","选项F":"","选项E":"","选项D":"没有状态","答案":"B","选项C":"临时状态","选项B":"持久状态","选项A":"游离状态","类型":"1-单选"},{"题干":"Hibernate属于哪一层框架（）","选项F":"","选项E":"","选项D":"业务层","答案":"C","选项C":"持久层","选项B":"控制层","选项A":"数据传输层","类型":"1-单选"},{"题干":"在Hibernate的HQL查询中，有如下代码\nString hql = \"select model.deptName,model.createDate from Dept as model \";\nQuery query = session.createQuery(hql);\n则query.list();返回的是","选项F":"","选项E":"","选项D":"所有包括部门名称和创建日期的对象数组的集合","答案":"D","选项C":"所有部门创建日期的集合","选项B":"所有部门名称的集合","选项A":"所有部门的集合","类型":"1-单选"},{"题干":"Hibernate的HQL查询，哪些说法是不正确的","选项F":"","选项E":"","选项D":"HQL提供了更多面向对象的封装","答案":"B","选项C":"HQL是基于SQL的","选项B":"在Hibernate3中，不可以使用update、delete子句","选项A":"在Hibernate3中，可以使用update、delete子句","类型":"1-单选"},{"题干":"在Hibernate的HQL查询中，setMaxResults(4)方法中参数值4指的是","选项F":"","选项E":"","选项D":"查询4条记录","答案":"D","选项C":"查询3条记录","选项B":"从第4条记录开始","选项A":"从第3条记录开始","类型":"1-单选"},{"题干":"在Hibernate的HQL查询中，下列说法不正确的是","选项F":"","选项E":"","选项D":"where、as关键字区分大小写","答案":"D","选项C":"HQL支持as子句","选项B":"HQL支持where子句","选项A":"HQL子句本身的大小写没有差异，但类名和属性名必须区分大小写","类型":"1-单选"},{"题干":"在Hibernate的HQL语言中，Query对象特别提供了（）方法，用于获得一个唯一行唯一列的对象","选项F":"","选项E":"","选项D":"queryResult","答案":"B","选项C":"result","选项B":"uniqueResult","选项A":"list","类型":"1-单选"},{"题干":"在Hibernate的HQL查询中，setFirstResult(2)方法中参数值2指的是","选项F":"","选项E":"","选项D":"查询2条记录","答案":"A","选项C":"查询3条记录","选项B":"从第2条记录开始","选项A":"从第3条记录开始","类型":"1-单选"},{"题干":"在Hibernate的HQL查询中，下列说法错误的是","选项F":"","选项E":"","选项D":"HQL语句可以实现类似PreparedStatement的效果","答案":"A","选项C":"HQL支持统计函数","选项B":"HQL支持只查询对象的某几个属性，查询结果将保存在一个Object数组中","选项A":"HQL查询可以执行T-SQL语句，执行速度更快","类型":"1-单选"},{"题干":"Hibernate的HQL语句：String\u00A0hql\u00A0=\"from\u00A0Dept\u00A0as\u00A0model\u00A0order\u00A0by\u00A0model.deptName,\u00A0model.createDate\u00A0desc\";所表达的意思为","选项F":"","选项E":"","选项D":"查询部门，deptName和createDate的desc排序没有先后之分","答案":"C","选项C":"查询部门，先按照deptName的asc排序，再按照createDate的desc排序","选项B":"查询部门，按照createDate的desc排序","选项A":"查询部门，按照deptName的desc排序","类型":"1-单选"},{"题干":"Hibernate的HQL，对下面代码的说法正确的是\nString hql = \"from Dept as model where model.deptName = 人事部\";\nQuery query = session.createQuery(hql);\nList<Dept> deptList = query.list();","选项F":"","选项E":"","选项D":"该HQL查询无法查出“人事部”这个部门","答案":"D","选项C":"查询成功","选项B":"查询部门名称为“人事部”的部门","选项A":"查询所有部门","类型":"1-单选"},{"题干":"在Hibernate的HQL中，下列说法不正确的是","选项F":"","选项E":"","选项D":"HQL是面向对象的查询语言","答案":"A","选项C":"HQL是Hibernate官方推荐的查询方式","选项B":"HQL提供更加面向对象的封装","选项A":"HQL无法实现分页查询","类型":"1-单选"},{"题干":"在Hibernate的HQL查询中，下列说法不正确的是","选项F":"","选项E":"","选项D":"支持分页查询","答案":"B","选项C":"支持子查询","选项B":"不可以调用用户自定义函数","选项A":"可以调用用户自定义函数","类型":"1-单选"},{"题干":"Hibernate中默认情况下事务不支持自动提交，以下需要事务(Transaction)支持才能实现的功能有（）","选项F":"","选项E":"","选项D":"update()","答案":"CD","选项C":"delete()","选项B":"get()","选项A":"load()","类型":"2-多选"},{"题干":"Session是Hibernate中非常重要的对象，以下哪些属于Session的方法（）","选项F":"","选项E":"","选项D":"load()","答案":"BCD","选项C":"createQuery()","选项B":"save()","选项A":"list()","类型":"2-多选"},{"题干":"Transaction可以进行哪些操作（）","选项F":"","选项E":"","选项D":"回滚","答案":"BD","选项C":"删除","选项B":"提交","选项A":"增加","类型":"2-多选"},{"题干":"Hibernate映射文件中class的常用属性有（）","选项F":"","选项E":"","选项D":"property","答案":"AB","选项C":"column","选项B":"table","选项A":"name","类型":"2-多选"},{"题干":"下面不使用Query对象就能完成的查询方法是（）","选项F":"","选项E":"","选项D":"select()","答案":"BC","选项C":"load()","选项B":"get()","选项A":"list()","类型":"2-多选"},{"题干":"在Hibernate的HQL查询中，有数据库表（dept）对应的对象名称为Dept，下列HQL写法正确的有","选项F":"","选项E":"","选项D":"String hql = \"from dept \";","答案":"BC","选项C":"String hql = \"from Dept as model\";","选项B":"String hql = \"from com.hr.g3.persist.Dept \";","选项A":"String hql = \"from com.hr.g3.persist.dept as model\";","类型":"2-多选"},{"题干":"对于Hibernate的HQL查询，下列说法正确的有","选项F":"","选项E":"","选项D":"HQL查询为官方推荐的查询方式","答案":"CD","选项C":"HQL支持仅查询对象的某几个属性，查询结果保存于Object数组中","选项B":"HQL不支持统计函数","选项A":"HQL查询的select子句中必须区分大小写","类型":"2-多选"},{"题干":"Hibernate的HQL查询，关于HQL与SQL，下列说法正确的有","选项F":"","选项E":"","选项D":"HQL仅用于查询数据，不支持insert,update和delete语句","答案":"BC","选项C":"在HQL与SQL中，都包含select,insert,update,delete语句","选项B":"HQL面向对象，而SQL操纵关系数据库","选项A":"HQL与SQL没有多少差别","类型":"2-多选"},{"题干":"对于Hibernate的HQL，下列关于HQL参数绑定的写法正确的有（    ）\nString hql =\"from Dept as model where model.deptName =? and model.createDate =? \";","选项F":"","选项E":"","选项D":"设置参数的方法为：setParameter()","答案":"AD","选项C":"设置参数的方法为：setEntity()","选项B":"第一个参数的位置为1","选项A":"第一个参数的位置为0","类型":"2-多选"},{"题干":"对于Hibernate的HQL，关于Query接口绑定参数的方法，说法正确的是","选项F":"","选项E":"","选项D":"setProperties( )方法用于绑定命名参数","答案":"ABCD","选项C":"setProperties( )有重载的方法","选项B":"setParameter( )有重载的方法","选项A":"setParameter( )方法用于绑定任意类型的参数","类型":"2-多选"},{"题干":"事务隔离级别中Serializable 序列化的运行速度是最快的。","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"临时状态无法转换为持久状态。","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"只有Query对象能进行查询。","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Hibernate映射文件中的主键生成策略中native是自动递增的意思。","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"事务隔离级别最高的是Serializable。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"对于Hibernate的HQL，HQL中类名和属性名不用区分大小写","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"在Hibernate的HQL的连接查询，left outer join fetch或left join fetch用于迫切左外连接","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Hibernate的HQL查询语句中用\"?\"来定义参数位置,参数位置编号下标从1开始","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Hibernate的HQL中没有表和字段的概念，只有类、对象和属性的概念","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Hibernate的HQL查询中排序使用order by关键字，升序使用desc，降序使用asc","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"}]