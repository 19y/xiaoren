[{"题干":"以下属于Hibernate懒加载方法的是（）","选项F":"","选项E":"","选项D":"getTransaction()","答案":"B","选项C":"createQuery()","选项B":"load()","选项A":"get()","类型":"1-单选"},{"题干":"在Hibernate中刚刚使用new关键字创建出来的对象属于那种状态（）","选项F":"","选项E":"","选项D":"没有状态","答案":"C","选项C":"临时状态","选项B":"持久状态","选项A":"游离状态","类型":"1-单选"},{"题干":"被Hibernate操作并在数据库生效后，在session关闭之前，对象处于哪种状态？","选项F":"","选项E":"","选项D":"没有状态","答案":"B","选项C":"临时状态","选项B":"持久状态","选项A":"游离状态","类型":"1-单选"},{"题干":"在Session关闭之后被Session操作过的对象处于那种状态（）","选项F":"","选项E":"","选项D":"没有状态","答案":"A","选项C":"临时状态","选项B":"持久状态","选项A":"游离状态","类型":"1-单选"},{"题干":"Hibernate核心配置文件中的根标签是（）","选项F":"","选项E":"","选项D":"hibernate-configuration","答案":"D","选项C":"class","选项B":"property","选项A":"session-factory","类型":"1-单选"},{"题干":"Hibernate中可以实现数据增加的方法是（）","选项F":"","选项E":"","选项D":"insert()","答案":"A","选项C":"update()","选项B":"delete()","选项A":"save()","类型":"1-单选"},{"题干":"以下不需要事务支持就能执行的方法是（）","选项F":"","选项E":"","选项D":"update()","答案":"B","选项C":"delete()","选项B":"get()","选项A":"saveOrUpdate()","类型":"1-单选"},{"题干":"ORM框架是指（）","选项F":"","选项E":"","选项D":"对象关系型框架","答案":"D","选项C":"Hibernate框架","选项B":"对象反转框架","选项A":"轻量级框架","类型":"1-单选"},{"题干":"Hibernate映射文件中用来表示实体类的标签是（）","选项F":"","选项E":"","选项D":"class","答案":"D","选项C":"hibernate-mapping","选项B":"table","选项A":"bean","类型":"1-单选"},{"题干":"Hibernate描述的映射关系中,类对应数据库中的什么（）","选项F":"","选项E":"","选项D":"主键","答案":"C","选项C":"表","选项B":"索引","选项A":"列","类型":"1-单选"},{"题干":"在Hibernate中，Session关闭之后，继续修改处于游离状态的对象，执行update()方法后，对象处于哪种状态？","选项F":"","选项E":"","选项D":"没有状态","答案":"B","选项C":"临时状态","选项B":"持久状态","选项A":"游离状态","类型":"1-单选"},{"题干":"在Hibernate中，使用session.get()方法直接数据库查询所返回的数据对象处于哪种状态","选项F":"","选项E":"","选项D":"没有状态","答案":"B","选项C":"临时状态","选项B":"持久状态","选项A":"游离状态","类型":"1-单选"},{"题干":"在Hibernate中，当一个session执行clear()方法清空session缓存后，对象处于哪种状态","选项F":"","选项E":"","选项D":"没有状态","答案":"A","选项C":"临时状态","选项B":"持久状态","选项A":"游离状态","类型":"1-单选"},{"题干":"在Hibernate中，当一个session执行evict()方法清除指定的对象后，对象处于哪种状态","选项F":"","选项E":"","选项D":"没有状态","答案":"A","选项C":"临时状态","选项B":"持久状态","选项A":"游离状态","类型":"1-单选"},{"题干":"Hibernate对JDBC访问数据库的代码进行了封装，从而大大简化了数据访问层的重复性代码，它是针对三层架构中（）的解决方案","选项F":"","选项E":"","选项D":"数据库系统","答案":"C","选项C":"持久化层","选项B":"业务逻辑层","选项A":"表现层","类型":"1-单选"},{"题干":"Hibernate中，强制同步数据到数据库里面去，用session的什么方法","选项F":"","选项E":"","选项D":"close()","答案":"A","选项C":"clear()","选项B":"delete()","选项A":"flush()","类型":"1-单选"},{"题干":"在Hibernate中，下列哪个选项不属于Session的方法","选项F":"","选项E":"","选项D":"delete()","答案":"C","选项C":"open()","选项B":"save()","选项A":"load()","类型":"1-单选"},{"题干":"Hibernate对象从游离状态到临时状态转换的方式是哪个","选项F":"","选项E":"","选项D":"调用session的evict方法","答案":"A","选项C":"调用session的clear方法","选项B":"调用session的close方法","选项A":"调用session的delete方法","类型":"1-单选"},{"题干":"Hibernate对象从临时状态到持久状态转换的方式有","选项F":"","选项E":"","选项D":"调用session的evict方法","答案":"A","选项C":"调用session的clear方法","选项B":"调用session的close方法","选项A":"调用session的save方法","类型":"1-单选"},{"题干":"事务隔离级别最高的是哪个","选项F":"","选项E":"","选项D":"Read Uncommitted：未提交数据读","答案":"A","选项C":"Read Committed：已提交数据读","选项B":"Repeatable Read：可重复读","选项A":"Serializable：串行化","类型":"1-单选"},{"题干":"Hibernate中需要事务(Transaction)支持才能实现的功能有（）","选项F":"","选项E":"","选项D":"update()","答案":"ACD","选项C":"delete()","选项B":"get()","选项A":"save()","类型":"2-多选"},{"题干":"下列可以实现数据增加的方法是（）","选项F":"","选项E":"","选项D":"saveOrUpdate()","答案":"BD","选项C":"createQuery()","选项B":"save()","选项A":"load()","类型":"2-多选"},{"题干":"下列关于事务的隔离级别描述正确的是（）","选项F":"","选项E":"","选项D":"Serializable 序列化","答案":"ABCD","选项C":"Repeatable Read 重复读","选项B":"Read Committed 读已提交","选项A":"Read Uncommitted 读未提交","类型":"2-多选"},{"题干":"Hibernate核心配置文件中跟SQL有关的选项有（）","选项F":"","选项E":"","选项D":"format_sql","答案":"BCD","选项C":"show_sql","选项B":"dialect","选项A":"hbm2ddl.auto","类型":"2-多选"},{"题干":"Hibernate框架的配置文件hibernate.cfg.xml的配置信息包括以下哪些部分（）","选项F":"","选项E":"","选项D":"监听器信息(Listener)","答案":"ABC","选项C":"映射信息(Mapping)","选项B":"Hibernate属性(运行机制)","选项A":"数据源(DataSource)","类型":"2-多选"},{"题干":"哪些属于Hibernate对象的状态","选项F":"","选项E":"","选项D":"游离状态","答案":"ACD","选项C":"持久状态","选项B":"隔离态","选项A":"临时状态","类型":"2-多选"},{"题干":"Hibernate中，下列关于SessionFactory说法正确的有","选项F":"","选项E":"","选项D":"一个SessionFactory实例对应一个数据存储源","答案":"AD","选项C":"它是轻量级的","选项B":"它不是线程安全的","选项A":"它是线程安全的","类型":"2-多选"},{"题干":"调用session的哪些方法可以让Hibernate对象从持久状态变到游离状态","选项F":"","选项E":"","选项D":"evict()","答案":"BCD","选项C":"clear()","选项B":"close()","选项A":"save()","类型":"2-多选"},{"题干":"Hibernate中，下列关于Transaction说法正确的有","选项F":"","选项E":"","选项D":"获得Transaction的方法：Transaction tr = session.beginTransaction();","答案":"ABD","选项C":"在对数据库进行查询操作时一定要加上Transaction","选项B":"在对数据库进行增加、修改和删除操作时一定要加上Transaction","选项A":"事务Transaction为应用程序指定以原子操作单元为范围的对象","类型":"2-多选"},{"题干":"Hibernate中，关于脏检查和刷新缓存说法正确的是","选项F":"","选项E":"","选项D":"编写代码时，调用commit()方法之前要调用flush()方法","答案":"AB","选项C":"在执行Session的commit()方法之前不会调用Session的flush()方法","选项B":"Session的flush()方法是刷新缓存的方法","选项A":"当事务提交时，会发生脏检查","类型":"2-多选"},{"题干":"游离状态无法转换为临时状态。","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"游离状态无法转换为持久状态。","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Hibernate核心配置文件中,dialect可以改变自动生成SQL语句的规则。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Hibernate映射文件中的主键生成策略只能是\"自动递增\"。","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"事务隔离级别最高的是Read Uncommitted。","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"使用hibernate可以简化持久层的编码","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Hibernate中，session的update方法可以增加功能","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Hibernate中，设置数据库事务隔离级别方法是，在hibernate.cfg.xml中使用hibernate.connection.isolation参数","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Hibernate中，事务隔离级别中隔离级别最差的是Read Uncommitted（未提交数据读）","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Hibernate中，通过主键查询不到数据的时候，get返回null，load抛出异常","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"}]