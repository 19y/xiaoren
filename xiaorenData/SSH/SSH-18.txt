[{"题干":"Resource和Autowired注解的区别是（）","选项F":"","选项E":"","选项D":"Resource默认按照名称注入，Autowired默认按照参数注入","答案":"B","选项C":"Resource是SpringMVC注解，Autowired是JavaEE注解","选项B":"Resource默认按照名称注入，Autowired默认按照类型注入","选项A":"Resource默认按照类型注入，Autowired默认按照名称注入","类型":"1-单选"},{"题干":"用于将请求URL中的模板变量映射到功能处理方法的参数上的注解是（）","选项F":"","选项E":"","选项D":"RequestBody","答案":"B","选项C":"VariablePath","选项B":"PathVariable","选项A":"RequestParam","类型":"1-单选"},{"题干":"对SpringMVC是一种基于Web\u00A0MVC设计模式的请求驱动类型的轻量级Web框架的理解正确的是（）","选项F":"","选项E":"","选项D":"SpringMVC是一个重量级的MVC框架","答案":"A","选项C":"SpringMVC框架已经取代了所有的MVC框架","选项B":"MVC开发模式唯一的框架是SpringMVC框架","选项A":"SpringMVC是一种轻量级的MVC框架","类型":"1-单选"},{"题干":"具有依赖关系的Bean对象，下列选项中的注解，可以实现依赖关系注入的是()","选项F":"","选项E":"","选项D":"Resource","答案":"D","选项C":"Component","选项B":"Service","选项A":"Controller","类型":"1-单选"},{"题干":"请看如下代码：\n@Controller\n@RequestMapping(\"/demo\")\npublic class HelloController{\n @RequestMapping(\"/hello\")\n public String execute() throws Exception {\n       return \"hello\";\n      }\n  }\n web.xml中配置的DispatcherServlet映射信息配置如下：\n <servlet-mapping>\n  <servlet-name>springmvc</servlet-name>\n    <url-pattern>*.do</url-pattern>\n</servlet-mapping>\n如果工程名为spring，那么访问HelloController的execute方法的路径为（）","选项F":"","选项E":"","选项D":"http://ip:端口/spring/hello/demo.do","答案":"B","选项C":"http://ip:端口/spring/hello/demo.from","选项B":"http://ip:端口/spring/demo/hello.do","选项A":"http://ip:端口/spring/demo/hello.from","类型":"1-单选"},{"题干":"在SpringMVC中核心控制器在（）配置文件中配置","选项F":"","选项E":"","选项D":"build-path.properties","答案":"A","选项C":"Tomcat配置文件中","选项B":"springmvc.xml","选项A":"web.xml","类型":"1-单选"},{"题干":"SpringMVC中文件上传过程中设置上传文件大小的bean的名字是（）","选项F":"","选项E":"","选项D":"不用命名","答案":"C","选项C":"multipartResolver","选项B":"uploadResolver","选项A":"commonsMultipartResolver","类型":"1-单选"},{"题干":"在SpringMVC中日志记录常用的组件是（）","选项F":"","选项E":"","选项D":"ORM","答案":"A","选项C":"web","选项B":"IoC","选项A":"AOP","类型":"1-单选"},{"题干":"RequestMapping注解用在类上面的作用是（）","选项F":"","选项E":"","选项D":"用于类上，表示类中的所有响应请求的方法都是以该地址作为子路径","答案":"B","选项C":"接受请求参数绑定到对象","选项B":"用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径","选项A":"与用在方法上没有区别","类型":"1-单选"},{"题干":"以下哪个注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为JSON格式后，写入到Response对象的body数据区（）","选项F":"","选项E":"","选项D":"Autowired","答案":"C","选项C":"ResponseBody","选项B":"Resource","选项A":"RequestBody","类型":"1-单选"},{"题干":"关于HQL的连接查询，说法错误的是","选项F":"","选项E":"","选项D":"right outer join fetch 或 right join fetch用于迫切右外连接","答案":"D","选项C":"left outer join fetch 或 left join fetch用于迫切左外连接","选项B":"inner join fetch或 join fetch用于迫切内连接","选项A":"inner join 或 join用于内连接","类型":"1-单选"},{"题干":"在Hibernate中，从性能方面考虑，inverse属性值通常设置为","选项F":"","选项E":"","选项D":"none","答案":"B","选项C":"true","选项B":"false","选项A":"all","类型":"1-单选"},{"题干":"关于HQL子查询中，说法错误的是","选项F":"","选项E":"","选项D":"in关键字与\"=any\"意思相同","答案":"C","选项C":"any关键字用于子查询语句返回所有记录","选项B":"elements( )用于获取集合中的所有元素","选项A":"size( )或size用于获取集合中元素的数目","类型":"1-单选"},{"题干":"在ORM中，面向对象概念中的对象与面向关系概念中的（    ）相对应","选项F":"","选项E":"","选项D":"表中行的数据","答案":"B","选项C":"表的列","选项B":"表的行","选项A":"表","类型":"1-单选"},{"题干":"使用Hibernate技术实现数据库持久化时，下列（ ）不在Hibernate配置文件中。","选项F":"","选项E":"","选项D":"数据库表和实体的映射信息","答案":"D","选项C":"show_sql参数","选项B":"数据库类型（dialect）","选项A":"数据库连接信息","类型":"1-单选"},{"题干":"在Hibernate中，哪个状态不是一个持久化类的实例可能存在的状态","选项F":"","选项E":"","选项D":"游离态","答案":"C","选项C":"隔离态","选项B":"持久态","选项A":"临时态","类型":"1-单选"},{"题干":"在Hibernate中，inverse属性值为（ ）时，会标识被控方。","选项F":"","选项E":"","选项D":"none","答案":"C","选项C":"true","选项B":"false","选项A":"all","类型":"1-单选"},{"题干":"SpringMVC的注解@RequestMapping(value={\"/show\"})能匹配的URL是","选项F":"","选项E":"","选项D":"/showx","答案":"A","选项C":"/shows","选项B":"/shown","选项A":"/show","类型":"1-单选"},{"题干":"在Hibernate中，如果需要标识主控方，则inverse属性值应为","选项F":"","选项E":"","选项D":"none","答案":"B","选项C":"true","选项B":"false","选项A":"all","类型":"1-单选"},{"题干":"在Spring框架中必然用到的模块是","选项F":"","选项E":"","选项D":"Spring Web模块","答案":"A","选项C":"Spring MVC模块","选项B":"Spring ORM模块","选项A":"Spring核心模块","类型":"1-单选"},{"题干":"在Spring中，下列属于DI的注入方式的是（）","选项F":"","选项E":"","选项D":"上下文注入","答案":"AC","选项C":"构造器注入","选项B":"接口注入","选项A":"Setter注入","类型":"2-多选"},{"题干":"请看下列Spring配置文件中的代码：\n\n<bean id=\"exampleBean\" class=\"com.foo.ExampleBean \"  init-method= \"init\" />\n<bean id=\"exampleBean\" class=\"com.foo.ExampleBean\" destroy-method=\"destroy\" />\n关于上述代码说法正确的是（）","选项F":"","选项E":"","选项D":"指定了exampleBean销毁的回调方法为init","答案":"AC","选项C":"指定了exampleBean销毁的回调方法为destroy","选项B":"指定了exampleBean初始化的回调方法为destroy","选项A":"指定了exampleBean初始化的回调方法为init","类型":"2-多选"},{"题干":"下列选项中，属于Spring的Bean的作用域的是（）","选项F":"","选项E":"","选项D":"application","答案":"ABC","选项C":"Session","选项B":"Prototype","选项A":"Singleton","类型":"2-多选"},{"题干":"下列选项中，属于Spring MVC向页面传递值的方式的是（）","选项F":"","选项E":"","选项D":"使用@RequestParam注解","答案":"ABC","选项C":"使用@ModelAttribute注解","选项B":"使用ModelMap参数对象","选项A":"使用ModeAndView对象","类型":"2-多选"},{"题干":"关于SpringMVC框架，Resource注解的说法正确的是（）","选项F":"","选项E":"","选项D":"默认按照名称装配","答案":"BD","选项C":"属于Spring的","选项B":"属于JavaEE的","选项A":"默认按照类型装配","类型":"2-多选"},{"题干":"使用HQL查询所有部门信息，以下正确的是","选项F":"","选项E":"","选项D":"select d from Dept d","答案":"AD","选项C":"select Dept from cn.demo.entity.Dept","选项B":"select * from cn.demo.entity.Dept","选项A":"from Dept","类型":"2-多选"},{"题干":"在Hibernate中，以下关于主键生成器说法错误的是","选项F":"","选项E":"","选项D":"native由Hibernate根据底层数据库自行判断采用何种主键生成策略，是由使用的数据库生成主键的值","答案":"AC","选项C":"sequence用于如Oracle、SQL Server等支持序列的数据库","选项B":"identity用于如SQL Server、DB2、MySQL等支持标识列的数据库","选项A":"increment可以用于类型为long、short或byte的主键","类型":"2-多选"},{"题干":"关于Query接口的list()和iterate()方法，说法正确的是","选项F":"","选项E":"","选项D":"执行iterate()方法，查询出所有符合条件的主键值","答案":"AD","选项C":"执行list()方法，查询出所有符合条件的主键值","选项B":"执行iterate()方法，查询所有符合条件的记录","选项A":"执行list()方法，查询所有符合条件的记录","类型":"2-多选"},{"题干":"在Hibernate映射文件中，关于延迟加载配置说法错误的是","选项F":"","选项E":"","选项D":"<many-to-one>标签中lazy属性可选值：proxy、true和false","答案":"BD","选项C":"<set>标签中lazy属性可选值：true、extra和false","选项B":"<set>标签中lazy属性可选值：true、proxy和no-proxy","选项A":"<class>标签中lazy属性可选值：true、false","类型":"2-多选"},{"题干":"关于Hibernate缓存说法错误的是","选项F":"","选项E":"","选项D":"Session的flush()方法用于从缓存中清除所有持久化对象","答案":"CD","选项C":"Session的clear( )方法用于刷新缓存","选项B":"Session的evict()方法用于从缓存中清除指定的持久化对象","选项A":"Hibernate缓存一般分为三类：一级缓存、二级缓存和查询缓存","类型":"2-多选"},{"题干":"处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"SpingMVC中的控制器的注解一般用@Conntroller注解,表示是表现层,不能用@Component注解代替。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"SpringMVC是Spring的一个模块，基于MVC的一个框架，无需中间整合层来整合。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Spring通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"一个Spring Bean 的定义包含容器必知的所有配置元数据，包括如何创建一个bean，它的生命周期详情及它的依赖。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"在MVC模式中，Hibernate属于控制层","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"在Hibernate中，SessionFactory是线程安全的","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"在Hibernate中，事务Transaction为应用程序指定以原子操作单元为范围的对象","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"在Hibernate中，Session是线程安全的","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"在Hibernate中，load()属于Session的方法","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"}]