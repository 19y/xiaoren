[{"题干":"在Spring依赖注入中对Map集合进行注入说法正确的是（）","选项F":"","选项E":"","选项D":"使用maps注入键值对","答案":"A","选项C":"使用prop注入map键值对","选项B":"使用key和value标记注入键值对","选项A":"使用entry标记注入键值对","类型":"1-单选"},{"题干":"关于DI的说法正确的是（）","选项F":"","选项E":"","选项D":"DI也可以成为控制反转技术","答案":"C","选项C":"DI是依赖注入，应用程序只管获取核心容器中的bean，而bean的依赖对象的注入交给spring的核心容器完成，从而实现解耦","选项B":"DI是依赖注入，是对bean的依赖对象使用getter和构造器进行赋值的一种策略","选项A":"DI是依赖注入，在不用配置bean的情况下可以直接进行注入","类型":"1-单选"},{"题干":"Spring核心容器采用IoC的方式负责创建和管理bean,以下的描述不正确的是（）","选项F":"","选项E":"","选项D":"在Spring技术中是基于组件的","答案":"B","选项C":"是最基本也是最常用的单元","选项B":"通过new关键字实例化的对象，也可以用来做DI","选项A":"其实例保存在sprig的容器中","类型":"1-单选"},{"题干":"Spring核心模块主要构件是核心容器Core Container,其作用是（）","选项F":"","选项E":"","选项D":"是用来支持Struts的","答案":"B","选项C":"做AOP的","选项B":"做IOC的，用来管理Bean的","选项A":"是用来支持Hibernete","类型":"1-单选"},{"题干":"Spring框架中包括若干模块，以下理解有误的是（\u00A0）","选项F":"","选项E":"","选项D":"Spring包含并管理应用对象的配置和生命周期，在这个意义上它是\u00A0一种容器","答案":"B","选项C":"Spring是一个轻量级的控制反转(IoC)","选项B":"Spring不提供面向切面编程的支持","选项A":"Spring通过一种称作控制反转（IoC）的技术促进了松耦合","类型":"1-单选"},{"题干":"Spring中IoC和DI的描述正确的是（）","选项F":"","选项E":"","选项D":"依赖注入和控制反转是完全不同的两个概念","答案":"A","选项C":"依赖注入可以单独存在，不一定要在ioc的基础之上完成操作","选项B":"二者相互没有任何区别，是一回事","选项A":"IOC是控制反转，把对象创建交给spring进行配置，DI是依赖注入，向类里面的属性中设置值","类型":"1-单选"},{"题干":"Spring各模块之间的联系比较松散，以下对于Spring模块与模块之间的描述正确的是（ ）","选项F":"","选项E":"","选项D":"Spring的核心模块是必须的，其他模块是基于核心模块","答案":"D","选项C":"Spring的核心模块不是必须的，可以不要","选项B":"Spring各模块之间是紧密联系的，相互依赖的","选项A":"Spring各模块之间不可以单独存在","类型":"1-单选"},{"题干":"spring配置文件中使用哪一个节点定义一个实例（）","选项F":"","选项E":"","选项D":"context:beans","答案":"C","选项C":"bean","选项B":"beans","选项A":"application:beans","类型":"1-单选"},{"题干":"在反射中如何获取一个类实现的全部接口","选项F":"","选项E":"","选项D":"类名.classForName","答案":"A","选项C":"对象.class.getInterfaces()","选项B":"类名.class.getInterfaces","选项A":"类名.class.getClassLoader().getInterfaces()","类型":"1-单选"},{"题干":"下面关于Spring框架的理解正确的是（）","选项F":"","选项E":"","选项D":"Spring是Java标准体系内的框架","答案":"B","选项C":"Spring是一个入侵式框架","选项B":"Spring是一个轻量级的框架","选项A":"Spring是一个重量级的框架","类型":"1-单选"},{"题干":"下面哪个是依赖注入的缩写","选项F":"","选项E":"","选项D":"IOC","答案":"B","选项C":"AOP","选项B":"DI","选项A":"Bean","类型":"1-单选"},{"题干":"以下哪个注解能完成自动装配","选项F":"","选项E":"","选项D":"@import","答案":"A","选项C":"@Config","选项B":"@Res","选项A":"@Autowired","类型":"1-单选"},{"题干":"开启注解装配，需要在Spring配置文件中配置\u00A0（）元素","选项F":"","选项E":"","选项D":"<context:property-placeholder/>","答案":"C","选项C":"<context:annotation-config/>","选项B":"<context:property-override/>","选项A":"<context:component-scan/>","类型":"1-单选"},{"题干":"下面对Spring中Bean的注入说法正确的是","选项F":"","选项E":"","选项D":"构造方法通过constructor-index属性来指定，在该标签下要指定索引的位置","答案":"B","选项C":"在关系的对象很多时，使用构造方法注入更适合","选项B":"使用构造方法注入构造对象的同时，完成依赖关系的建立","选项A":"Bean根据注入方式不同可以分为构造方法注入和自动装载。","类型":"1-单选"},{"题干":"在Spring中依赖注入的说法，正确的是","选项F":"","选项E":"","选项D":"依赖注入的使用会增大程序的规模","答案":"A","选项C":"依赖注入是面向对象技术的替代品","选项B":"依赖注入即“面向接口”的编程","选项A":"依赖注入的目标是在代码之外管理程序组件间的依赖关系","类型":"1-单选"},{"题干":"Spring中的核心机制是","选项F":"","选项E":"","选项D":"资源访问","答案":"B","选项C":"声明式事务","选项B":"依赖注入","选项A":"AOP","类型":"1-单选"},{"题干":"Spring配置文件中，实现组件扫描的配置标签是","选项F":"","选项E":"","选项D":"<context:property-placeholder/>","答案":"B","选项C":"<context:property-override/>","选项B":"<context:component-scan/>","选项A":"<context:annotation-config/>","类型":"1-单选"},{"题干":"依赖注入的优点","选项F":"","选项E":"","选项D":"解耦","答案":"D","选项C":"结构复杂","选项B":"代码无法重用","选项A":"代码量增加","类型":"1-单选"},{"题干":"在Spring中，下列关于依赖注入的说法，错误的是哪个","选项F":"","选项E":"","选项D":"依赖注入可以独立开发各组件，然后根据组件间的依赖关系进行组装","答案":"B","选项C":"依赖注入提倡使用接口编程","选项B":"依赖注入使组件之间相互依赖、相互制约","选项A":"依赖注入是一种设计开发模式","类型":"1-单选"},{"题干":"Spring依赖注入对调用者和被调用者是否有要求","选项F":"","选项E":"","选项D":"对调用者和被调用者都有要求","答案":"C","选项C":"对调用者和被调用者都没有要求","选项B":"只对被调用者有要求","选项A":"只对调用者有要求","类型":"1-单选"},{"题干":"1533600262418Spring中依赖注入的方式包括（）","选项F":"","选项E":"","选项D":"实例工厂注入","答案":"AB","选项C":"静态工厂注入","选项B":"构造器注入","选项A":"setter注入","类型":"2-多选"},{"题干":"构成了Spring框架IoC容器的基础的是（）","选项F":"","选项E":"","选项D":"org.springframework.jdbc","答案":"AB","选项C":"org.springframework.web","选项B":"org.springframework.context","选项A":"Spring中的 org.springframework.beans","类型":"2-多选"},{"题干":"Spring中的BeanFactory与ApplicationContext的作用描述正确的是（）","选项F":"","选项E":"","选项D":"BeanFactory能完成的功能，ApplicationContext照样能完成","答案":"AD","选项C":"二者没有任何关系，因此彼此的作用各不相同","选项B":"ApplicationContext是BeanFactory的父接口，除了负责管理bean的加载、实例化、维护依赖关系、负责bean的生命周期外，还提供了更完整的框架功能，比如国际化、资源访问等","选项A":"BeanFactory负责读取bean的配置文件，管理bean的加载、实例化，维护bean之间的依赖关系，负责bean的生命周期","类型":"2-多选"},{"题干":"构造注入的描述正确的是（）","选项F":"","选项E":"","选项D":"对于有复杂的依赖关系，如果采用构造注入，会导致构造器过于臃肿，难以阅读","答案":"ABD","选项C":"依赖关系在构造器中设定，则只有组件的创建者才能改变组件的依赖关系。对组件的调用者而言，组件内部的依赖关系完全透明，更符合高内聚的原则","选项B":"所有的依赖关系全部在构造器内设定，因此，无须担心后续的代码对依赖关系产生破坏","选项A":"可以在构造器中决定依赖关系的注入顺序，优先依赖的优先注入","类型":"2-多选"},{"题干":"在Spring的核心模块中涉及到的设计模式有（）","选项F":"","选项E":"","选项D":"装饰模式","答案":"ABC","选项C":"原型模式","选项B":"工厂模式","选项A":"单例模式","类型":"2-多选"},{"题干":"以下哪些自动装配的方式，可以用来指导Spring容器用自动装配方式来进行依赖注入","选项F":"","选项E":"","选项D":"byMethed","答案":"AB","选项C":"auto","选项B":"byType","选项A":"byName","类型":"2-多选"},{"题干":"以下哪些属于DI注解","选项F":"","选项E":"","选项D":"@Value","答案":"ABCD","选项C":"@Qualifier","选项B":"@Autowired","选项A":"@Resource","类型":"2-多选"},{"题干":"关于依赖注入，描述正确的是","选项F":"","选项E":"","选项D":"Spring的依赖注入和控制反转是完全不同的两个概念","答案":"BC","选项C":"依赖注入能够降低系统各组件的依赖关系，提倡面向接口编程","选项B":"所谓依赖注入，就是明确地定义组件接口，独立开发各个组件\n，然后根据组件件依赖关系组装运行的设计模式","选项A":"依赖注入可以增强系统各组件的依赖关系","类型":"2-多选"},{"题干":"在Spring中，哪些DI注解可以注入一个接口","选项F":"","选项E":"","选项D":"@import","答案":"AB","选项C":"@Controller","选项B":"@Autowired","选项A":"@Resource","类型":"2-多选"},{"题干":"Spring的依赖注入通常有哪几种形式","选项F":"","选项E":"","选项D":"基于注解的依赖注入","答案":"CD","选项C":"基于xml的依赖注入","选项B":"基于html的依赖注入","选项A":"基于json的依赖注入","类型":"2-多选"},{"题干":"Spring的配置文件中，<bean>的autowire属性可能的取值包括","选项F":"","选项E":"","选项D":"no","答案":"ABCD","选项C":"constructor","选项B":"byType","选项A":"byName","类型":"2-多选"},{"题干":"在Spring中不可以注入一个null，但是可以注入一个空字符串。","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"IoC&DI的基本思想是在应用程序中把对象之间的依赖关系全部去掉，由IoC/DI容器来管理对象和对象之间的依赖关系，实现对象之间的松散耦合","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Spring中bean的作用范围包括singleton、prototype、request、session、gloable-session，框架中singleton的bean是线程安全的。","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"在一个bean实例被初始化时，需要执行一系列的初始化操作以达到可用的状态。同样的，当一个bean不在被调用时需要进行相关的析构操作，并从bean容器中移除成为Bean的生命周期管理。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Spring框架并没有对单例bean进行任何多线程的封装处理。关于单例bean的线程安全和并发问题需要开发者自行去搞定。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"依赖注入把应用的代码量降到最低","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"不可以在Spring中注入一个null和一个空字符串","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"组件之间依赖关系由容器在运行期决定","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"IoC和DI是完全相同的概念，没有任何区别","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"DI依赖注入是一个初始化实例的过程","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"}]