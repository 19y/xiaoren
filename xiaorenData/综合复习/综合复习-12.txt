[{"题干":"Solr提供各种各样的功能，不包括以下哪一类","选项F":"","选项E":"","选项D":"数据持久化","答案":"D","选项C":"全文搜索功能","选项B":"高度可扩展和容错","选项A":"分页搜索和过滤","类型":"1-单选"},{"题干":"下列不可以用来运行solr项目的web容器有","选项F":"","选项E":"","选项D":"oracle","答案":"D","选项C":"jboss","选项B":"jetty","选项A":"Tomcat","类型":"1-单选"},{"题干":"在solrconfig.xml中配置Solr如何处理和返回搜索的标签是","选项F":"","选项E":"","选项D":"<updateHandler/>","答案":"A","选项C":"<requestHandler/>","选项B":"<lib/>","选项A":"<query/>","类型":"1-单选"},{"题干":"在solrconfig.xml中以下属于配置插件jar包的标签是","选项F":"","选项E":"","选项D":"<updateHandler/>","答案":"B","选项C":"<query/>","选项B":"<lib/>","选项A":"<requestHandler/>","类型":"1-单选"},{"题干":"在solrconfig.xml中配置Solr处理各种请求的标签是","选项F":"","选项E":"","选项D":"<query/>","答案":"C","选项C":"<requestHandler/>","选项B":"<select/>","选项A":"<update/>","类型":"1-单选"},{"题干":"在solrconfig.xml中响应请求的方式的标签是","选项F":"","选项E":"","选项D":"<lib/>","答案":"B","选项C":"<updateHandler/>","选项B":"<requestDispatcher/>","选项A":"<requestHandler/>","类型":"1-单选"},{"题干":"通常我们在用java连接Solr时首先要创建（）对象","选项F":"","选项E":"","选项D":"QueryResponse","答案":"B","选项C":"SolrInputDocument","选项B":"Query","选项A":"SolrQuery","类型":"1-单选"},{"题干":"通过java代码要给solr集合添加一条数据会用到（）对象","选项F":"","选项E":"","选项D":"Query","答案":"B","选项C":"SolrQuery","选项B":"SolrInputDocument","选项A":"QueryResponse","类型":"1-单选"},{"题干":"在使用solr做带条件查询时会用到（）对象","选项F":"","选项E":"","选项D":"SolrDocumentList","答案":"A","选项C":"QueryResponse","选项B":"SolrInputDocument","选项A":"SolrQuery","类型":"1-单选"},{"题干":"如果要删除solr集合中的一条数据要根据ID删除会用到（）方法","选项F":"","选项E":"","选项D":"commit()","答案":"C","选项C":"deleteById()","选项B":"deleteByQuery()","选项A":"query()","类型":"1-单选"},{"题干":"web.xml文件的位置在","选项F":"","选项E":"","选项D":"classpath","答案":"A","选项C":"WebContent","选项B":"src","选项A":"web-inf","类型":"1-单选"},{"题干":"<filter-name>的作用是","选项F":"","选项E":"","选项D":"声明框架核心配置文件的位置及其名称","答案":"A","选项C":"没有任何意义","选项B":"声明自定义过滤器的名称","选项A":"声明过滤器的名称","类型":"1-单选"},{"题干":"对于web.xml文件的配置，forceEncoding的值如果是true","选项F":"","选项E":"","选项D":"毫无意义","答案":"A","选项C":"与properties的编码保持一致","选项B":"与jsp的编码保持一致","选项A":"代表异步请求采用的编码格式与整个项目的保持一致","类型":"1-单选"},{"题干":"ssm整合时建议将框架的核心配置文件放在哪一个位置","选项F":"","选项E":"","选项D":"dto","答案":"A","选项C":"lib","选项B":"web-inf","选项A":"scr","类型":"1-单选"},{"题干":"对于web项目配置监听ContextLoaderListener的理解正确的是","选项F":"","选项E":"","选项D":"必须配置，而且配置文件的名称必须是默认的","答案":"B","选项C":"必须配置","选项B":"项目在启动的时候加载spring配置文件中的配置项","选项A":"必须配置，但是没有任何意义","类型":"1-单选"},{"题干":"ssm整合时依赖注入最常使用并且可以按照名称注入的是","选项F":"","选项E":"","选项D":"@RequestMapping","答案":"A","选项C":"@service","选项B":"@Autowired","选项A":"@Resource","类型":"1-单选"},{"题干":"springmvc关于网络资源视图解析器的描述正确的是","选项F":"","选项E":"","选项D":"后缀没有任何的意义","答案":"A","选项C":"前缀没有任何的意义","选项B":"没有特定的解析规则","选项A":"视图解析的规则是前缀+方法的返回值+后缀","类型":"1-单选"},{"题干":"ssm整合时springmvc配置文件中建议扫描的包结构是","选项F":"","选项E":"","选项D":"dto","答案":"C","选项C":"controller","选项B":"service","选项A":"mapper","类型":"1-单选"},{"题干":"hibernate中的哪一个查询可以不用写hql语句","选项F":"","选项E":"","选项D":"saveOrUpdate","答案":"A","选项C":"save","选项B":"list","选项A":"标准查询","类型":"1-单选"},{"题干":"对于参数mapperLocations理解正确的是","选项F":"","选项E":"","选项D":"声明mapper层接口的路径","答案":"A","选项C":"声明持久层接口的路径","选项B":"没有任何意义","选项A":"声明子映射文件的位置，并且可以使用通配符进行匹配","类型":"1-单选"},{"题干":"1536195851505jQuery对原生ajax封装所产生的方法中，$.ajax()中的type指（\u00A0\u00A0）","选项F":"","选项E":"","选项D":"回调函数","答案":"B","选项C":"请求地址","选项B":"请求类型","选项A":"返回结果类型","类型":"1-单选"},{"题干":"以下不是jQuery封装ajax第二层产生的方法（  ）","选项F":"","选项E":"","选项D":"load()","答案":"C","选项C":"$.ajax()","选项B":"$.get()","选项A":"$.post()","类型":"1-单选"},{"题干":"1536199378727以下对$.ajax()中的属性说法不正确的是（\u00A0\u00A0）","选项F":"","选项E":"","选项D":"data：返回的结果数据","答案":"D","选项C":"success：请求成功执行的回调函数","选项B":"type：请求方式","选项A":"url：请求地址","类型":"1-单选"},{"题干":"以下对jQuery分装了ajax所产生的方法说法错误的是（  ）","选项F":"","选项E":"","选项D":"$.post()方法中的参数可以互换位置","答案":"D","选项C":"$.ajax()方法中的属性可以互换位置","选项B":"第二层封装产生了$.post(),$.get(),load()","选项A":"第一层封装产生了$.ajax()","类型":"1-单选"},{"题干":"不属于jQuery封装ajax之后的方法是（  ）","选项F":"","选项E":"","选项D":"$.async()","答案":"D","选项C":"$.get()","选项B":"$.post()","选项A":"$.ajax()","类型":"1-单选"},{"题干":"jQuery封装原生ajax所产生的方法中，$.post()中的dataType指（\u00A0\u00A0）","选项F":"","选项E":"","选项D":"回调函数","答案":"A","选项C":"请求地址","选项B":"请求类型","选项A":"返回结果类型","类型":"1-单选"},{"题干":"jquery中$.ajax()的error是（  ）","选项F":"","选项E":"","选项D":"请求错误后回调函数","答案":"D","选项C":"提交的请求方式","选项B":"发送请求的地址","选项A":"发送到服务器的数据","类型":"1-单选"},{"题干":"有以下标签：<input id=\"txtContent\" class=\"txt\" type=\"text\" value=\"张三\"/> \n请问不能够正确的获取文本框里面的值“张三”的语句是（  ）","选项F":"","选项E":"","选项D":"$(\"#txtContent\").attr(\"value\")","答案":"C","选项C":"$(\"#txtContent\").text()","选项B":"$(\".txt\").attr(\"value\")","选项A":"$(\".txt\").val()","类型":"1-单选"},{"题干":"以下哪个函数不是jQuery内置的与AJAX相关的函数（  ）","选项F":"","选项E":"","选项D":"$.each()","答案":"D","选项C":"$.post()","选项B":"$.get()","选项A":"$.ajax()","类型":"1-单选"},{"题干":"如果想在一个指定的元素的外部尾部添加内容，下面哪个是实现该功能的？（\u00A0\u00A0）","选项F":"","选项E":"","选项D":"after(content)","答案":"D","选项C":"insertAfter(content)","选项B":"appendTo(content)","选项A":"append(content)","类型":"1-单选"},{"题干":"使用jquery检查<input type=\"hidden\" id=\"id\" name=\"id\" />元素在网页上是否存在（  ）","选项F":"","选项E":"","选项D":"if($(\"#id\").size > 0) {   //do someing...    }","答案":"B","选项C":"if($(\"#id\").length() > 0) {   //do someing...    }","选项B":"if($(\"#id\").length > 0) {   //do someing...    }","选项A":"if($(\"#id\")) {   //do someing...    }","类型":"1-单选"},{"题干":"<a href=\"xxx.jpg\" title=\"李克强出席学校...\">新闻</a>,获取<a>元素title的属性值（  ）","选项F":"","选项E":"","选项D":"$(\"a\").attr(\"title\").value;","答案":"C","选项C":"$(\"a\").attr(\"title\");","选项B":"$(\"#a\").attr(\"title\");","选项A":"$(\"a\").attr(\"title\").val();","类型":"1-单选"},{"题干":"下列选项中，可以使用哪个方法改变线程的优先级","选项F":"","选项E":"","选项D":"yield","答案":"C","选项C":"setPriority","选项B":"sleep","选项A":"run","类型":"1-单选"},{"题干":"下列选项中，那个方法可以启动线程","选项F":"","选项E":"","选项D":"wait","答案":"B","选项C":"sleep","选项B":"start","选项A":"run","类型":"1-单选"},{"题干":"Java多线程中可以通过_方法进行休眠一段时间，然后恢复运行","选项F":"","选项E":"","选项D":"setPriority","答案":"C","选项C":"sleep","选项B":"yield","选项A":"run","类型":"1-单选"},{"题干":"那个方法是实现Runnable接口所需的？","选项F":"","选项E":"","选项D":"update()","答案":"B","选项C":"stop()","选项B":"run()","选项A":"wait()","类型":"1-单选"},{"题干":"关于多线程，在多个线程访问同一个资源时，可以使用（）关键字来实现线程同步，保证对资源安全访问。","选项F":"","选项E":"","选项D":"Yield","答案":"A","选项C":"Serializable","选项B":"Transient","选项A":"Synchronized","类型":"1-单选"},{"题干":"关于多线程，Thread.sleep()方法调用后，当等待时间未到，该线程所处状态为（）状态。当等待时间已到，该线程所处状态为运行状态。","选项F":"","选项E":"","选项D":"死亡(DEAD)","答案":"C","选项C":"阻塞(BLOCKED)","选项B":"运行(RUNNING)","选项A":"可运行","类型":"1-单选"},{"题干":"关于多线程，notify是唤醒所在对象wait pool中的哪个线程","选项F":"","选项E":"","选项D":"运行时间最长的","答案":"C","选项C":"随机","选项B":"第一个","选项A":"线程优先级最高的","类型":"1-单选"},{"题干":"关于多线程，关于sleep()和wait()，以下描述错误的一项是","选项F":"","选项E":"","选项D":"wait后进入等待锁定池，只有针对此对象发出notify方法后获得对象锁进入运行状态","答案":"D","选项C":"sleep暂停线程、但监控状态仍然保持，结束后会自动恢复","选项B":"sleep不释放对象锁，wait放弃对象锁","选项A":"sleep是线程类（Thread）的方法，wait是Object类的方法","类型":"1-单选"},{"题干":"关于java多线程，多个线程并发执行时，线程之间的相对执行顺序是","选项F":"","选项E":"","选项D":"明确的","答案":"A","选项C":"可控制的","选项B":"确定的","选项A":"不确定的","类型":"1-单选"},{"题干":"关于多线程，Java中线程安全问题是通过关键字（）解决的","选项F":"","选项E":"","选项D":"notify()","答案":"C","选项C":"Synchronized","选项B":"wait()","选项A":"Finally","类型":"1-单选"},{"题干":"Solr索引库中支持的方法有","选项F":"","选项E":"","选项D":"修改索引","答案":"D","选项C":"根据ID覆盖索引","选项B":"添加索引","选项A":"删除索引","类型":"1-单选"},{"题干":"Solr中关于Fileds描述不正确的是","选项F":"","选项E":"","选项D":"mutiValued表示是否存储","答案":"D","选项C":"required表示必填项","选项B":"termOffsets用来存储term vector的偏移量的","选项A":"version的作用是表示版本号","类型":"1-单选"},{"题干":"下列 不 属 于 全文检索框架的是","选项F":"","选项E":"","选项D":"ElasticSearch","答案":"C","选项C":"redis","选项B":"Solr","选项A":"lucene","类型":"1-单选"},{"题干":"下列不 可以 用来 运行 solr项目的web容器有","选项F":"","选项E":"","选项D":"oracle","答案":"D","选项C":"jboss","选项B":"Tomcat","选项A":"jetty","类型":"1-单选"},{"题干":"以下不 属于 Solr后台 常用 的功能有","选项F":"","选项E":"","选项D":"Query","答案":"C","选项C":"Commit","选项B":"Analysis","选项A":"Document","类型":"1-单选"},{"题干":"Solr是 基于 开 放接口（ ）的标准","选项F":"","选项E":"","选项D":"IP","答案":"B","选项C":"TCP","选项B":"Xml、http","选项A":"UDP","类型":"1-单选"},{"题干":"Solr后台 包括 的 菜单不包括以下哪一类","选项F":"","选项E":"","选项D":"analyzer","答案":"A","选项C":"document","选项B":"Query","选项A":"Download","类型":"1-单选"},{"题干":"Solr提供 各种 各 样的功能，不包括以下哪一类","选项F":"","选项E":"","选项D":"数据持久化","答案":"D","选项C":"全文搜索功能","选项B":"分页搜索和过滤","选项A":"高度可扩展和容错","类型":"1-单选"},{"题干":"Solr是 基 于（ ）发展而来的","选项F":"","选项E":"","选项D":"ElasticSearch","答案":"C","选项C":"Lucene","选项B":"ibatis","选项A":"JPA","类型":"1-单选"},{"题干":"Solr是由一下那个组织在维护","选项F":"","选项E":"","选项D":"Google","答案":"B","选项C":"Sun","选项B":"Apache","选项A":"Oracle","类型":"1-单选"},{"题干":"事务管理在Spring与Hibernate整合后的正确方式是（）","选项F":"","选项E":"","选项D":"不支持使用注解","答案":"C","选项C":"在Service层通过AOP进行声明式的事务管理","选项B":"不用事务控制管理","选项A":"在DAO层进行控制管理","类型":"1-单选"},{"题干":"在Spring与Hibernate整合后获取Session的正确方法是（）","选项F":"","选项E":"","选项D":"getSession","答案":"A","选项C":"setNewSession","选项B":"openNewSession","选项A":"getCurrentSession","类型":"1-单选"},{"题干":"在Spring与Hibernate整合后，以下对数据源的描述正确的是（）","选项F":"","选项E":"","选项D":"不能配置多数据源，只能配置一个数据源","答案":"A","选项C":"数据源用于事务控制","选项B":"不用配置数据源","选项A":"可以使用数据库连接池作为数据源","类型":"1-单选"},{"题干":"以下对事务管理器在使用时描述正确的是（）","选项F":"","选项E":"","选项D":"声明式事务最大的优点就是需要通过编程的方式管理事务","答案":"C","选项C":"如果默认引入，事务管理器的名称必须是transactionManager","选项B":"事务管理器可以默认引入，其名称没有约定","选项A":"声明式事务管理无需使用事务管理器","类型":"1-单选"},{"题干":"在Spring与Hibernate整合后关于Hibernate框架配置文件的说法正确的是（）","选项F":"","选项E":"","选项D":"Hibernate配置文件可有可无","答案":"D","选项C":"Hiberante配置文件绝对不能存在，可以通过spring配置文件进行配置","选项B":"Hiberante配置文件如果存在，文件名必须是hibernate.cfg.xml","选项A":"Hibernate配置文件必须有，存在WEB-INF目录下","类型":"1-单选"},{"题干":"以下哪个选项是对事务传播特性Propagation.REQUIRED的正确描述（）","选项F":"","选项E":"","选项D":"新建事务，如果当前存在事务，把当前事务挂起。","答案":"C","选项C":"业务方法要在事务中运行，如果有事务就在当前事务中运行，如果没有事务则创建一个新事务","选项B":"业务方法不需要在事务中运行，如果存在事务则抛出异常","选项A":"业务方法要在事务中运行，如果没有事务则抛出异常","类型":"1-单选"},{"题干":"Spring与Hibernate整合时在配置Hibernate事务管理器时，以下说法正确的是（  ）。","选项F":"","选项E":"","选项D":"要注入transactionProxyFactoryBean","答案":"B","选项C":"要注入baseHibernateDao","选项B":"要注入sessionFactory","选项A":"要注入dataSource","类型":"1-单选"},{"题干":"事务管理器的bean名字是transactionManager,在进行声明式事务控制管理时可以在Service实现类上使用注解@Transactional,此时需要在Spring与Hibernate整合的配置文件中加入（）","选项F":"","选项E":"","选项D":"<tx:annotation-driven transaction-manager=\"transactionManager\"/>","答案":"D","选项C":"<util:annotation-driven transaction-manager=\"transactionManager\"/>","选项B":"<aop:annotation-driven transaction-manager=\"transactionManager\"/>","选项A":"<mvc:annotation-driven transaction-manager=\"transactionManager\"/>","类型":"1-单选"},{"题干":"关于spring与Hibernate整合，下列说法错误的是（）","选项F":"","选项E":"","选项D":"Spring提供HibernateDaoSupport类来简化Hibernate的使用","答案":"A","选项C":"通过Spring，在DAO类中无须实例化SessionFactory，而是通过注入获得","选项B":"通过Spring，在控制层(业务逻辑层)代码中无须直接实例化DAO类，而是通过注入获得","选项A":"通过Spring与Hibernate集成，以Spring管理程序的依赖关系，将SessionFactory注入DataSource","类型":"1-单选"},{"题干":"以下对声明式的事务管理说法正确的是（）","选项F":"","选项E":"","选项D":"增加了使用Hibernate的难度","答案":"B","选项C":"增加代码量","选项B":"提高开发效率","选项A":"降低开发效率","类型":"1-单选"},{"题干":"（大数据）关于Dubbo，启动zookeeper的命令","选项F":"","选项E":"","选项D":"startzkServer.sh","答案":"B","选项C":"zkServer.sh","选项B":"zkServer.sh�start","选项A":"zkServer-start.sh","类型":"1-单选"},{"题干":"（大数据）ServerSocket的监听方法accept(\u00A0)方法的返回值类型是","选项F":"","选项E":"","选项D":"DatagramSocket","答案":"A","选项C":"Object","选项B":"void","选项A":"Socket","类型":"1-单选"},{"题干":"（大数据）在Java网络编程中，使用客户端套接字Socket创建对象时，需要指定","选项F":"","选项E":"","选项D":"服务器地址和文件","答案":"A","选项C":"服务器名称和文件","选项B":"服务器端口和文件","选项A":"服务器主机名称和端口","类型":"1-单选"},{"题干":"（大数据）在集群调用失败时，Dubbo提供了多种容错方案，缺省为","选项F":"","选项E":"","选项D":"Failsafe","答案":"A","选项C":"Cluster","选项B":"Failfast","选项A":"Failover","类型":"1-单选"},{"题干":"（大数据）关于Dubbo，以下用于提供方配置的标签是","选项F":"","选项E":"","选项D":"<dubbo:monitor/>","答案":"A","选项C":"<dubbo:registry/>","选项B":"<dubbo:consumer/>","选项A":"<dubbo:provider/>","类型":"1-单选"},{"题干":"（大数据）关于Dubbo，以下用于配置连接注册中心相关信息","选项F":"","选项E":"","选项D":"<dubbo:registry/>","答案":"D","选项C":"<dubbo:consumer/>","选项B":"<dubbo:provider/>","选项A":"<dubbo:monitor/>","类型":"1-单选"},{"题干":"关于spring代理，下面说法正确的是","选项F":"","选项E":"","选项D":"AOP的默认代理是JDK的静态代理","答案":"C","选项C":"JDK的动态代理要求必须有接口","选项B":"spring只支持JDK代理","选项A":"spring的事务管理是静态代理","类型":"1-单选"},{"题干":"（大数据）Socket的工作流程是①打开连接到Socket的输入/输出②按某个协议对Socket进行读/写操作③创建Socket④关闭Socket","选项F":"","选项E":"","选项D":"①②③④","答案":"C","选项C":"③①②④","选项B":"②①③④","选项A":"①③②④","类型":"1-单选"},{"题干":"（大数据）关于Dubbo，支持哪种计算机语言","选项F":"","选项E":"","选项D":"支持Python语言","答案":"A","选项C":"支持PHP语言","选项B":"支持C语言","选项A":"支持JAVA语言","类型":"1-单选"},{"题干":"（大数据）关于ZooKeeper，哪个不是它的节点类型","选项F":"","选项E":"","选项D":"内存节点","答案":"D","选项C":"持久节点","选项B":"临时顺序节点","选项A":"临时节点","类型":"1-单选"},{"题干":"电商下-以下用于提供方配置的标签是（\u00A0\u00A0）","选项F":"","选项E":"","选项D":"<dubbo:monitor/>","答案":"A","选项C":"<dubbo:registry/>","选项B":"<dubbo:consumer/>","选项A":"<dubbo:provider/>","类型":"1-单选"},{"题干":"电商下-ServerSocket的监听方法accept(\u00A0)方法的返回值类型是（\u00A0）","选项F":"","选项E":"","选项D":"DatagramSocket","答案":"A","选项C":"Object","选项B":"Void","选项A":"Socket","类型":"1-单选"},{"题干":"电商下-在集群负载均衡时，Dubbo\u00A0提供了多种均衡策略，缺省为（\u00A0\u00A0）","选项F":"","选项E":"","选项D":"RoundRobin(轮循)","答案":"A","选项C":"ConsistentHash(一致性\u00A0Hash)","选项B":"LeastActive(最少活跃调用数)","选项A":"Random（随机）","类型":"1-单选"},{"题干":"电商下-下面说法正确的是\u00A0（\u00A0\u00A0）","选项F":"","选项E":"","选项D":"AOP的默认代理是JDK的静态代理","答案":"C","选项C":"JDK的动态代理要求必须有接口","选项B":"spring只支持JDK代理","选项A":"spring的事务管理是静态代理","类型":"1-单选"},{"题干":"电商下-以下用于配置连接注册中心相关信息（\u00A0\u00A0）","选项F":"","选项E":"","选项D":"<dubbo:registry/>","答案":"D","选项C":"<dubbo:consumer/>","选项B":"<dubbo:provider/>","选项A":"<dubbo:monitor/>","类型":"1-单选"},{"题干":"电商下-启动zookeeper（\u00A0\u00A0）","选项F":"","选项E":"","选项D":"startzkServer.sh","答案":"B","选项C":"zkServer.sh","选项B":"zkServer.sh�start","选项A":"以上都不对","类型":"1-单选"},{"题干":"电商下-在Java网络编程中，使用客户端套接字Socket创建对象时，需要指定（\u00A0\u00A0）","选项F":"","选项E":"","选项D":"服务器地址和文件","答案":"A","选项C":"服务器名称和文件","选项B":"服务器端口和文件","选项A":"服务器主机名称和端口","类型":"1-单选"},{"题干":"电商下-在集群调用失败时，Dubbo\u00A0提供了多种容错方案，缺省为什么","选项F":"","选项E":"","选项D":"Failsafe","答案":"A","选项C":"Cluster","选项B":"Failfast","选项A":"Failover","类型":"1-单选"},{"题干":"abstract\u00A0class和interface的区别是，描述错误的是（\u00A0\u00A0\u00A0\u00A0）","选项F":"","选项E":"","选项D":"抽象类中的抽象方法的访问类型可以是public,protected和默认类型,,但接口的抽象方法只能是public,默认即为public\u00A0abstract类型","答案":"C","选项C":"抽象类和接口没有区别，两者可以混用。","选项B":"抽象类可以有构造方法,接口不可以,\u00A0抽象类可以包含静态方法,但接口不可以","选项A":"抽象类中可以有普通的成员变量,普通的非抽象方法.接口不可以","类型":"1-单选"},{"题干":"关于抽象类与接口区别的说法，以下描述错误的是（）：","选项F":"","选项E":"","选项D":"接口中不定义任何与实现相关的内容，在抽象类中可以定义具有具体实现的方法","答案":"B","选项C":"接口是对行为的抽象，如：“可以飞”\u00A0是个接口，它是对各种可飞的实体的行为的抽象","选项B":"抽象类比接口定义更灵活，可以完全代替接口","选项A":"抽象类是对实体的抽象，如交通工具就是一个抽象类，它是对各式各样的交通工具的抽象","类型":"1-单选"},{"题干":"关于抽象说法错误的是","选项F":"","选项E":"","选项D":"抽象类不能直接实例化对象","答案":"C","选项C":"抽象类，必须有抽象方法","选项B":"有抽象方法的类，需要定义为抽象类","选项A":"抽象方法不可以有{}实现","类型":"1-单选"},{"题干":"java中，接口中的成员变量可以使用的访问修饰符是（  ）。","选项F":"","选项E":"","选项D":"private","答案":"A","选项C":"default","选项B":"protected","选项A":"public","类型":"1-单选"},{"题干":"当方法不需要返回值时，方法的返回值类型应该是","选项F":"","选项E":"","选项D":"void","答案":"D","选项C":"null","选项B":"\"\"","选项A":"不写","类型":"1-单选"},{"题干":"声明抽象类和抽象方法用到的关键字是（）。","选项F":"","选项E":"","选项D":"extends","答案":"A","选项C":"interface","选项B":"class","选项A":"abstract","类型":"1-单选"},{"题干":"若有如下接口A的定义，下列哪个类下确实现了该接口？（）\ninterface\u00A0A\u00A0{\u00A0\u00A0\n    void\u00A0method1(int\u00A0i);\u00A0\n    void\u00A0method2(int\u00A0j);\u00A0\n}","选项F":"","选项E":"","选项D":"class�B�implements�A{�\npublic��void�method1(int�x�)�{�}�\npublic�void�method2(int�y�)�{�}�\n}","答案":"D","选项C":"class�B�implements�A�{�\n�void�method1(int�i�)�{�}�\n�void�method2(int�j�)�{�}�\n}","选项B":"class�B�{�\n�void�method1(int�i�)�{�}�\n�void�method2(int�j�)�{�}�\n}","选项A":"class�B�implements�A{�\n�void�method1(�)�{�}�\n�void�method2(�)�{�}�\n}","类型":"1-单选"},{"题干":"若有如下接口A的定义，下列哪个类实现了该接口（\u00A0\u00A0）\u00A0\u00A0\u00A0interface\u00A0\u00A0A\u00A0{\u00A0\u00A0void\u00A0method1(int\u00A0i);\u00A0void\u00A0method2(int\u00A0j);\u00A0}\u00A0：","选项F":"","选项E":"","选项D":"class�B�{�void�method1(int�i�)�{�}�void�method2(int�j�)�{�}�}","答案":"C","选项C":"class�B�implements�A�{public�void�method1(int�i�)�{�}�public�void�method2(int�j�)�{�}�}","选项B":"class�B�implements�A{�public�void�method1(int�x�)�{�}�}","选项A":"class�B�implements�A{�void�method1(�)�{�}�void�method2(�)�{�}�}","类型":"1-单选"},{"题干":"关于接口的定义和实现，以下描述正确的是()。","选项F":"","选项E":"","选项D":"如果一个类实现一个接口，则必须实现该接口中的所有方法，但方法不必声明为 public。","答案":"A","选项C":"如果一个接口由多个类来实现，则这些类在实现该接口中的方法时应采用统一的代码。","选项B":"接口定义中的变量都必须写明 final 和 static。","选项A":"接口定义中的方法都只有定义没有实现。","类型":"1-单选"},{"题干":"java中，以下关于接口的说法中正确的是（  ）。","选项F":"","选项E":"","选项D":"一个接口可以有多个父接口","答案":"D","选项C":"接口之间不能有继承关系","选项B":"一个类不可以实现多个接口","选项A":"一个接口只能有一个父接口","类型":"1-单选"},{"题干":"阅读以下代码，从选项中选择正确重写父类方法的选项（  ）。\nclass A {\nprotected int method1(int a, int b) { return 0; }\n}\npublic class B extends A{ \n//选项中选择...\n}","选项F":"","选项E":"","选项D":"protected int method1(int a, long b) { return 0; }","答案":"B","选项C":"protected long method1(int a, int b) { return 0; }","选项B":"public int method1(int a, int b) { return 0; }","选项A":"private int method1(int a, int b) { return 0; }","类型":"1-单选"},{"题干":"java中，正确的关于接口说法是哪个","选项F":"","选项E":"","选项D":"接口中的属性可以定义为private","答案":"C","选项C":"接口中的属性都是常量，不能修改值","选项B":"接口中的方法可以定义为private","选项A":"接口中的方法都是抽象的，所以必须显式的用abstract修饰，不能有实现","类型":"1-单选"},{"题干":"下列对于抽象类的使用描述有误的是()。","选项F":"","选项E":"","选项D":"抽象类里只可以定义常量，不可以定义普通变量。","答案":"D","选项C":"抽象类声明的对象必须依靠子类进行实例化才能使用。","选项B":"不能直接实例化抽象类","选项A":"可以使用抽象类来声明对象","类型":"1-单选"},{"题干":"下面有关接口的说法中正确的是()。","选项F":"","选项E":"","选项D":"普通类实现一个接口必须实现接口的所有方法。","答案":"D","选项C":"接口之间不能有继承关系。","选项B":"一个类不可以实现多个接口。","选项A":"接口与抽象类是相同的概念。","类型":"1-单选"},{"题干":"java中，对抽象类正确的描述是哪个","选项F":"","选项E":"","选项D":"既不能用以创建对象，也不可用来派生新类","答案":"B","选项C":"既可用以创建对象，也可用以派生新类","选项B":"只能用以派生新类，不能用以创建对象","选项A":"只能用以创建对象，不能用以派生新类","类型":"1-单选"},{"题干":"封装的目的","选项F":"","选项E":"","选项D":"私有化数据，可以保证数据的安全性","答案":"D","选项C":"代码复用","选项B":"简化代码","选项A":"所有的方法都必须是公共的方法，提供访问","类型":"1-单选"},{"题干":"下面的接口或类定义正确的是（  ）。","选项F":"","选项E":"","选项D":"public class A { \nprivate int x; \npublic getx(){ return x; } \n}","答案":"C","选项C":"public abstract class A { \nprivate int x; \npublic abstract int getx(); \npublic int amethod() { return 0; }\n}","选项B":"public class A { \nprivate int x;\npublic abstract int getx(); \n}","选项A":"public interface A { \nprivate int x;\npublic int getx() { return x; }\n}","类型":"1-单选"},{"题干":"以下对面向接口编程的说法错误的是()。","选项F":"","选项E":"","选项D":"提高可维护性降低耦合","答案":"B","选项C":"提高编程的灵活性","选项B":"增加了代码量，并且封装了具体实现，很难理解，这是语言设计的缺陷","选项A":"更加抽象 ，更加面向对象","类型":"1-单选"},{"题干":"int j=1;\nfor( int i=j++; i<3; i++){\n\tSystem.out.print(i);\n}\n输出结果是","选项F":"","选项E":"","选项D":"2","答案":"B","选项C":"234","选项B":"12","选项A":"123","类型":"1-单选"},{"题干":"java中，抽象方法的描述，哪些是正确的？","选项F":"","选项E":"","选项D":"对于抽象方法方法体可有可无","答案":"C","选项C":"抽象方法没有方法体","选项B":"abstract修饰符可修饰字段、方法和类","选项A":"抽象方法的方法体必须用一对大括号{\u00A0}包住","类型":"1-单选"},{"题干":"接口是Java面向对象的实现机制之一，以下关于接口的说法中正确的是（  ）。","选项F":"","选项E":"","选项D":"在Java中一个类可只能有一个父类，也只能实现一个接口","答案":"B","选项C":"在Java中一个类可以有多个父类，但是只能实现一个接口","选项B":"在Java中一个类可只能有一个父类，但是可以实现多个接口","选项A":"Java中一个类可以有多个父类，也可以实现多个接口","类型":"1-单选"},{"题干":"1535332359551当通过继承HttpServlet的方法来创建servlet时候，如果只重写了doPost方法时候，而在浏览器中直接访问该servlet会时发生（）错误。","选项F":"","选项E":"","选项D":"500","答案":"C","选项C":"405","选项B":"404","选项A":"304","类型":"1-单选"},{"题干":"1535331477488每当请求到达Servlet时，会调用Servlet的()方法对请求进行响应。","选项F":"","选项E":"","选项D":"doGet()","答案":"B","选项C":"destroy()","选项B":"service()","选项A":"init()","类型":"1-单选"},{"题干":"1535332140278以下关于servlet接口的说法中错误的是()。","选项F":"","选项E":"","选项D":"可以通过实现Servlet接口，重写doGet和doPost的方法来创建一个servlet","答案":"D","选项C":"Servlet需要进行配置才能使用","选项B":"servlet接口是javax.servlet包下面的一个接口","选项A":"servlet接口中有service、init和destory等方法","类型":"1-单选"},{"题干":"以下关于servlet和jsp的区别说法错误的是()。","选项F":"","选项E":"","选项D":"jsp经转译之后就是一个servlet","答案":"C","选项C":"jsp需要浏览器来运行","选项B":"servlet一般用来做控制层","选项A":"jsp一般作为用户展示层（视图层）","类型":"1-单选"},{"题干":"1535332379480Servlet也是java程序，下列步骤中最先执行的是（）。","选项F":"","选项E":"","选项D":"销毁","答案":"B","选项C":"提供服务","选项B":"实例化","选项A":"初始化","类型":"1-单选"},{"题干":"1535332384297Servlet在容器中经历的阶段，按顺序为（）。","选项F":"","选项E":"","选项D":"提供服务、销毁、初始化","答案":"A","选项C":"提供服务、初始化、销毁","选项B":"初始化、销毁、提供服务","选项A":"初始化、提供服务、销毁","类型":"1-单选"},{"题干":"1535332315667在Servlet的生命周期中，以下可能会执行多次的方法是（）。","选项F":"","选项E":"","选项D":"destroy()","答案":"C","选项C":"service()","选项B":"init()","选项A":"构造方法","类型":"1-单选"},{"题干":"下面jsp指令中用于引入其他页面的是()。","选项F":"","选项E":"","选项D":"import","答案":"B","选项C":"page","选项B":"include","选项A":"taglib","类型":"1-单选"},{"题干":"JSP四大作用域中，作用范围最小的是（）。","选项F":"","选项E":"","选项D":"application","答案":"A","选项C":"session","选项B":"request","选项A":"page","类型":"1-单选"},{"题干":"JSP四大作用域中，作用范围最大的是（）。","选项F":"","选项E":"","选项D":"application","答案":"D","选项C":"session","选项B":"request","选项A":"page","类型":"1-单选"},{"题干":"在Linux中，查看进程记录的命令是","选项F":"","选项E":"","选项D":"以上都不对","答案":"A","选项C":"pstree","选项B":"top","选项A":"ps [-ef|-aux]","类型":"1-单选"},{"题干":"1534908299在vi编辑中“：”代表什么命令","选项F":"","选项E":"","选项D":"退出命令","答案":"A","选项C":"操作命令","选项B":"文本命令","选项A":"转义命令","类型":"1-单选"},{"题干":"在Linux中，如果brokencount>0，用来修复安装包的命令是","选项F":"","选项E":"","选项D":"sudo apt-get update --fix-broken","答案":"B","选项C":"sudo apt-get update --find-broken","选项B":"sudo apt-get install --fix-broken","选项A":"sudo apt-get install --find-broken","类型":"1-单选"},{"题干":"______模块是 python 支持多线程编程的重要模块","选项F":"","选项E":"","选项D":"line","答案":"B","选项C":"lines","选项B":"threading","选项A":"threads","类型":"1-单选"},{"题干":"已知矩阵A为[1,2]，矩阵B为[[2],[1]]，A*B的结果为","选项F":"","选项E":"","选项D":"无法计算","答案":"B","选项C":"[[2],[1]]","选项B":"4","选项A":"[1,2]","类型":"1-单选"},{"题干":"设A=[[2,-1],[-1,1]]则A的逆矩阵是","选项F":"","选项E":"","选项D":"该矩阵A没有逆矩阵","答案":"A","选项C":"[[-1,-2],[-1,1]]","选项B":"[[2,1],[1,1]]","选项A":"[[1,1],[1,2]]","类型":"1-单选"},{"题干":"threading.__________：返回当前处于alive状态的Thread对象数量","选项F":"","选项E":"","选项D":"threading.enumerate()","答案":"A","选项C":"threading.get_ident()","选项B":"threading.current_thread()","选项A":"threading.active_count()","类型":"1-单选"},{"题干":"Python内置函数________用来返回序列中的最大元素","选项F":"","选项E":"","选项D":"max()","答案":"D","选项C":"big()","选项B":"min()","选项A":"huge()","类型":"1-单选"},{"题干":"Queue模块允许用户创建一个可以用于多个线程之间_________的队列数据结构","选项F":"","选项E":"","选项D":"共享数据","答案":"D","选项C":"线程管理","选项B":"处理异常","选项A":"无正确答案","类型":"1-单选"},{"题干":"单层神经网络不能实现以下哪个逻辑运算","选项F":"","选项E":"","选项D":"XOR (逻辑异或)","答案":"D","选项C":"OR (逻辑或)","选项B":"AND (逻辑与)","选项A":"NOT(逻辑非)","类型":"1-单选"},{"题干":"把许多的_____按一定的层次连接起来就得到了神经网络","选项F":"","选项E":"","选项D":"输入层","答案":"A","选项C":"权重","选项B":"隐藏层","选项A":"神经元","类型":"1-单选"},{"题干":"Consider the following neural network which takes two binary-valued inputs x1,x2∈{0,1} and outputs hΘ(x).Also hΘ(x)=g(-10+20x1+20x2).Which of the following logical functions does it (approximately) compute?","选项F":"","选项E":"","选项D":"NOT(逻辑非)","答案":"C","选项C":"NOT(逻辑非)","选项B":"NOT(逻辑非)","选项A":"NOT(逻辑非)","类型":"1-单选"},{"题干":"clf=tree.DecisionTreeClassifier的作用是","选项F":"","选项E":"","选项D":"对变量矩阵化处理","答案":"B","选项C":"预测模型","选项B":"初始化一个决策树分类器","选项A":"训练模型","类型":"1-单选"},{"题干":"将决策树模型规则集导出的方法是","选项F":"","选项E":"","选项D":"tree.scores","答案":"C","选项C":"tree.export_graphviz","选项B":"tree.get_support","选项A":"tree.shuffle","类型":"1-单选"},{"题干":"AUC值可以通过sklearn包中的哪个模块实现","选项F":"","选项E":"","选项D":"project","答案":"A","选项C":"workspace","选项B":"preprocessing","选项A":"metrics","类型":"1-单选"},{"题干":"以下不属于常见的回归类型的是","选项F":"","选项E":"","选项D":"多元线性回归","答案":"B","选项C":"逻辑回归","选项B":"复杂线性回归","选项A":"一元线性回归","类型":"1-单选"},{"题干":"以下不属于集成学习类型的是","选项F":"","选项E":"","选项D":"bagging","答案":"A","选项C":"stacking","选项B":"boosting","选项A":"increasing","类型":"1-单选"},{"题干":"不是sklearn功能包的基本回归方法的是","选项F":"","选项E":"","选项D":"LOGIC","答案":"D","选项C":"KNN","选项B":"SVM","选项A":"决策树","类型":"1-单选"},{"题干":"xgboost的设计理念不包括","选项F":"","选项E":"","选项D":"可容错","答案":"C","选项C":"不可扩展","选项B":"可移植，少写代码","选项A":"速度快","类型":"1-单选"},{"题干":"以下关于回归分析的说法中不正确的是","选项F":"","选项E":"","选项D":"回归方程得到的预报值就是预报变量的精确值","答案":"D","选项C":"回归方程一般都有时间性","选项B":"残差平方和越大，模型的拟合效果越差","选项A":"R2越大，模型的拟合效果越好","类型":"1-单选"},{"题干":"(e^x)*sin(x)的导数是","选项F":"","选项E":"","选项D":"cosx","答案":"A","选项C":"(e^x)*cos(x)","选项B":"(e^x)","选项A":"(e^x)【（sin(x)+cos（x）】","类型":"1-单选"},{"题干":"tf.nn.relu","选项F":"","选项E":"","选项D":"激活","答案":"D","选项C":"步长","选项B":"卷积核","选项A":"被卷积数据","类型":"1-单选"},{"题干":"conv2d(x_image, W_conv1) + b_conv1）","选项F":"","选项E":"","选项D":"平均","答案":"B","选项C":"激活函数","选项B":"卷积函数","选项A":"对图像池化","类型":"1-单选"},{"题干":"池化核ksize=[1, 2, 2, 1]将图像","选项F":"","选项E":"","选项D":"扩大四倍","答案":"B","选项C":"扩大两倍","选项B":"缩小到1/4","选项A":"缩小到1/2","类型":"1-单选"},{"题干":"步长张量strides=[1, 2, 2, 1]能横向纵向移动","选项F":"","选项E":"","选项D":"4像素","答案":"B","选项C":"3像素","选项B":"2像素","选项A":"1像素","类型":"1-单选"},{"题干":"tf.equal(tf.argmax(y_conv, 1), tf.argmax(y_, 1))函数","选项F":"","选项E":"","选项D":"返回字符","答案":"B","选项C":"返回浮点值","选项B":"返回布尔值","选项A":"返回整数值","类型":"1-单选"},{"题干":"tf.cast(x, tf.float32)将x类型转化成","选项F":"","选项E":"","选项D":"返回字符","答案":"C","选项C":"返回浮点值","选项B":"返回布尔值","选项A":"返回整数值","类型":"1-单选"},{"题干":"能消除overflow的方法是","选项F":"","选项E":"","选项D":"正则化","答案":"D","选项C":"归一化","选项B":"非线性化","选项A":"线性化","类型":"1-单选"},{"题干":"在linux系统中，关于-rwxr-xr-x描述正确的是","选项F":"","选项E":"","选项D":"(700)\u00A0只有所有者才有读，写，执行的权限","答案":"C","选项C":"(755)\u00A0只有所有者才有读，写，执行的权限，组群和其他人只有读和执行的权限","选项B":"(666)\u00A0每个人都有读写的权限","选项A":"(711)\u00A0只有所有者才有读，写，执行的权限，组群和其他人只有执行的权限","类型":"1-单选"},{"题干":"1534908321在linux系统，vi编辑中“：”代表什么命令","选项F":"","选项E":"","选项D":"退出命令","答案":"A","选项C":"操作命令","选项B":"文本命令","选项A":"转义命令","类型":"1-单选"},{"题干":"在linux系统中，查看进程记录树的命令","选项F":"","选项E":"","选项D":"以上都不对","答案":"C","选项C":"pstree","选项B":"top","选项A":"ps [-ef|-aux]","类型":"1-单选"},{"题干":"在linux系统中，如果brokencount>0，用来修复安装包的命令是","选项F":"","选项E":"","选项D":"sudo apt-get update --fix-broken","答案":"B","选项C":"sudo apt-get update --find-broken","选项B":"sudo apt-get install --fix-broken","选项A":"sudo apt-get install --find-broken","类型":"1-单选"},{"题干":"python3 支持多线程编程的重要模块是__","选项F":"","选项E":"","选项D":"line","答案":"B","选项C":"lines","选项B":"threading","选项A":"threads","类型":"1-单选"},{"题干":"启动大量的子进程时，可以用什么方式批量创建子进程","选项F":"","选项E":"","选项D":"进程类","答案":"A","选项C":"进程参数","选项B":"进程函数","选项A":"进程池","类型":"1-单选"},{"题干":"用什么函数来启动线程","选项F":"","选项E":"","选项D":"begin","答案":"A","选项C":"run","选项B":"open","选项A":"start","类型":"1-单选"},{"题干":"已知矩阵A为[1,2]，矩阵B为[[2],[1]]，则A*B为","选项F":"","选项E":"","选项D":"无法计算","答案":"B","选项C":"[[2],[1]]","选项B":"4","选项A":"[1,2]","类型":"1-单选"},{"题干":"设A=[[2,-1],[-1,1]]  A的逆矩阵是","选项F":"","选项E":"","选项D":"该矩阵A没有逆矩阵","答案":"A","选项C":"[[-1,-2],[-1,1]]","选项B":"[[2,1],[1,1]]","选项A":"[[1,1],[1,2]]","类型":"1-单选"},{"题干":"返回当前处于alive状态的Thread对象数量为：threading.__________：","选项F":"","选项E":"","选项D":"threading.enumerate()","答案":"A","选项C":"threading.get_ident()","选项B":"threading.current_thread()","选项A":"threading.active_count()","类型":"1-单选"},{"题干":"内置函数中，用来返回序列中的最大元素","选项F":"","选项E":"","选项D":"max()","答案":"D","选项C":"big()","选项B":"min()","选项A":"huge()","类型":"1-单选"},{"题干":"在本月学习中，Queue模块允许用户创建一个可以用于多个线程之间_________的队列数据结构","选项F":"","选项E":"","选项D":"共享数据","答案":"D","选项C":"线程管理","选项B":"处理异常","选项A":"无正确答案","类型":"1-单选"},{"题干":"对于代价函数误差与多项式次数的关系描述正确的是（）（其中d代表多项式的次数）","选项F":"","选项E":"","选项D":"对于训练集：当 d 较小时，模型拟合程度更高，误差较大；随着 d 的增长，拟合程度降低，误差增大","答案":"A","选项C":"对于训练集：当 d 较小时，模型拟合程度更低，误差较大；随着 d 的增长，拟合程度提高，误差增大","选项B":"对于训练集：当 d 较小时，模型拟合程度更高，误差较大；随着 d 的增长，拟合程度提高，误差减小","选项A":"对于训练集：当 d 较小时，模型拟合程度更低，误差较大；随着 d 的增长，拟合程度提高，误差减小","类型":"1-单选"},{"题干":"以下关于正则化参数lamda描述正确的是（）","选项F":"","选项E":"","选项D":"正则化可以解决过拟合问题与欠拟合问题","答案":"B","选项C":"正则化用来解决欠拟合问题","选项B":"当lamda较小时，训练集误差较小（过拟合）而交叉验证集误差较大","选项A":"当lamda较大时，训练集误差较小（过拟合）而交叉验证集误差较大","类型":"1-单选"},{"题干":"文本挖掘中主题生成用的模块是","选项F":"","选项E":"","选项D":"scipy","答案":"B","选项C":"sklearn","选项B":"genism","选项A":"seaborn","类型":"1-单选"},{"题干":"以下关于回归分析的说法中不正确的是","选项F":"","选项E":"","选项D":"回归方程得到的预报值就是预报变量的精确值","答案":"D","选项C":"回归模型需要残差诊断","选项B":"残差平方和越大，模型的拟合效果越差","选项A":"R2越大，模型的拟合效果越好","类型":"1-单选"},{"题干":"在Python中，执行下列语句后的显示结果是什么? \nprint(type({1,2}))","选项F":"","选项E":"","选项D":"<class 'list'>","答案":"C","选项C":"<class 'set'>","选项B":"<class 'complex'>","选项A":"<class 'tuple'>","类型":"1-单选"},{"题干":"在Python中，执行下列语句后的显示结果是什么? \na = [2,3,None,(),[],{}]\nprint(len(a))","选项F":"","选项E":"","选项D":"7","答案":"C","选项C":"6","选项B":"5","选项A":"4","类型":"1-单选"},{"题干":"python3中，表达式set([1,1,3,3,2,2,3])的值为","选项F":"","选项E":"","选项D":"list","答案":"C","选项C":"{1, 2, 3}","选项B":"{3, 2, 1}","选项A":"{1, 3, 2}","类型":"1-单选"},{"题干":"在Python中，执行下列语句后的显示结果是什么? \ncounter = 1\ndef doLotsOfStuff(): \n    global counter\n    for i in (1, 2, 3):\n        counter += 1\ndoLotsOfStuff() \nprint(counter)","选项F":"","选项E":"","选项D":"4","答案":"D","选项C":"3","选项B":"2","选项A":"1","类型":"1-单选"},{"题干":"在Python中，执行下列语句后的显示结果是什么? \ndef f(): pass\nprint(type(f()))","选项F":"","选项E":"","选项D":"<class 'set'>","答案":"B","选项C":"<class 'complex'>","选项B":"<class 'NoneType'>","选项A":"<class 'list'>","类型":"1-单选"},{"题干":"表达式 'abcab'.replace('a','d')的值为","选项F":"","选项E":"","选项D":"adad","答案":"A","选项C":"dabcdab","选项B":"adbcadb","选项A":"dbcdb","类型":"1-单选"},{"题干":"表达式[float(i) for i in range(3)]的值为","选项F":"","选项E":"","选项D":"['0', '1', '2','3']","答案":"B","选项C":"[0,1,2,3]","选项B":"[0.0, 1.0, 2.0]","选项A":"['0', '1', '2']","类型":"1-单选"},{"题干":"在python中，阅读下列程序，输出结果正确的是：\nnums = set([1,3,3,3,4]) \nprint( len(nums))","选项F":"","选项E":"","选项D":"5","答案":"C","选项C":"3","选项B":"2","选项A":"1","类型":"1-单选"},{"题干":"在Python3中，执行表达式{1,2,3,4}-{3,4,5,6}后，所得的值为","选项F":"","选项E":"","选项D":"{-8}","答案":"A","选项C":"typeError","选项B":"{-2,-2,-2,-2}","选项A":"{1, 2}","类型":"1-单选"},{"题干":"已知 a = [1,2,3,4,5,6]，那么执行语句 a[-2::-2]之后，a的值为","选项F":"","选项E":"","选项D":"[4,3]","答案":"A","选项C":"[5,4,3,2,1]","选项B":"[5,4,3]","选项A":"[5,3,1]","类型":"1-单选"},{"题干":"Python3中可以使用什么语句来处理异常","选项F":"","选项E":"","选项D":"try...but","答案":"A","选项C":"try..elif","选项B":"try..exception","选项A":"try..except","类型":"1-单选"},{"题干":"在python中，阅读下列程序，输出结果正确的是：\na=int(16**0.5)\nb=int(2**2)\nprint('a==b')","选项F":"","选项E":"","选项D":"False","答案":"A","选项C":"None","选项B":"True","选项A":"a==b","类型":"1-单选"},{"题干":"在python3中，执行下列语句：\na = '1,2,3,4,5,6'\nla=a.split(',')\n则la的数据类型是","选项F":"","选项E":"","选项D":"array","答案":"A","选项C":"dict","选项B":"str","选项A":"list","类型":"1-单选"},{"题干":"Python文件的读写里，有一些常用的打开模式，其中只能写，并从文件底部添加内容的是","选项F":"","选项E":"","选项D":"rb","答案":"A","选项C":"w","选项B":"r","选项A":"a","类型":"1-单选"},{"题干":"表达式5 if 5>6 else (6 if 3>2 else 5)\u00A0的值为","选项F":"","选项E":"","选项D":"Ture","答案":"B","选项C":"5","选项B":"6","选项A":"无正确选项","类型":"1-单选"},{"题干":"大数据：对于代价函数误差与多项式次数的关系描述正确的是（）（其中d代表多项式的次数）","选项F":"","选项E":"","选项D":"对于训练集：当 d 较小时，模型拟合程度更高，误差较大；随着 d 的增长，拟合程度降低，误差增大","答案":"A","选项C":"对于训练集：当 d 较小时，模型拟合程度更低，误差较大；随着 d 的增长，拟合程度提高，误差增大","选项B":"对于训练集：当 d 较小时，模型拟合程度更高，误差较大；随着 d 的增长，拟合程度提高，误差减小","选项A":"对于训练集：当 d 较小时，模型拟合程度更低，误差较大；随着 d 的增长，拟合程度提高，误差减小","类型":"1-单选"},{"题干":"大数据：以下关于正则化参数lamda描述正确的是（）","选项F":"","选项E":"","选项D":"正则化可以解决过拟合问题与欠拟合问题","答案":"B","选项C":"正则化用来解决欠拟合问题","选项B":"当lamda较小时，训练集误差较小（过拟合）而交叉验证集误差较大","选项A":"当lamda较大时，训练集误差较小（过拟合）而交叉验证集误差较大","类型":"1-单选"},{"题干":"大数据:如果神经网络，有两个输入x1,x2∈{0,1} 和输出hΘ(x)=g(-30+20x1+20x2).下面选项中哪一个是它表达的逻辑关系？","选项F":"","选项E":"","选项D":"XOR (逻辑异或)","答案":"B","选项C":"OR (逻辑或)","选项B":"AND (逻辑与)","选项A":"NOT(逻辑非)","类型":"1-单选"},{"题干":"大数据：通常来说，下面哪种（些）方法能够用来预测连续因变量？\n1.    线性回归\n2.    逻辑回归","选项F":"","选项E":"","选项D":"以上皆非","答案":"B","选项C":"只有2","选项B":"只有1","选项A":"1和2","类型":"1-单选"},{"题干":"HBASE显示所有表的命令是","选项F":"","选项E":"","选项D":"list","答案":"D","选项C":"desc","选项B":"show all","选项A":"show tables","类型":"1-单选"},{"题干":"下列哪个命令是创建多版本的表的（）","选项F":"","选项E":"","选项D":"create \"t1\",{NAME=\"f1\",VERSIONS=3}","答案":"C","选项C":"create \"t1\",{NAME=>\"f1\",VERSIONS=>3}","选项B":"create \"t1\",\"f1\"","选项A":"create table \"t1\",\"f1\"","类型":"1-单选"},{"题干":"关于数据库truncate和delete * from tb说法正确的是","选项F":"","选项E":"","选项D":"delete * from tb数据不能回滚","答案":"A","选项C":"truncate数据能回滚","选项B":"两个操作效果一样","选项A":"两个都能清空表","类型":"1-单选"},{"题干":"下列哪个命令是启动HBASE服务的","选项F":"","选项E":"","选项D":"start-zk.sh","答案":"A","选项C":"start-yarn.sh","选项B":"start-dfs.sh","选项A":"start-hbase.sh","类型":"1-单选"},{"题干":"HBbase起源于google的哪一篇论文？","选项F":"","选项E":"","选项D":"MapReduce","答案":"C","选项C":"BigTable","选项B":"Chubby","选项A":"GFS","类型":"1-单选"},{"题干":"HBbase的Region说法正确的是","选项F":"","选项E":"","选项D":"Region是存储数据的最小单位","答案":"A","选项C":"一个表只能有一个Region","选项B":"region是按照行数进行分割的","选项A":"Region是HBASE分布式和负载均衡的最小单位","类型":"1-单选"},{"题干":"下列关于HBASE表说法错误的是","选项F":"","选项E":"","选项D":"建表的时候需要指定各个列","答案":"D","选项C":"随机读写性能很高","选项B":"没有像MySQL那种复杂的数据类型","选项A":"支持多版本数据","类型":"1-单选"},{"题干":"HBase 是建立在__之上的一个数据仓库","选项F":"","选项E":"","选项D":"Pig","答案":"A","选项C":"Zookeeper","选项B":"Saprk","选项A":"Hadoop","类型":"1-单选"},{"题干":"HBase来源于哪一项？","选项F":"","选项E":"","选项D":"Chubby","答案":"C","选项C":"BigTable","选项B":"MapReduce","选项A":"The Google File System","类型":"1-单选"},{"题干":"一个MapReduce程序中的MapTask的个数由什么决定？","选项F":"","选项E":"","选项D":"输入的总文件大小/数据块大小","答案":"C","选项C":"FileInputFormat.getSplits(JobContext job)计算出的逻辑切片的数量","选项B":"客户端程序设置的mapTask的个数","选项A":"输入的总文件数","类型":"1-单选"},{"题干":"1532923634是否听明白此知识点：\t12.1.1tensorflow平台的构思原理","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"否","选项A":"是","类型":"1-单选"},{"题干":"1532923634是否听明白此知识点：12.1.3tensorflow和Python的计算分工","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"否","选项A":"是","类型":"1-单选"},{"题干":"1532923634是否听明白此知识点：12.1.2tensorflow和Python关系（数据交互，指令交互，结果提取）","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"否","选项A":"是","类型":"1-单选"},{"题干":"1532923634是否听明白此知识点：\t12.2.1建议一种安装方案","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"否","选项A":"是","类型":"1-单选"},{"题干":"1532923634是否听明白此知识点：\t12.2.2介绍其它安装方案","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"否","选项A":"是","类型":"1-单选"},{"题干":"1532923634是否听明白此知识点：12.3tf运行原理和如何操作这种平台","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"否","选项A":"是","类型":"1-单选"},{"题干":"1532923634是否听明白此知识点：\t12.3.1变量、常量、形式参数","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"否","选项A":"是","类型":"1-单选"},{"题干":"1532923634是否听明白此知识点：\t12.3.2要牢记全局变量的初始化","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"否","选项A":"是","类型":"1-单选"},{"题干":"1532923634是否听明白此知识点：\t12.3.3各种python和tensorflow的参数交换","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"否","选项A":"是","类型":"1-单选"},{"题干":"1532923634是否听明白此知识点：\t12.3.4各种功能块的详述","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"否","选项A":"是","类型":"1-单选"},{"题干":"1532923634是否听明白此知识点：\t12.4.1三种不同称谓来描述tensor的维度：Shape，Rank，Dimension。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"否","选项A":"是","类型":"1-单选"},{"题干":"在Linux系统中，查看进程记录的命令是","选项F":"","选项E":"","选项D":"以上都不对","答案":"A","选项C":"pstree","选项B":"top","选项A":"ps [-ef|-aux]","类型":"1-单选"},{"题干":"在linux中，在vi编辑中“：”代表什么命令","选项F":"","选项E":"","选项D":"退出命令","答案":"A","选项C":"操作命令","选项B":"文本命令","选项A":"转义命令","类型":"1-单选"},{"题干":"1532420495565在Linux系统中，如果brokencount>0，用来修复安装包的命令是","选项F":"","选项E":"","选项D":"sudo�apt-get�update�--fix-broken","答案":"B","选项C":"sudo�apt-get�update�--find-broken","选项B":"sudo�apt-get�install�--fix-broken","选项A":"sudo�apt-get�install�--find-broken","类型":"1-单选"},{"题干":"语句tf.nn.conv2d(a, b, c, d )中，被卷积数据是","选项F":"","选项E":"","选项D":"d","答案":"B","选项C":"c","选项B":"a","选项A":"b","类型":"1-单选"},{"题干":"语句tf.nn.conv2d(a, b, c, d )中，其中b是","选项F":"","选项E":"","选项D":"填充","答案":"B","选项C":"步长","选项B":"卷积核","选项A":"被卷积数据","类型":"1-单选"},{"题干":"现有一个32X32大小的图像，通过步长为2，尺寸为2X2的池化运算后，尺寸变为","选项F":"","选项E":"","选项D":"16X16","答案":"D","选项C":"28X28","选项B":"2X2","选项A":"14X14","类型":"1-单选"},{"题干":"现有一个32X32大小的图像，通过步长为1，大小为5X5的卷积核卷积后，结果尺寸成为","选项F":"","选项E":"","选项D":"32X32","答案":"A","选项C":"31X31","选项B":"14X14","选项A":"28X28","类型":"1-单选"},{"题干":"语句tf.nn.conv2d()，其中遇到的图像张量，格式是","选项F":"","选项E":"","选项D":"[batch, in_channels，in_height, in_width ]","答案":"A","选项C":"[batch, in_width, in_height， in_channels]","选项B":"[Size,  in_height, in_width, in_channels]","选项A":"[batch,  in_height, in_width, in_channels]","类型":"1-单选"},{"题干":"如果定义一个卷积核filter，它的张量定义为filter=tf.Variable(tf.random_normal([10,20，16,3]))它的图像高度是：","选项F":"","选项E":"","选项D":"3","答案":"B","选项C":"16","选项B":"20","选项A":"10","类型":"1-单选"},{"题干":"从上升速度来看所有的函数的，上升最慢的是","选项F":"","选项E":"","选项D":"对数函数","答案":"D","选项C":"幂函数","选项B":"指数函数","选项A":"线性函数","类型":"1-单选"},{"题干":"神经网络需要激活函数，其最主要原因是可实现：","选项F":"","选项E":"","选项D":"正则化","答案":"B","选项C":"归一化","选项B":"非线性分类","选项A":"解决线性可分性","类型":"1-单选"},{"题干":"机器学习训练时，针对过拟合问题，应该如何处理","选项F":"","选项E":"","选项D":"正则化，保留所有的特征，增大lamda参数的大小","答案":"D","选项C":"增加更多的特征","选项B":"正则化，保留所有的特征，但是减少lamda参数的大小","选项A":"增加更多的样本","类型":"1-单选"},{"题干":"神经网络一般有输入层、隐藏层和()构成","选项F":"","选项E":"","选项D":"多级层","答案":"B","选项C":"隐藏层","选项B":"输出层","选项A":"输入层","类型":"1-单选"},{"题干":"以下不是解决高偏差/欠拟合现象的方法是（）","选项F":"","选项E":"","选项D":"尝试减少正则化程度λ","答案":"B","选项C":"尝试增加多项式特征","选项B":"尝试增加正则化程度λ","选项A":"尝试获得更多的特征","类型":"1-单选"},{"题干":"假设一个神经网络，有2个输入单元x1,x2∈{0,1} 和输出hΘ(x)=g(20-10x1-15x2).请问，它表达的是如下哪一个逻辑关系？","选项F":"","选项E":"","选项D":"与非","答案":"D","选项C":"OR (逻辑或)","选项B":"AND (逻辑与)","选项A":"NOT(逻辑非)","类型":"1-单选"},{"题干":"假设有一个神经网络，有2个输入x1,x2∈{0,1}和输出 hΘ(x)，以下表达式为逻辑‘与’关系的是","选项F":"","选项E":"","选项D":"h(x)=g(20-10x1-15x2)","答案":"A","选项C":"h(x)=g(-30+20x1)","选项B":"h(x)=g(-10+15x1+15x2)","选项A":"h(x)=g(-25+15x1+15x2)","类型":"1-单选"},{"题干":"以下不是解决高方差/过拟合现象的措施是（）","选项F":"","选项E":"","选项D":"尝试减少正则化程度λ","答案":"D","选项C":"尝试增加正则化程度λ","选项B":"尝试减少特征的数量","选项A":"获得更多的训练实例","类型":"1-单选"},{"题干":"下面哪种（些）方法可以用来预测离散因变量？\n1.    线性回归\n2.    逻辑回归","选项F":"","选项E":"","选项D":"以上皆非","答案":"C","选项C":"只有2","选项B":"只有1","选项A":"1和2","类型":"1-单选"},{"题干":"已知矩阵D=[[2,2],[1,1]]，那么，D+1=","选项F":"","选项E":"","选项D":"[[2,2],[2,2]]","答案":"A","选项C":"[[3,3],[1,1]]","选项B":"不能相加","选项A":"[[3,3],[2,2]]","类型":"1-单选"},{"题干":"有关神经网络模型，描述错误的是","选项F":"","选项E":"","选项D":"神经网络模型一定可以解决所有分类问题","答案":"D","选项C":"神经网络模型中，无中间层的神经元模型的计算可用来表示逻辑运算","选项B":"神经网络模型建立在多神经元之上","选项A":"神经网络模型是许多逻辑单元按照不同层级组织起来的网络，每一层的输出变量都是下一层的输入变量","类型":"1-单选"},{"题干":"已知C=[1,2,3] D=[1,1,1],则np.c_[C,D]结果是","选项F":"","选项E":"","选项D":"[[1,1,1],[1,2,3]]","答案":"A","选项C":"[[1 1]\n [1 2]\n [1 3]]","选项B":"[[1,2,3],[1,1,1]]","选项A":"[[1 1]\n [2 1]\n [3 1]]","类型":"1-单选"},{"题干":"关于java多线程，下列关于Java线程的说法正确的是","选项F":"","选项E":"","选项D":"使用new Thread(new X()).run();方法启动一个线程","答案":"A","选项C":"Thread类属于java.util程序包","选项B":"创建线程的两种方法中，从Thread类中继承方式可以防止出现多父类的问题","选项A":"每一个Java线程可以看成由代码、一个真实的CPU以及数据三部分组成","类型":"1-单选"},{"题干":"关于java多线程，如下代码创建一个新线程并启动线程，问:四个选项中可以保证正确代码创建target对象，并能编译正确的是\npublic static void main(String[] args) {\n          Runnable target=new MyRunnable( ); \n          Thread myThread=new Thread(target);\n}","选项F":"","选项E":"","选项D":"public class MyRunnable  implements Runnable  {\n    void run(){}\n}","答案":"C","选项C":"public class MyRunnable  implements Runnable  {\n    public void run(){}\n}","选项B":"public class MyRunnable extends Runnable {\n    void run(){}\n}","选项A":"public class MyRunnable extends Runnable {\n    public void run( ){}\n}","类型":"1-单选"},{"题干":"关于java多线程，线程执行完了或者因异常退出了run()方法，变成什么状态","选项F":"","选项E":"","选项D":"新建状态","答案":"A","选项C":"就绪状态","选项B":"运行状态","选项A":"死亡状态","类型":"1-单选"},{"题干":"关于java多线程，下列关于Thread类提供的线程控制方法的说法中，错误的是","选项F":"","选项E":"","选项D":"currentThread()方法返回当前线程的引用","答案":"C","选项C":"若线程A调用方法isAlive()返回值为false，则说明A正在执行中，也可能是可运行状态","选项B":"线程A通过调用interrupt()方法来中断其阻塞状态","选项A":"线程A中执行线程B的join()方法，则线程A等待直到B执行完成","类型":"1-单选"},{"题干":"关于java多线程，下面说法不正确的是","选项F":"","选项E":"","选项D":"Java中的线程可以共享代码","答案":"B","选项C":"Java中的线程可以共享数据","选项B":"Java中线程是分时的","选项A":"Java中线程是抢占式的","类型":"1-单选"},{"题干":"关于java多线程，方法resume()负责恢复哪些线程的执行","选项F":"","选项E":"","选项D":"通过调用suspend()方法而停止的线程","答案":"D","选项C":"通过调用wait()方法而停止的线程","选项B":"通过调用sleep()方法而停止的线程","选项A":"通过调用stop()方法而停止的线程","类型":"1-单选"},{"题干":"关于java多线程，继承Thread类，必须重写该类的哪种方法","选项F":"","选项E":"","选项D":"synchronized()","答案":"A","选项C":"start()","选项B":"init()","选项A":"run()","类型":"1-单选"},{"题干":"关于java多线程，下列描述正确的是","选项F":"","选项E":"","选项D":"一个线程可以包含多个进程","答案":"C","选项C":"Java提供对多线程同步提供语言级的支持","选项B":"启动一个线程直接调用线程对象的run()方法","选项A":"线程对象必须实现Runnable接口","类型":"1-单选"},{"题干":"关于java多线程，线程run()、main() 方法执行结束，或者因异常退出了run()方法，线程处于什么状态","选项F":"","选项E":"","选项D":"死亡(DEAD)","答案":"D","选项C":"阻塞(BLOCKED)","选项B":"运行(RUNNING)","选项A":"可运行(RUNNABLE)","类型":"1-单选"},{"题干":"关于java多线程，下列选项中不属于多线程作用的是","选项F":"","选项E":"","选项D":"使多CPU系统更加有效","答案":"A","选项C":"改善程序结构","选项B":"提高应用程序的响应","选项A":"提高内存存储空间","类型":"1-单选"},{"题干":"在Spring中可以通过以下哪种方式实现依赖注入","选项F":"","选项E":"","选项D":"setter方法","答案":"D","选项C":"getter方法","选项B":"自定义赋值方法","选项A":"静态方法","类型":"1-单选"},{"题干":"关于spring与Hibernate整合，HibernateTemplate的作用是什么","选项F":"","选项E":"","选项D":"增加了使用Hibernate的难度","答案":"B","选项C":"增加代码量","选项B":"提高开发效率","选项A":"降低开发效率","类型":"1-单选"},{"题干":"关于spring与Hibernate整合，HibernateDaoSupport类提供了哪种方法获得HibernateTemplate对象","选项F":"","选项E":"","选项D":"setHibernateTemplate","答案":"C","选项C":"getHibernateTemplate","选项B":"currentSession","选项A":"createHibernateTemplate","类型":"1-单选"},{"题干":"关于spring与Hibernate整合，Spring包装Hibernate之后的Hibernate的DAO应该继承哪个类","选项F":"","选项E":"","选项D":"Session","答案":"A","选项C":"SessionFactory","选项B":"HibernateDao","选项A":"HibernateDaoSupport","类型":"1-单选"},{"题干":"关于spring与Hibernate整合，HibernateTemplate的方法中哪个方法不改变数据","选项F":"","选项E":"","选项D":"save","答案":"A","选项C":"delete","选项B":"update","选项A":"get","类型":"1-单选"},{"题干":"关于spring与Hibernate整合，HibernateDaoSupport中获取当前session的方法是","选项F":"","选项E":"","选项D":"getCurrentSessession","答案":"D","选项C":"getSession","选项B":"currentSession","选项A":"setCurrentSession","类型":"1-单选"},{"题干":"Spring默认的代理方式是","选项F":"","选项E":"","选项D":"java代理","答案":"B","选项C":"静态代理","选项B":"JDK动态代理","选项A":"CgLib代理","类型":"1-单选"},{"题干":"关于spring与Hibernate整合，HibernateTemplate的方法中哪个方法删除集合内全部持久化类实例","选项F":"","选项E":"","选项D":"save","答案":"A","选项C":"update","选项B":"delete","选项A":"deleteAll","类型":"1-单选"},{"题干":"关于spring与Hibernate整合，Spring包装Hibernate之后，关于find方法说法正确的是","选项F":"","选项E":"","选项D":"参数是Collection对象","答案":"B","选项C":"参数是DetachedCriteria对象","选项B":"参数是HQL语句","选项A":"参数是Restrictions对象","类型":"1-单选"},{"题干":"关于spring与Hibernate整合，HibernateDaoSupport中获取Hibernate的SessionFactory的方法是","选项F":"","选项E":"","选项D":"getFactory","答案":"B","选项C":"setSessionFactory","选项B":"getSessionFactory","选项A":"getCurrentSessionFactory","类型":"1-单选"},{"题干":"以下关于MapReduce的序列化键值传输数据的说法正确的是","选项F":"","选项E":"","选项D":"键和值的数据类型可以超出Hadoop自身支持的基本类型","答案":"C","选项C":"Hadoop的基本类型Text并不实现WritableComparable<T>接口","选项B":"实现WritableComparable<T>接口的类可以是值或键","选项A":"实现Writable接口的类是值","类型":"1-单选"},{"题干":"（大数据）电商上　schema.xml的根标签是（）","选项F":"","选项E":"","选项D":"config","答案":"A","选项C":"managed-schema","选项B":"schemas","选项A":"schema","类型":"1-单选"},{"题干":"（大数据）电商上　在schema.xml文件中表示存储原始数据的属性是（）","选项F":"","选项E":"","选项D":"indexed","答案":"B","选项C":"name","选项B":"stored","选项A":"text","类型":"1-单选"},{"题干":"（大数据）电商上  Solr下fields节点中indexed的作用是()","选项F":"","选项E":"","选项D":"类型","答案":"B","选项C":"是否储存","选项B":"是否被用来建立索引","选项A":"标识","类型":"1-单选"},{"题干":"（大数据）电商上 Solr下fields节点中表示是否必填属性是（）","选项F":"","选项E":"","选项D":"Stored","答案":"A","选项C":"mutiValued","选项B":"omitNorms","选项A":"required","类型":"1-单选"},{"题干":"（大数据）电商上 Solr下fields节点中name的作用","选项F":"","选项E":"","选项D":"定义的类型","答案":"A","选项C":"是否储存","选项B":"是否被用来建立索引","选项A":"标识","类型":"1-单选"},{"题干":"（大数据）电商上 Solr下fields节点中type的作用是","选项F":"","选项E":"","选项D":"定义的类型","答案":"D","选项C":"是否储存","选项B":"是否被用来建立索引","选项A":"标识","类型":"1-单选"},{"题干":"（大数据）电商上\u00A0Solr下field节点中mutiValued的作用是","选项F":"","选项E":"","选项D":"是否储存","答案":"C","选项C":"是否包含多个值","选项B":"是否使用gzip压缩","选项A":"是否被用来建立索引","类型":"1-单选"},{"题干":"（大数据）电商上 Solr下fields节点中compressed的作用是","选项F":"","选项E":"","选项D":"是否储存","答案":"B","选项C":"是否包含多个值","选项B":"是否使用gzip压缩","选项A":"是否被用来建立索引","类型":"1-单选"},{"题干":"（大数据）电商上 Solr下fields节点中mergeFacor的作用是","选项F":"","选项E":"","选项D":"存储term vector的偏移量","答案":"B","选项C":"是否包含多个值","选项B":"被合并的频率","选项A":"是否使用gzip压缩","类型":"1-单选"},{"题干":"（大数据）电商上 Solr下fields节点中termOffsets的作用是","选项F":"","选项E":"","选项D":"存储term vector的偏移量","答案":"D","选项C":"是否包含多个值","选项B":"被合并的频率","选项A":"是否使用gzip压缩","类型":"1-单选"},{"题干":"（大数据）电商上 Solr下fields节点中termVectors的作用是","选项F":"","选项E":"","选项D":"被合并的频率","答案":"A","选项C":"存储term vector的偏移量","选项B":"存储term vector中的地址信","选项A":"会存储term vector","类型":"1-单选"},{"题干":"（大数据）电商上 Solr下fields节点中termPositions的作用是","选项F":"","选项E":"","选项D":"被合并的频率","答案":"B","选项C":"存储term vector的偏移量","选项B":"存储term vector中的地址信","选项A":"会存储term vector","类型":"1-单选"},{"题干":"（大数据）电商上 Solr下fields节点中version的作用是","选项F":"","选项E":"","选项D":"版本号","答案":"D","选项C":"是否包含多个值","选项B":"是否使用gzip压缩","选项A":"是否储存","类型":"1-单选"},{"题干":"1535017401024在web项目中web.xml文件的位置在","选项F":"","选项E":"","选项D":"classpath","答案":"A","选项C":"WebContent","选项B":"src","选项A":"web-inf","类型":"1-单选"},{"题干":"1535017346772在JavaWeb中<filter-name>的作用是","选项F":"","选项E":"","选项D":"声明框架核心配置文件的位置及其名称","答案":"A","选项C":"没有任何意义","选项B":"声明自定义过滤器的名称","选项A":"声明过滤器的名称","类型":"1-单选"},{"题干":"1535017376847在Web项目中对于web.xml文件的配置，forceEncoding的值如果是true","选项F":"","选项E":"","选项D":"毫无意义","答案":"A","选项C":"与properties的编码保持一致","选项B":"与jsp的编码保持一致","选项A":"代表异步请求采用的编码格式与整个项目的保持一致","类型":"1-单选"},{"题干":"1535017442404在SSM框架整合时建议将框架的核心配置文件放在哪一个位置","选项F":"","选项E":"","选项D":"dto","答案":"A","选项C":"lib","选项B":"web-inf","选项A":"scr","类型":"1-单选"},{"题干":"1535017331468关于web项目配置监听ContextLoaderListener的描述正确的是","选项F":"","选项E":"","选项D":"必须配置，而且配置文件的名称必须是默认的","答案":"B","选项C":"必须配置","选项B":"项目在启动的时候加载spring配置文件中的配置项","选项A":"必须配置，但是没有任何意义","类型":"1-单选"},{"题干":"1535017536854SSM框架整合时依赖注入最常使用并且可以按照名称注入的是","选项F":"","选项E":"","选项D":"@RequestMapping","答案":"A","选项C":"@service","选项B":"@Autowired","选项A":"@Resource","类型":"1-单选"},{"题干":"1535017309188springmvc框架中关于网络资源视图解析器的描述正确的是","选项F":"","选项E":"","选项D":"后缀没有任何的意义","答案":"A","选项C":"前缀没有任何的意义","选项B":"没有特定的解析规则","选项A":"视图解析的规则是前缀+方法的返回值+后缀","类型":"1-单选"},{"题干":"1535017455181SSM框架整合时springmvc配置文件中建议扫描的包结构是","选项F":"","选项E":"","选项D":"dto","答案":"C","选项C":"controller","选项B":"service","选项A":"mapper","类型":"1-单选"},{"题干":"1535017321226hibernate框架中的哪一个查询可以不用写hql语句","选项F":"","选项E":"","选项D":"saveOrUpdate","答案":"A","选项C":"save","选项B":"list","选项A":"标准查询","类型":"1-单选"},{"题干":"1535017358387关于参数mapperLocations理解正确的是","选项F":"","选项E":"","选项D":"声明mapper层接口的路径","答案":"A","选项C":"声明持久层接口的路径","选项B":"没有任何意义","选项A":"声明子映射文件的位置，并且可以使用通配符进行匹配","类型":"1-单选"},{"题干":"task运行在下面哪里个选项中Executor上的工作单元","选项F":"","选项E":"","选项D":"cluster","答案":"C","选项C":"worker","选项B":"master","选项A":"driver","类型":"1-单选"},{"题干":"DataFrame和RDD最大的区别是什么","选项F":"","选项E":"","选项D":"外部数据源支持","答案":"B","选项C":"存储方式不一样","选项B":"多了schema","选项A":"科学统计支持","类型":"1-单选"},{"题干":"spark集群的web端口是哪个","选项F":"","选项E":"","选项D":"4040","答案":"A","选项C":"18080","选项B":"8090","选项A":"8080","类型":"1-单选"},{"题干":"spark中弹性分布式数据集指的是哪个","选项F":"","选项E":"","选项D":"Map","答案":"A","选项C":"Master","选项B":"Driver","选项A":"RDD","类型":"1-单选"},{"题干":"以下可以将数据持久化到硬盘的算子是哪个","选项F":"","选项E":"","选项D":"map","答案":"C","选项C":"persist","选项B":"reduce","选项A":"foreach","类型":"1-单选"},{"题干":"下列算子可以遍历List集合并且没有返回值的是","选项F":"","选项E":"","选项D":"map","答案":"A","选项C":"persist","选项B":"reduce","选项A":"foreach","类型":"1-单选"},{"题干":"spark中有向无环图指的是哪个","选项F":"","选项E":"","选项D":"DAG","答案":"D","选项C":"Driver","选项B":"Task","选项A":"Master","类型":"1-单选"},{"题干":"DAG调度器会将结果以什么样的形式传给Task调度器","选项F":"","选项E":"","选项D":"Job","答案":"A","选项C":"DAG","选项B":"Task","选项A":"TaskSet","类型":"1-单选"},{"题干":"分发task任务是哪个节点的作用","选项F":"","选项E":"","选项D":"application","答案":"B","选项C":"worker","选项B":"driver","选项A":"master","类型":"1-单选"},{"题干":"RDD之间宽窄依赖关系的主要依据哪个的对应关系来划分的","选项F":"","选项E":"","选项D":"数据","答案":"A","选项C":"master","选项B":"worker","选项A":"partition","类型":"1-单选"},{"题干":"java判断一个对象是否为某个类的实例可以使用以下哪个方法","选项F":"","选项E":"","选项D":"contains","答案":"B","选项C":"inInstance","选项B":"instanceof","选项A":"equals","类型":"1-单选"},{"题干":"不属于Linux发行版的是以下的哪个？","选项F":"","选项E":"","选项D":"Unix","答案":"D","选项C":"CentOS","选项B":"RedHat","选项A":"Debian","类型":"1-单选"},{"题干":"http的默认端口号是什么端口？","选项F":"","选项E":"","选项D":"222","答案":"A","选项C":"443","选项B":"8080","选项A":"80","类型":"1-单选"},{"题干":"Java应用程序经过编译后会产生一个以（\u00A0）为扩展名的字节码文件","选项F":"","选项E":"","选项D":".html","答案":"B","选项C":".exe","选项B":".class","选项A":".java","类型":"1-单选"},{"题干":"给定以下程序段，如下\nint\u00A0i=0,j=-1;\nswitch(i){\u00A0\ncase\u00A00:j=1;\u00A0\ncase\u00A02:j=2;\u00A0\ndefault:j=5;\u00A0\n}\nSystem.out.print(\"j=\"+j);\u00A0编译运行，正确的是（\u00A0）","选项F":"","选项E":"","选项D":"j=5","答案":"D","选项C":"j=2","选项B":"j=1","选项A":"j=-1","类型":"1-单选"},{"题干":"如下Java程序片段\u00A0\nString\u00A0a\u00A0=\u00A0\"abcdefg\";\u00A0String\u00A0b\u00A0=\u00A0\"abcdefg\";\nSystem.out.println(a==b);\u00A0\n运行后，该程序段的输出结果是","选项F":"","选项E":"","选项D":"编译出错","答案":"A","选项C":"0","选项B":"false","选项A":"true","类型":"1-单选"},{"题干":"下面的代码段中，执行之后i\u00A0和j\u00A0的值是什么?\nint\u00A0i\u00A0=\u00A01;\nint\u00A0j;\nj\u00A0=\u00A0i++;","选项F":"","选项E":"","选项D":"2,�2","答案":"C","选项C":"2,�1","选项B":"1,�2","选项A":"1,�1","类型":"1-单选"},{"题干":"下面哪个是入口函数main()函数的合法参数?","选项F":"","选项E":"","选项D":"String�args","答案":"C","选项C":"String�args[]","选项B":"char�args[][]","选项A":"char�args[]","类型":"1-单选"},{"题干":"欲构造ArrayList类得一个实例，此类继承了List接口，下列哪个方法是正确的","选项F":"","选项E":"","选项D":"List�myList�=�new�List();","答案":"B","选项C":"ArraylList�myList�=�new�List();","选项B":"List�myList�=�new�ArrayList();","选项A":"ArrayList�myList�=�new�Object();","类型":"1-单选"},{"题干":"代理模式的作用是","选项F":"","选项E":"","选项D":"为其他对象提供一种锁的机制","答案":"A","选项C":"为其他对象提供一种多态的方式","选项B":"为其他对象提供一种继承的方式","选项A":"为其他对象提供一种代理以控制对这个对象的访问","类型":"1-单选"},{"题干":"CGLIB实现动态代理不需要做内容是","选项F":"","选项E":"","选项D":"完成实例化Enhancer","答案":"A","选项C":"完成拦截器","选项B":"完成被代理类","选项A":"完成接口","类型":"1-单选"},{"题干":"JDK动态代理需要实现的内容是","选项F":"","选项E":"","选项D":"实现回调接口InvocationHandler","答案":"D","选项C":"完成实例化Enhancer","选项B":"接口","选项A":"被代理类","类型":"1-单选"},{"题干":"JDK动态代理利用是Java的那个机制","选项F":"","选项E":"","选项D":"面向对象机制","答案":"A","选项C":"依赖注入机制","选项B":"注解机制","选项A":"反射机制","类型":"1-单选"},{"题干":"实现jdk动态代理一定要到的类是","选项F":"","选项E":"","选项D":"String","答案":"B","选项C":"Arrays","选项B":"Proxy","选项A":"Thread","类型":"1-单选"},{"题干":"实现CGLIB需要实现的类或接口是","选项F":"","选项E":"","选项D":"MethodInterceptor","答案":"D","选项C":"Thread","选项B":"Arrays","选项A":"Proxy","类型":"1-单选"},{"题干":"CGLIB生成的动态代理类与目标类的关系，是以下的哪个？","选项F":"","选项E":"","选项D":"依赖","答案":"A","选项C":"实现共同接口","选项B":"实现","选项A":"继承","类型":"1-单选"},{"题干":"JDK生成的动态代理类与目标类关系是","选项F":"","选项E":"","选项D":"没有关系","答案":"C","选项C":"实现共同接口","选项B":"实现","选项A":"继承","类型":"1-单选"},{"题干":"关于CGLIb原理说法正确的是","选项F":"","选项E":"","选项D":"使用反射机制转换字节码并修改目标类","答案":"A","选项C":"使用反射机制转换字节码并生成新的类","选项B":"使用字节码处理框架ASM转换字节码并修改目标类","选项A":"使用字节码处理框架ASM转换字节码并生成新的类","类型":"1-单选"},{"题干":"关于Proxy说法正确的是","选项F":"","选项E":"","选项D":"需要实例化后才能使用","答案":"B","选项C":"是一个抽象类","选项B":"是一个工具类","选项A":"是一个接口","类型":"1-单选"},{"题干":"JSP相当于MVC架构中的哪层？","选项F":"","选项E":"","选项D":"数据持久层","答案":"A","选项C":"模型层","选项B":"控制层","选项A":"视图层","类型":"1-单选"},{"题干":"在jsp中，page指令的（）属性用来引入需要的包或类。","选项F":"","选项E":"","选项D":"import","答案":"D","选项C":"extends","选项B":"include","选项A":"languge","类型":"1-单选"},{"题干":"JSP页面经过编译之后，将创建一个","选项F":"","选项E":"","选项D":"exe文件","答案":"B","选项C":"application","选项B":"servlet","选项A":"applet","类型":"1-单选"},{"题干":"Servlet程序的入口点是下列哪个函数","选项F":"","选项E":"","选项D":"doGet()","答案":"A","选项C":"service()","选项B":"main()","选项A":"init()","类型":"1-单选"},{"题干":"servlet的生命周期中，销毁Servlet实例时调用的方法是","选项F":"","选项E":"","选项D":"destroy()","答案":"D","选项C":"service()","选项B":"init()","选项A":"close()","类型":"1-单选"},{"题干":"servlet中，重定向使用的jsp内置对象是","选项F":"","选项E":"","选项D":"out","答案":"A","选项C":"session","选项B":"request","选项A":"response","类型":"1-单选"},{"题干":"在servlet中实现转发，使用的jsp内置对象是","选项F":"","选项E":"","选项D":"out","答案":"B","选项C":"session","选项B":"request","选项A":"response","类型":"1-单选"},{"题干":"url地址长度限制一般是多少？","选项F":"","选项E":"","选项D":"8K","答案":"B","选项C":"4K","选项B":"2K","选项A":"1K","类型":"1-单选"},{"题干":"在HttpServlet中，用来处理GET请求的方法是","选项F":"","选项E":"","选项D":"doPut()","答案":"B","选项C":"doPost()","选项B":"doGet()","选项A":"doHead()","类型":"1-单选"},{"题干":"HttpServlet中，用来处理POST请求的方法是哪个","选项F":"","选项E":"","选项D":"doPut()","答案":"C","选项C":"doPost()","选项B":"doGet()","选项A":"doHead()","类型":"1-单选"},{"题干":"在jquery中想要实现通过远程http get请求载入信息功能的是下面的哪个","选项F":"","选项E":"","选项D":"$.getScript(url)","答案":"C","选项C":"$.get(url)","选项B":"load(url)","选项A":"$.ajax()","类型":"1-单选"},{"题干":"$.ajax()的参数async的默认值是","选项F":"","选项E":"","选项D":"0","答案":"A","选项C":"1","选项B":"false","选项A":"true","类型":"1-单选"},{"题干":"$.ajax()的参数type的默认值是","选项F":"","选项E":"","选项D":"DELETE","答案":"B","选项C":"PUT","选项B":"GET","选项A":"POST","类型":"1-单选"},{"题干":"$.ajax()的参数url的默认值是哪个","选项F":"","选项E":"","选项D":"当前页地址","答案":"D","选项C":"post","选项B":"get","选项A":"空串","类型":"1-单选"},{"题干":"jQuery.getJSON()中，当请求成功时运行的函数是","选项F":"","选项E":"","选项D":"complete","答案":"B","选项C":"beforeSend","选项B":"success","选项A":"error","类型":"1-单选"},{"题干":"jQuery.getScript()中，必须的参数是","选项F":"","选项E":"","选项D":"url","答案":"D","选项C":"error","选项B":"success","选项A":"data","类型":"1-单选"},{"题干":"jQuery中内置的与AJAX相关的函数是哪个？","选项F":"","选项E":"","选项D":"$.each()","答案":"C","选项C":"$.post()","选项B":"$.save()","选项A":"$.init()","类型":"1-单选"},{"题干":"jquery中load()方法从服务器加载数据，必须的参数是","选项F":"","选项E":"","选项D":"callback","答案":"A","选项C":"success","选项B":"data","选项A":"URL","类型":"1-单选"},{"题干":"调用jQuery.get()方法，必须使用的参数是哪个？","选项F":"","选项E":"","选项D":"url","答案":"D","选项C":"data","选项B":"success","选项A":"dataType","类型":"1-单选"},{"题干":"jquery中$.post()的第一个参数是","选项F":"","选项E":"","选项D":"提交的类型","答案":"B","选项C":"发送的数据","选项B":"发送请求的地址","选项A":"返回的回调函数","类型":"1-单选"},{"题干":"在使用SpringMVC时候@RequestMapping的作用","选项F":"","选项E":"","选项D":"指定重定向地址","答案":"C","选项C":"指定请求的地址","选项B":"指定转发地址","选项A":"获取前台数据","类型":"1-单选"},{"题干":"SpringMVC中，哪个是处理request\u00A0header部分的注解","选项F":"","选项E":"","选项D":"@PathVariable","答案":"B","选项C":"@RequestParam","选项B":"@RequestHeader","选项A":"@ModelAttribute","类型":"1-单选"},{"题干":"下面有关SpringMVC的注解@RequestMapping(value=\"/get/{bookid}\",method={RequestMethod.GET})可以匹配请求哪种的method类型","选项F":"","选项E":"","选项D":"DELETE","答案":"A","选项C":"PUT","选项B":"POST","选项A":"GET","类型":"1-单选"},{"题干":"SpringMVC中，哪个是处理request\u00A0body部分的注解","选项F":"","选项E":"","选项D":"@SessionAttributes","答案":"C","选项C":"@RequestBody","选项B":"@RequestHeader","选项A":"@ModelAttribute","类型":"1-单选"},{"题干":"SpringMVC中通用的注解是以下哪个选项","选项F":"","选项E":"","选项D":"@Repository","答案":"B","选项C":"@Service","选项B":"@Component","选项A":"@Controller","类型":"1-单选"},{"题干":"SpringMVC的注解@RequestMapping(value\u00A0=\u00A0\"/produces\",\u00A0produces\u00A0=\u00A0\"application/json\")根据请求头中的Accept进行匹配，以下哪个请求头可匹配","选项F":"","选项E":"","选项D":"Accept:application/pdf","答案":"A","选项C":"Accept:text/html","选项B":"Accept:application/xml","选项A":"Accept:application/json","类型":"1-单选"},{"题干":"SpringMVC的注解@RequestMapping(value=\"/get/{productid}\",method={RequestMethod.POST})能匹配请求的下面那个选项的method类型","选项F":"","选项E":"","选项D":"DELETE","答案":"B","选项C":"PUT","选项B":"POST","选项A":"GET","类型":"1-单选"},{"题干":"1537322260在ssm框架使用中关于SpringMVC，Resource注解的说法正确的是（）","选项F":"","选项E":"","选项D":"默认按照名称装配","答案":"BD","选项C":"属于Spring的","选项B":"属于JavaEE的","选项A":"默认按照类型装配","类型":"1-单选"},{"题干":"1537322260在ssm框架使用关于SpringMVC，Controller类默认Scope是单例（singleton）的。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"1-单选"},{"题干":"1537322260在ssm框架使用关于SpringMVC，SpringMVC把所有的Controller请求都提交给DispatcherServlet，它会委托应用系","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"1-单选"},{"题干":"1537322260在ssm框架使用关于SpringMVC，SpringMVC把所有的Controller请求都提交给DispatcherServlet，它会委托应用系统的HandlerMapping模块负责负责对请求交给特定的Controller进行真正的处理工作。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"1-单选"},{"题干":"1537322260在ssm框架使用关于SpringMVC，SpringMVC通过一套MVC注解，让POJO成为处理请求的控制器，而无须实现任何接口。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"1-单选"},{"题干":"1537322260在ssm框架使用关于SpringMVC，SpingMVC中的控制器的注解可以使用Controller。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"1-单选"},{"题干":"1537322260在ssm框架使用关于SpringMVC，SpringMvc中有个类把视图和数据都合并的一起的，名字是（）","选项F":"","选项E":"","选项D":"Model","答案":"A","选项C":"ModelMap","选项B":"RedirectView","选项A":"ModelAndView","类型":"1-单选"},{"题干":"1537322260在ssm框架使用SpringMVC的控制器返回Json数据要用的注解是哪个","选项F":"","选项E":"","选项D":"PathVariable","答案":"B","选项C":"RequestParam","选项B":"ResponseBody","选项A":"Autowired","类型":"1-单选"},{"题干":"1537322260在ssm框架使用关于SpringMVC上传文件，form表单的method设置为（）","选项F":"","选项E":"","选项D":"delete","答案":"C","选项C":"post","选项B":"put","选项A":"get","类型":"1-单选"},{"题干":"1537322260在ssm框架使用中关于SpringMVC，利用什么技术解决上传时文件名的重名问题（）","选项F":"","选项E":"","选项D":"无法彻底解决","答案":"A","选项C":"限制上传文件个数","选项B":"限制文件类型","选项A":"UUID","类型":"1-单选"},{"题干":"1537322260在ssm框架使用中关于SpringMVC，如果需要修改框架配置文件的位置及其名称，可以在以下（）文件当中做相关的设置。","选项F":"","选项E":"","选项D":"applicationContext.properties","答案":"B","选项C":"springmvc.xml","选项B":"web.xml","选项A":"applicationContext.xml","类型":"1-单选"},{"题干":"1537322260在ssm框架使用中SpringMVC处理文件上传和下载时需要第三方jar是（）","选项F":"","选项E":"","选项D":"servlet.jar","答案":"AC","选项C":"commons-io.jar","选项B":"log4j.jar","选项A":"commons-fileupload.jar","类型":"1-单选"},{"题干":"1537322260在ssm框架使用中关于SpringMVC，核心控制器DispatcherServlet的作用，以下说法正确的包括（）","选项F":"","选项E":"","选项D":"初始化上下文应用对象ApplicationContext","答案":"BCD","选项C":"加载配置文件","选项B":"它负责接收HTTP请求","选项A":"实现业务操作","类型":"1-单选"},{"题干":"1537322260在ssm框架使用中SpringMVC框架中，ModelAndView对象描述正确的是（）","选项F":"","选项E":"","选项D":"控制层的方法的返回值可以是ModelAndView","答案":"ABCD","选项C":"称之为模型视图对象","选项B":"可以添加指定的对象，然后再跳转的JSP视图中取到所存放的值","选项A":"可以用来设置去往哪一个页面","类型":"1-单选"},{"题干":"1537322260在ssm框架使用中SpringMVC中控制器的组件包括前端控制器DispatcherServlet、HandlerMapping和Controller。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"1-单选"},{"题干":"1537322260在ssm框架使用中关于SpringMVC，Springmvc属于spring框架的一部分。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"1-单选"},{"题干":"1537322260在ssm框架使用中关于SpringMVC，SpringMVC采用了松散耦合可插拔组件结构，比其他MVC框架更具扩展性和灵活性。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"1-单选"},{"题干":"1537322260在ssm框架使用中除了SpringMVC，还可以用其它方式实现文件上传下载功能。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"1-单选"},{"题干":"1537322260在ssm框架使用中SpringMVC中的Controller默认Scope不是单例（singleton）的。","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"1-单选"},{"题干":"1537322260在ssm框架使用中SpringMVC框架中自定义拦截器实现的接口是（）","选项F":"","选项E":"","选项D":"Filter","答案":"A","选项C":"HandlerFilter","选项B":"Interceptor","选项A":"HandlerInterceptor","类型":"1-单选"},{"题干":"1537322260在ssm框架使用中SpringMVC框架中拦截器中的方法preHandle的返回类型是（）","选项F":"","选项E":"","选项D":"String","答案":"B","选项C":"int","选项B":"boolean","选项A":"void","类型":"1-单选"},{"题干":"1537322260在ssm框架使用中SpringMVC框架中拦截器可以实现（）","选项F":"","选项E":"","选项D":"做一些过滤操作，获取我们想要获取的数据","答案":"A","选项C":"事务控制","选项B":"数据库是否已连接验证","选项A":"用户是否已登录","类型":"1-单选"},{"题干":"1537322260在ssm框架使用中SpringMVC框架中@RequestMapping的属性不包括（）","选项F":"","选项E":"","选项D":"method","答案":"A","选项C":"value","选项B":"produces","选项A":"type","类型":"1-单选"},{"题干":"1537322260在ssm框架使用中SpringMVC框架拦截器中的方法afterCompletion说法正确的是（）","选项F":"","选项E":"","选项D":"在action执行后，生成视图前执行","答案":"B","选项C":"在性能监控中我们可以在此记录结束时间并输出消耗时间，还可以进行一些资源清理，当preHandle返回false时才会执行","选项B":"整个请求处理完毕后调用","选项A":"任何时候能要执行","类型":"1-单选"},{"题干":"1537322260在ssm框架使用中在SpringMVC框架中RedirectView属于（）","选项F":"","选项E":"","选项D":"模型＋视图","答案":"B","选项C":"模型","选项B":"视图","选项A":"控制器","类型":"1-单选"},{"题干":"1537322260在ssm框架使用中Spring框架包括若干个松耦合的组件，以下说法不正确的是（）","选项F":"","选项E":"","选项D":"Spring与SpringMVC都是典型的MVC框架","答案":"D","选项C":"SpringMVC是MVC 框架，spring框架是其他框架的粘合剂。两者之间存在着包含关系。","选项B":"SpringMVC属于Spring的一部分","选项A":"SpringMVC是Spring框架中web模块的一部分","类型":"1-单选"},{"题干":"1537322260在ssm框架使用中SpringMVC框架中InternalResourceViewResolver属于（）","选项F":"","选项E":"","选项D":"持久层组件","答案":"B","选项C":"控制层组件","选项B":"视图层组件","选项A":"模型层组件","类型":"1-单选"},{"题干":"1537322260在ssm框架使用中SpringMVC框架中拦截器的实现方式是（）","选项F":"","选项E":"","选项D":"继承InterceptorAdapter类","答案":"AB","选项C":"实现Interceptor接口","选项B":"继承HandleInterceptorAdapter类","选项A":"实现HandleInterceptor接口","类型":"1-单选"},{"题干":"1537322260在ssm框架使用中SpringMVC框架中控制器组件包括（）","选项F":"","选项E":"","选项D":"ModelAndView","答案":"ABC","选项C":"处理业务的Controller组件","选项B":"HandlerMapping组件","选项A":"核心控制器DispatcherServlet","类型":"1-单选"},{"题干":"1537322260在ssm框架使用中SpringMVC框架提供了丰富的前台参数值获取方案，以下不是获取前台数据的方式是（）","选项F":"","选项E":"","选项D":"RequestMapping","答案":"BD","选项C":"参数","选项B":"ActionForm","选项A":"getParameter","类型":"1-单选"},{"题干":"1537322260在ssm框架使用中SpringMVC框架拦截器可以实现的功能有（）","选项F":"","选项E":"","选项D":"日志记录","答案":"ABCD","选项C":"可以解决静态资源被拦截","选项B":"性能监测","选项A":"登录验证","类型":"1-单选"},{"题干":"在ssm框架使用关于SpringMVC，SpringMvc中有个类把视图和数据都合并的一起的，名字是（）","选项F":"","选项E":"","选项D":"Model","答案":"A","选项C":"ModelMap","选项B":"RedirectView","选项A":"ModelAndView","类型":"1-单选"},{"题干":"在ssm框架使用SpringMVC的控制器返回Json数据要用的注解是哪个","选项F":"","选项E":"","选项D":"PathVariable","答案":"B","选项C":"RequestParam","选项B":"ResponseBody","选项A":"Autowired","类型":"1-单选"},{"题干":"在ssm框架使用关于SpringMVC上传文件，form表单的method设置为（）","选项F":"","选项E":"","选项D":"delete","答案":"C","选项C":"post","选项B":"put","选项A":"get","类型":"1-单选"},{"题干":"在ssm框架使用中关于SpringMVC，利用什么技术解决上传时文件名的重名问题（）","选项F":"","选项E":"","选项D":"无法彻底解决","答案":"A","选项C":"限制上传文件个数","选项B":"限制文件类型","选项A":"UUID","类型":"1-单选"},{"题干":"在ssm框架使用中关于SpringMVC，如果需要修改框架配置文件的位置及其名称，可以在以下（）文件当中做相关的设置。","选项F":"","选项E":"","选项D":"applicationContext.properties","答案":"B","选项C":"springmvc.xml","选项B":"web.xml","选项A":"applicationContext.xml","类型":"1-单选"},{"题干":"在ssm框架使用中SpringMVC框架中自定义拦截器实现的接口是（）","选项F":"","选项E":"","选项D":"Filter","答案":"A","选项C":"HandlerFilter","选项B":"Interceptor","选项A":"HandlerInterceptor","类型":"1-单选"},{"题干":"在ssm框架使用中SpringMVC框架中拦截器中的方法preHandle的返回类型是（）","选项F":"","选项E":"","选项D":"String","答案":"B","选项C":"int","选项B":"boolean","选项A":"void","类型":"1-单选"},{"题干":"在ssm框架使用中SpringMVC框架中拦截器可以实现（）","选项F":"","选项E":"","选项D":"做一些过滤操作，获取我们想要获取的数据","答案":"A","选项C":"事务控制","选项B":"数据库是否已连接验证","选项A":"用户是否已登录","类型":"1-单选"},{"题干":"在ssm框架使用中SpringMVC框架中@RequestMapping的属性不包括（）","选项F":"","选项E":"","选项D":"method","答案":"A","选项C":"value","选项B":"produces","选项A":"type","类型":"1-单选"},{"题干":"在ssm框架使用中SpringMVC框架拦截器中的方法afterCompletion说法正确的是（）","选项F":"","选项E":"","选项D":"在action执行后，生成视图前执行","答案":"B","选项C":"在性能监控中我们可以在此记录结束时间并输出消耗时间，还可以进行一些资源清理，当preHandle返回false时才会执行","选项B":"整个请求处理完毕后调用","选项A":"任何时候能要执行","类型":"1-单选"},{"题干":"在ssm框架使用中在SpringMVC框架中RedirectView属于（）","选项F":"","选项E":"","选项D":"模型＋视图","答案":"B","选项C":"模型","选项B":"视图","选项A":"控制器","类型":"1-单选"},{"题干":"在ssm框架使用中Spring框架包括若干个松耦合的组件，以下说法不正确的是（）","选项F":"","选项E":"","选项D":"Spring与SpringMVC都是典型的MVC框架","答案":"D","选项C":"SpringMVC是MVC 框架，spring框架是其他框架的粘合剂。两者之间存在着包含关系。","选项B":"SpringMVC属于Spring的一部分","选项A":"SpringMVC是Spring框架中web模块的一部分","类型":"1-单选"},{"题干":"在ssm框架使用中SpringMVC框架中InternalResourceViewResolver属于（）","选项F":"","选项E":"","选项D":"持久层组件","答案":"B","选项C":"控制层组件","选项B":"视图层组件","选项A":"模型层组件","类型":"1-单选"},{"题干":"java面向对象中声明抽象类和抽象方法用到的关键字是什么？","选项F":"","选项E":"","选项D":"extends","答案":"A","选项C":"interface","选项B":"class","选项A":"abstract","类型":"1-单选"},{"题干":"java代码int\u00A0j=1;\nfor(\u00A0int\u00A0i=j++;\u00A0i<3;\u00A0i++){\n\u00A0\u00A0\u00A0\u00A0System.out.print(i);\n}\n的输出结果是","选项F":"","选项E":"","选项D":"2","答案":"B","选项C":"234","选项B":"12","选项A":"123","类型":"1-单选"},{"题干":"java代码String\u00A0str=\"字符串长度point\";字符串的长度为？","选项F":"","选项E":"","选项D":"10","答案":"D","选项C":"11","选项B":"12","选项A":"15","类型":"1-单选"},{"题干":"有java代码int\u00A0a=(int)Math.floor(4.6);则a的值为？","选项F":"","选项E":"","选项D":"-5","答案":"A","选项C":"-4","选项B":"5","选项A":"4","类型":"1-单选"},{"题干":"java中，Math类的哪个方法可以取绝对值？","选项F":"","选项E":"","选项D":"round()","答案":"C","选项C":"abs()","选项B":"random()","选项A":"max()","类型":"1-单选"},{"题干":"在Java中创建字符串，不正确的代码是什么？","选项F":"","选项E":"","选项D":"String�s�=�new�String(\"ABC\");","答案":"A","选项C":"String�s�=�new�String(new�char[]{});","选项B":"String�s�=�new�String(new�byte[]{});","选项A":"String�s�=�new�String('A');","类型":"1-单选"},{"题干":"CGLIB实现动态代理是基于什么实现","选项F":"","选项E":"","选项D":"数组","答案":"A","选项C":"类和接口","选项B":"接口","选项A":"类","类型":"1-单选"},{"题干":"JDK动态代理是基于什么实现","选项F":"","选项E":"","选项D":"数组","答案":"B","选项C":"类和接口","选项B":"接口","选项A":"类","类型":"1-单选"},{"题干":"实现jdk动态代理调用Proxy类中的那个方法实现","选项F":"","选项E":"","选项D":"checkNewProxyPermission(Reflection.getCallerClass(), cl);","答案":"A","选项C":"isProxyClass(Class<?> cl)","选项B":"getInvocationHandler(Object proxy)","选项A":"Proxy.newProxyInstance(target.getClass().getClassLoader(),target.getClass().getInterfaces(),this);","类型":"1-单选"},{"题干":"以下不属于代理模式所涉及到的角色是","选项F":"","选项E":"","选项D":"物理角色","答案":"D","选项C":"代理角色","选项B":"真实角色","选项A":"抽象角色","类型":"1-单选"},{"题干":"以下不属于CGlib代理模式使用的api是","选项F":"","选项E":"","选项D":"java.lang.reflect.InvocationHandler","答案":"D","选项C":"net.sf.cglib.proxy.MethodProxy","选项B":"net.sf.cglib.proxy.MethodInterceptor","选项A":"net.sf.cglib.proxy.Enhancer","类型":"1-单选"},{"题干":"以下关于单例模式说法错误的是","选项F":"","选项E":"","选项D":"单例类提供有多个实例","答案":"D","选项C":"单例类必须给所有其他对象提供这一实例","选项B":"单例类必须自己创建自己的唯一实例","选项A":"单例类只能有一个实例","类型":"1-单选"},{"题干":"Java在使用反射中获取访问修饰符的方法是","选项F":"","选项E":"","选项D":"getModify()","答案":"A","选项C":"getModel()","选项B":"getMethods()","选项A":"getModifiers()","类型":"1-单选"},{"题干":"JAVA反射机制提供功能不包括","选项F":"","选项E":"","选项D":"在运行时获取类的子类","答案":"D","选项C":"运行时构造任意一个类的对象","选项B":"运行时判断任意一个类所具有的成员变量和方法","选项A":"运行时调用任意一个对象的方法","类型":"1-单选"},{"题干":"在Java的反射中，以下那个方法可以通过反射获取父类","选项F":"","选项E":"","选项D":"getSuperclass();","答案":"D","选项C":"newInstance();","选项B":"getMethod();","选项A":"getClassLoader();","类型":"1-单选"},{"题干":"在Java反射中，Class对象的方法getName()的功能是","选项F":"","选项E":"","选项D":"返回此Class对象所表示的实体的全限定名称","答案":"D","选项C":"返回此Class对象所表示的实体的所有公共方法","选项B":"返回此Class对象所表示的实体的所有公共字段","选项A":"返回此Class对象所表示的实体的简称","类型":"1-单选"},{"题干":"solrconfig.xml主要是配置","选项F":"","选项E":"","选项D":"为分布式的复制配置相关的参数","答案":"ABCD","选项C":"为HTTP请求配置Request Dispatcher","选项B":"为某些事件配置listener，以触发执行某些代码","选项A":"为建索引和搜索等请求配置Request Handler","类型":"2-多选"},{"题干":"以下标签中属于solrconfig.xml配置文件的是","选项F":"","选项E":"","选项D":"<query/>","答案":"ABCD","选项C":"<updateHandler/>","选项B":"<requestHandler/>","选项A":"<lib/>","类型":"2-多选"},{"题干":"在向solr中添加数据时会用到的方法是（）","选项F":"","选项E":"","选项D":"query.setRows()","答案":"AB","选项C":"query.setQuery()","选项B":"client.commit()","选项A":"client.add()","类型":"2-多选"},{"题干":"使用solr查询数据分页会用到的方法是（）","选项F":"","选项E":"","选项D":"setQuery()","答案":"BC","选项C":"setRows()","选项B":"setStart()","选项A":"commit()","类型":"2-多选"},{"题干":"以下属于facet查询中的属性的是（）","选项F":"","选项E":"","选项D":"facet.field()","答案":"AD","选项C":"setStart()","选项B":"commit()","选项A":"facet.query()","类型":"2-多选"},{"题干":"springmvc中除了根标签还可以有以下哪些标签","选项F":"","选项E":"","选项D":"mvc:annotation-driven","答案":"ABCD","选项C":"property","选项B":"context:component-scan","选项A":"bean","类型":"2-多选"},{"题干":"1536202063161属于事务特性的是","选项F":"","选项E":"","选项D":"原子性","答案":"ABCD","选项C":"隔离性","选项B":"持久性","选项A":"一致性","类型":"2-多选"},{"题干":"springmvc作为控制层框架，以下描述准确的是","选项F":"","选项E":"","选项D":"不可以单独使用","答案":"ABC","选项C":"可以单独使用","选项B":"优秀的mvc框架，符合mvc的设计理念","选项A":"springmvc被包含在spring当中","类型":"2-多选"},{"题干":"spring框架中以下都包含以下哪些模块","选项F":"","选项E":"","选项D":"orm","答案":"ABCD","选项C":"dao","选项B":"aop","选项A":"core","类型":"2-多选"},{"题干":"spring框架中的七大核心模块包括","选项F":"","选项E":"","选项D":"dao","答案":"ABCD","选项C":"aop","选项B":"orm","选项A":"core","类型":"2-多选"},{"题干":"对jQuery中的ajax描述，正确的是（  ）","选项F":"","选项E":"","选项D":"jQuery使用ajax时，需要使用XMLHttpRequest对象","答案":"ACD","选项C":"是由Asynchronous\u00A0JavaScript\u00A0and\u00A0XML进行的编写。","选项B":"jQuery使用ajax时，不需要使用XMLHttpRequest对象","选项A":"javascript使用ajax时，需要使用XMLHttpRequest对象","类型":"2-多选"},{"题干":"下列对jQuery中的ajax描述正确的是（  ）","选项F":"","选项E":"","选项D":"jQuery中的ajax解决了大部分浏览器的兼容性问题","答案":"ABCD","选项C":"第三层封装产生$.getJSON()，$.getScript()","选项B":"第二层封装产生$.get()，$.post()，load()","选项A":"第一层封装产生了$.ajax()","类型":"2-多选"},{"题干":"以下对$.ajax()方法中的属性说法正确的是（  ）","选项F":"","选项E":"","选项D":"success：请求成功执行的回调函数","答案":"ABCD","选项C":"dataType：预期服务器返回的结果类型","选项B":"type：请求方式","选项A":"url：请求地址","类型":"2-多选"},{"题干":"ajax中，对$.post(url,data,callback,type)方法中的参数说法正确的是","选项F":"","选项E":"","选项D":"url：请求地址","答案":"ABCD","选项C":"callback：请求成功执行的回调函数","选项B":"type：预期服务器返回的结果类型","选项A":"data：发送的服务器的数据","类型":"2-多选"},{"题干":"jquery中post包括下面哪些参数（  ）","选项F":"","选项E":"","选项D":"type,返回内容格式","答案":"ABCD","选项C":"callback","选项B":"data","选项A":"url","类型":"2-多选"},{"题干":"下列选项中，File类的哪些方法可以创建文件夹","选项F":"","选项E":"","选项D":"mkdirs()","答案":"BD","选项C":"newFile()","选项B":"mkdir","选项A":"createFile()","类型":"2-多选"},{"题干":"下列选项中，属于线程生命周期状态的有","选项F":"","选项E":"","选项D":"运行状态","答案":"ABCD","选项C":"阻塞状态","选项B":"就绪状态","选项A":"新建状态","类型":"2-多选"},{"题干":"下列选项中，属于SQL中DML语言关键字的有","选项F":"","选项E":"","选项D":"select","答案":"ABC","选项C":"update","选项B":"delete","选项A":"insert","类型":"2-多选"},{"题干":"下列选项中，可以实现多线程的有","选项F":"","选项E":"","选项D":"实现Thread","答案":"AB","选项C":"实现Serializable","选项B":"实现Runnable","选项A":"继承Thread","类型":"2-多选"},{"题干":"下列选项中，属于Thread类提供的线程控制方法的有哪些？","选项F":"","选项E":"","选项D":"yield","答案":"ABD","选项C":"init","选项B":"interrupt","选项A":"sleep","类型":"2-多选"},{"题干":"以下Solr的功能特点正确的是","选项F":"","选项E":"","选项D":"全文检索","答案":"ABCD","选项C":"相似匹配","选项B":"高度扩展","选项A":"高度容错","类型":"2-多选"},{"题干":"Solr支 持的 模式描述正确的有","选项F":"","选项E":"","选项D":"支持反向代理","答案":"BC","选项C":"支持无模式配置","选项B":"支持模式配置","选项A":"支持负载均衡","类型":"2-多选"},{"题干":"以下 描述 正确的有","选项F":"","选项E":"","选项D":"Solr支持全文检索","答案":"ABD","选项C":"Solr支持持久化","选项B":"Solr是apache组织维护的","选项A":"Solr支持rest风格API","类型":"2-多选"},{"题干":"以下属于全 文检 索框架的有","选项F":"","选项E":"","选项D":"ElasticSearch","答案":"BCD","选项C":"Lucene","选项B":"Solr","选项A":"Like","类型":"2-多选"},{"题干":"Solr查 询 语 法介绍正确的有","选项F":"","选项E":"","选项D":"支持范围匹配","答案":"ABCD","选项C":"支持通配符查询","选项B":"匹配所有文档","选项A":"支持布尔操作","类型":"2-多选"},{"题干":"以下哪些方法是Session的方法（）","选项F":"","选项E":"","选项D":"save","答案":"BCD","选项C":"delete","选项B":"update","选项A":"list","类型":"2-多选"},{"题干":"以下属于Spring与Hibernate整合的重要步骤的有（）","选项F":"","选项E":"","选项D":"在Dao中注入SessionFactory","答案":"ABCD","选项C":"在Spring配置文件中配置事务管理器的bean","选项B":"在Spring配置文件中配置SessionFactory的bean","选项A":"在Spring配置文件中配置数据源的bean","类型":"2-多选"},{"题干":"以下方法中不能更新数据库表的方法是（）","选项F":"","选项E":"","选项D":"get","答案":"CD","选项C":"find","选项B":"saveOrUpdate","选项A":"update","类型":"2-多选"},{"题干":"Spring与Hibernate整合时，Spring框架的ORM模块提供支持，通过Spring包装Hibernate，包括的优点有（）","选项F":"","选项E":"","选项D":"声明式的事务管理","答案":"ACD","选项C":"通用的代码管理","选项B":"异常封装","选项A":"测试简单","类型":"2-多选"},{"题干":"Spring与Hibernate整合时没有用到如下哪些Spring的模块（）","选项F":"","选项E":"","选项D":"Spring Web模块","答案":"CD","选项C":"Spring MVC模块","选项B":"Spring ORM模块","选项A":"Spring核心模块","类型":"2-多选"},{"题干":"（大数据）zookeeper提供的功能有什么","选项F":"","选项E":"","选项D":"组服务","答案":"ABCD","选项C":"配置维护","选项B":"域名服务","选项A":"分布式同步","类型":"2-多选"},{"题干":"（大数据）在基于TCP网络通信模式中，客户与服务器程序的主要任务是","选项F":"","选项E":"","选项D":"如果客户程序和服务器都会保证发送的数据不会在传输途中丢失","答案":"BC","选项C":"服务器程序接收并处理客户请求，然后向客户发送响应结果","选项B":"客户程序发送请求，并接收服务器的响应","选项A":"客户程序在网络上找到一条到达服务器的路由","类型":"2-多选"},{"题干":"（大数据）关于Dubbo，下面说法正确的是","选项F":"","选项E":"","选项D":"dubbo服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复","答案":"ABCD","选项C":"dubbo监控中心宕掉不影响使用，只是丢失部分采样数据：","选项B":"dubbo注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯：","选项A":"dubbo服务提供者无状态，任意一台宕掉后，不影响使用","类型":"2-多选"},{"题干":"（大数据）关于Dubbo，以下属于Dubbo支持的通讯协议的是","选项F":"","选项E":"","选项D":"RMI","答案":"ACD","选项C":"dubbo","选项B":"soap","选项A":"hessian","类型":"2-多选"},{"题干":"（大数据）关于Dubbo，以下能作为dubbo的注册中心的是","选项F":"","选项E":"","选项D":"hibernate","答案":"BC","选项C":"Zookeeper","选项B":"Redis","选项A":"spring","类型":"2-多选"},{"题干":"关于Dubbo，下面描述正确的包括哪些选项","选项F":"","选项E":"","选项D":"dubbo服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复","答案":"ABCD","选项C":"dubbo监控中心宕掉不影响使用，只是丢失部分采样数据：","选项B":"dubbo注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯：","选项A":"dubbo服务提供者无状态，任意一台宕掉后，不影响使用","类型":"2-多选"},{"题干":"电商下-以下属于Dubbo支持的通讯协议的是？（\u00A0）","选项F":"","选项E":"","选项D":"RMI","答案":"ACD","选项C":"dubbo","选项B":"soap","选项A":"hessian","类型":"2-多选"},{"题干":"电商下-在基于TCP网络通信模式中，客户与服务器程序的主要任务是（\u00A0\u00A0）","选项F":"","选项E":"","选项D":"如果客户程序和服务器都会保证发送的数据不会在传输途中丢失","答案":"BC","选项C":"服务器程序接收并处理客户请求，然后向客户发送响应结果","选项B":"客户程序发送请求，并接收服务器的响应","选项A":"客户程序在网络上找到一条到达服务器的路由","类型":"2-多选"},{"题干":"电商下-zookeeper提供的功能有什么？（\u00A0\u00A0）","选项F":"","选项E":"","选项D":"组服务","答案":"ABCD","选项C":"配置维护","选项B":"域名服务","选项A":"分布式同步","类型":"2-多选"},{"题干":"电商下-以下能作为dubbo的注册中心的是（\u00A0\u00A0）","选项F":"","选项E":"","选项D":"hibernate","答案":"BC","选项C":"Zookeeper","选项B":"Redis","选项A":"spring","类型":"2-多选"},{"题干":"以下修饰符可用于修饰接口中的变量的有（  ）。","选项F":"","选项E":"","选项D":"abstract","答案":"BC","选项C":"final","选项B":"static","选项A":"protected","类型":"2-多选"},{"题干":"以下修饰符可以用于修饰接口中的变量的是","选项F":"","选项E":"","选项D":"abstract","答案":"BC","选项C":"final","选项B":"static","选项A":"protected","类型":"2-多选"},{"题干":"super说法错误的是：","选项F":"","选项E":"","选项D":"super代表当前类实例","答案":"BCD","选项C":"super()代表调用本类无参数构造方法","选项B":"super()和this()可以在同一个构造方法中同时使用，互不影响","选项A":"默认情况下，类的所有构造方法默认都有super(),表示默认调用父类无参数构造方法","类型":"2-多选"},{"题干":"java中，哪几种说法是错误的","选项F":"","选项E":"","选项D":"类的名字一般由大写字母开头","答案":"ABC","选项C":"构造方法不能有返回值，所以返回类型应该是void","选项B":"String[]\u00A0str;\u00A0就已经创建了数组，开辟了堆内存地址","选项A":"子类在重写继承过来的方法时，要求修饰符、返回类型、方法名称、参数列表必须和父类中的完全一样。","类型":"2-多选"},{"题干":"若有如下接口A的定义，下列哪个类没实现了该接口（\u00A0\u00A0）\u00A0\u00A0\u00A0\ninterface\u00A0\u00A0A\u00A0{\n    void\u00A0method1(int\u00A0i);\n    void\u00A0method2(int\u00A0j);\n}","选项F":"","选项E":"","选项D":"class�B�{\n    void�method1(int�i�)�{�}\n    void�method2(int�j�)�{�}\n}","答案":"ABD","选项C":"class�B�implements�A�{\n    public�void�method1(int�i�)�{�}\n    public�void�method2(int�j�)�{�}\n}","选项B":"class�B�implements�A{\n    public�void�method1(int�x�)�{�}\n}","选项A":"class�B�implements�A{\n    void�method1(�)�{�}\n    void�method2(�)�{�}\n}","类型":"2-多选"},{"题干":"访问修饰符说法正确的是：","选项F":"","选项E":"","选项D":"protected访问范围为不同包的子类","答案":"ABCD","选项C":"public任何范围可访问","选项B":"default为相同包内可访问","选项A":"private只能在本类内访问","类型":"2-多选"},{"题干":"下列代码是调用父类构造器的有（  ）。","选项F":"","选项E":"","选项D":"super.say();","答案":"AC","选项C":"super();","选项B":"super.say(\"小王\");","选项A":"super(\"小王\");","类型":"2-多选"},{"题干":"以下修饰符可以用于修饰接口中的方法的有（  ）。","选项F":"","选项E":"","选项D":"abstract","答案":"AD","选项C":"final","选项B":"static","选项A":"public","类型":"2-多选"},{"题干":"以下修饰符可以用于修饰接口中的方法的是","选项F":"","选项E":"","选项D":"abstract","答案":"AD","选项C":"final","选项B":"static","选项A":"public","类型":"2-多选"},{"题干":"下面学生类Student的构造方法正确的是：：","选项F":"","选项E":"","选项D":"Student(){}","答案":"CD","选项C":"public�Student(){}","选项B":"public�student(String�name){}","选项A":"public�void�Student(){}","类型":"2-多选"},{"题干":"java中下列对抽象类的描述正确的有（\u00A0\u00A0）。","选项F":"","选项E":"","选项D":"不能通过抽象类本身进行实例化对象","答案":"BD","选项C":"不能使用抽象类声明对象","选项B":"抽象类里面有构造器","选项A":"抽象类里面没有构造器","类型":"2-多选"},{"题干":"关于重写，遵循的规则以下选项描述正确的有（）：","选项F":"","选项E":"","选项D":"D\u00A0普通方法能被重写，父类中的final方法不能被重写。","答案":"ACD","选项C":"C\u00A0重写方法必须和被重写方法具有相同的参数列表，返回类型必须和被重写方法的返回类型相同或者是返回类型的子类型。","选项B":"B\u00A0final修饰的方法是可以被子类重写","选项A":"A\u00A0重写方法的访问控制修饰符不能比被重写方法更严格（比如一个在父类中声明为public的方法重写成一个protected的方法）","类型":"2-多选"},{"题干":"关于this说法正确的是","选项F":"","选项E":"","选项D":"this可以在成员方法中使用","答案":"BD","选项C":"this代表父类的实例","选项B":"this代表当前类的实例","选项A":"this可以在静态方法中使用","类型":"2-多选"},{"题干":"关于static说法正确的是","选项F":"","选项E":"","选项D":"静态方法可以直接使用成员变量","答案":"ABC","选项C":"静态方法可以直接使用静态变量","选项B":"静态变量被类的所有对象共享","选项A":"成员方法可以直接使用静态变量","类型":"2-多选"},{"题干":"下面关于JSP的说法中正确的有（）。","选项F":"","选项E":"","选项D":"jsp中不能写java代码","答案":"AB","选项C":"jsp是javaScript的简写","选项B":"index.jsp文件经过转译之后的文件是index_jsp.java","选项A":"jsp经过转译之后就是一个servlet","类型":"2-多选"},{"题干":"下面关于Servlet的描述正确的是","选项F":"","选项E":"","选项D":"使用web.xml配置Servlet时，可以为一个Servlet配置多个mapping","答案":"BCD","选项C":"Servlet需要先配置然后才能使用","选项B":"可以通过直接实现servlet接口的方式来创建servlet","选项A":"servlet的init方法都是在servlet第一次被访问的时候调用","类型":"2-多选"},{"题干":"1535332393302在web.xml文件中，哪些选项与servlet有关（）。","选项F":"","选项E":"","选项D":"url-pattern","答案":"ABD","选项C":"tag","选项B":"servlet-class","选项A":"servlet-mapping","类型":"2-多选"},{"题干":"servlet的init方法的调用时机可能是（）。","选项F":"","选项E":"","选项D":"每次访问该Servlet时","答案":"AC","选项C":"第一次访问该Servlet时","选项B":"该servlet销毁的时候","选项A":"项目启动时","类型":"2-多选"},{"题干":"在Servlet的生命周期中会调用的方法有（）。","选项F":"","选项E":"","选项D":"service()","答案":"ACD","选项C":"destroy()","选项B":"response()","选项A":"init()","类型":"2-多选"},{"题干":"在Linux中，卸载软件的命令","选项F":"","选项E":"","选项D":"pt-get purge packagename","答案":"BD","选项C":"pt-get delete packagename","选项B":"apt-get remove packagename","选项A":"apt-get delete packagename","类型":"2-多选"},{"题干":"thread模块提供了基本的______和______的支持","选项F":"","选项E":"","选项D":"指针","答案":"AB","选项C":"进程","选项B":"锁","选项A":"线程","类型":"2-多选"},{"题干":"Thread 类支持使用两种方法来创建线程，其中一种是，继承threading.Thread类创建派生类，并重写________方法的和__________方法来实现自定义对象类。","选项F":"","选项E":"","选项D":"setName","答案":"AB","选项C":"start()","选项B":"run()","选项A":"__init__","类型":"2-多选"},{"题干":"关于矩阵以下说法正确的是","选项F":"","选项E":"","选项D":"对角线元素均为1，其余元素均为0的矩阵称为单位矩阵","答案":"ACD","选项C":"所有矩阵都有转置矩阵","选项B":"所有矩阵都有逆矩阵","选项A":"当n=m时，矩阵A称为n阶方阵","类型":"2-多选"},{"题干":"支持向量机在解决什么问题中表现出特有的优势","选项F":"","选项E":"","选项D":"大样本","答案":"ABC","选项C":"高维模式识别","选项B":"非线性","选项A":"小样本","类型":"2-多选"},{"题干":"决策树算法的主要优点是","选项F":"","选项E":"","选项D":"数据的调整会影响模型稳定性","答案":"AB","选项C":"过拟合需对模型剪枝处理","选项B":"能够同时处理连续数据和离散数据","选项A":"简单易于解释","类型":"2-多选"},{"题干":"监督学习使用的算法主要包括","选项F":"","选项E":"","选项D":"神经网络","答案":"ABCD","选项C":"支持向量机","选项B":"决策树","选项A":"逻辑回归","类型":"2-多选"},{"题干":"tf.train.AdamOptimizer(1e-4).minimize(cross_entropy)","选项F":"","选项E":"","选项D":"按照梯度dY，确定的更新参数，更新X，继续循环","答案":"ABCD","选项C":"求出反向的梯度dY","选项B":"前向传递，求出loss","选项A":"准备样本集合","类型":"2-多选"},{"题干":"tf.nn.softmax_cross_entropy_with_logits(）是","选项F":"","选项E":"","选项D":"一定全连接层","答案":"BCD","选项C":"用信息熵","选项B":"进行优化","选项A":"在卷积层","类型":"2-多选"},{"题干":"能实现卷积运算的是","选项F":"","选项E":"","选项D":"tf.random_normal","答案":"AC","选项C":"tf.nn.convolution","选项B":"tf.nn.depthwise_conv2d","选项A":"tf.nn.conv2d","类型":"2-多选"},{"题干":"卷积核K的四个重要参数是","选项F":"","选项E":"","选项D":"输出通道","答案":"ABCD","选项C":"输入通道","选项B":"宽度","选项A":"高度","类型":"2-多选"},{"题干":"能实现总体加和或平均的函数是：","选项F":"","选项E":"","选项D":"tf.norm","答案":"AC","选项C":"tf.reduce_mean","选项B":"tf.multiply","选项A":"tf.reduce_sum","类型":"2-多选"},{"题干":"如果是填充后求卷积，图像尺寸变化","选项F":"","选项E":"","选项D":"图像尺寸变小","答案":"AC","选项C":"步长为不1","选项B":"填充为1","选项A":"以0填充","类型":"2-多选"},{"题干":"在linux系统中，卸载软件的命令","选项F":"","选项E":"","选项D":"pt-get purge packagename","答案":"BD","选项C":"pt-get delete packagename","选项B":"apt-get remove packagename","选项A":"apt-get delete packagename","类型":"2-多选"},{"题干":"thread模块需要哪两个基础的支持","选项F":"","选项E":"","选项D":"指针","答案":"AB","选项C":"进程","选项B":"锁","选项A":"线程","类型":"2-多选"},{"题干":"在本月学习中，Thread 类支持使用两种方法来创建线程，其中一种是，继承threading.Thread类创建派生类，并重写________方法的和__________方法来实现自定义对象类。","选项F":"","选项E":"","选项D":"setName","答案":"AB","选项C":"start()","选项B":"run()","选项A":"__init__","类型":"2-多选"},{"题干":"多线程类似于同时执行多个不同程序，多线程运行优点描述正确的为","选项F":"","选项E":"","选项D":"线程在执行过程与进程执行过程一样","答案":"AB","选项C":"使用多线程后运行速度一定变快","选项B":"程序的运行速度可能加快","选项A":"使用线程可以把占据长时间的程序中的任务放到后台去处理","类型":"2-多选"},{"题干":"关于线程与进程描述正确的为","选项F":"","选项E":"","选项D":"使用多个进程的优势在于每个进程都是独立运行的","答案":"ACD","选项C":"线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制","选项B":"线程在执行过程中与进程没有区别的","选项A":"使用线程可以把占据长时间的程序中的任务放到后台去处理","类型":"2-多选"},{"题干":"有关矩阵以下说法正确的是","选项F":"","选项E":"","选项D":"对角线元素均为1，其余元素均为0的矩阵称为单位矩阵","答案":"ACD","选项C":"所有矩阵都有转置矩阵","选项B":"所有矩阵都有逆矩阵","选项A":"当n=m时，矩阵A称为n阶方阵","类型":"2-多选"},{"题干":"解决高方差/过拟合的方法是（）","选项F":"","选项E":"","选项D":"尝试减少正则化程度λ","答案":"ABC","选项C":"尝试增加正则化程度λ","选项B":"尝试减少特征的数量","选项A":"获得更多的训练实例","类型":"2-多选"},{"题干":"解决高偏差/欠拟合的方法是（）","选项F":"","选项E":"","选项D":"尝试减少正则化程度λ","答案":"ACD","选项C":"尝试增加多项式特征","选项B":"尝试增加正则化程度λ","选项A":"尝试获得更多的特征","类型":"2-多选"},{"题干":"文本挖掘的流程主要有","选项F":"","选项E":"","选项D":"主题聚类","答案":"ABCD","选项C":"情感分类","选项B":"去除停用词","选项A":"中文分词","类型":"2-多选"},{"题干":"面向对象的三大特性","选项F":"","选项E":"","选项D":"多态","答案":"ABD","选项C":"重写","选项B":"继承","选项A":"封装","类型":"2-多选"},{"题干":"在python中，关于类的描述正确的是","选项F":"","选项E":"","选项D":"类的抽象可以将类的实现和类的使用分离开来","答案":"ABCD","选项C":"初始化程序以__init__命名","选项B":"对象是类的一个实例","选项A":"类定义了对象的属性，并提供了用于初始化对象的初始化程序和操作这些属性的方法","类型":"2-多选"},{"题干":"在python中，关于元组描述正确的是","选项F":"","选项E":"","选项D":"一个元组是一个字典","答案":"BC","选项C":"由于元组是一个序列，所以序列的切片操作可以用于元组","选项B":"不能对元组中的元素进行添加、删除或替换","选项A":"一个元组是一个列表","类型":"2-多选"},{"题干":"下列说法正确的是","选项F":"","选项E":"","选项D":"类的私有属性不能在类的外部被使用或直接访问","答案":"ABCD","选项C":"python中，子类可以重写父类的方法","选项B":"对象是类的实例","选项A":"类变量在整个实例化的对象中是公用的","类型":"2-多选"},{"题干":"在python中，下列方法对应正确的是","选项F":"","选项E":"","选项D":"@staticmethod标记的方法为静态方法","答案":"ABCD","选项C":"@classmethod标记的方法为类方法","选项B":"__del__:析构函数","选项A":"__init__:构造函数","类型":"2-多选"},{"题干":"大数据：以下关于神经网络模型描述正确的是","选项F":"","选项E":"","选项D":"神经网络模型一定可以解决所有分类问题","答案":"ABC","选项C":"神经网络模型中，无中间层的神经元模型的计算可用来表示逻辑运算","选项B":"神经网络模型建立在多神经元之上","选项A":"神经网络模型是许多逻辑单元按照不同层级组织起来的网络，每一层的输出变量都是下一层的输入变量","类型":"2-多选"},{"题干":"大数据：解决高方差/过拟合的方法是（）","选项F":"","选项E":"","选项D":"尝试减少正则化程度λ","答案":"ABC","选项C":"尝试增加正则化程度λ","选项B":"尝试减少特征的数量","选项A":"获得更多的训练实例","类型":"2-多选"},{"题干":"大数据：解决高偏差/欠拟合的方法是（）","选项F":"","选项E":"","选项D":"尝试减少正则化程度λ","答案":"ACD","选项C":"尝试增加多项式特征","选项B":"尝试增加正则化程度λ","选项A":"尝试获得更多的特征","类型":"2-多选"},{"题干":"Region Server作用是","选项F":"","选项E":"","选项D":"是HBASE的入口","答案":"AB","选项C":"是HBASE集群的主节点","选项B":"负责将Region切分成小Region","选项A":"维护Region，处理IO请求","类型":"2-多选"},{"题干":"下列哪些是zookeeper在HBase中的作用","选项F":"","选项E":"","选项D":"解决了Master的单点故障问题","答案":"ABCD","选项C":"实时监控Region Server的上线和下线信息，并且通知Master","选项B":"存储所有Region的入口","选项A":"保证集群中只有一个Hmaster","类型":"2-多选"},{"题干":"以下关于Region说法正确的是","选项F":"","选项E":"","选项D":"Region的切分是按照大小进行的","答案":"ACD","选项C":"同一行数据在同一个Region","选项B":"一张表只有一个Region","选项A":"Region是HBASE分布式和负载均衡的最小单位","类型":"2-多选"},{"题干":"以下哪些是HBase的特点？","选项F":"","选项E":"","选项D":"有很多丰富的数据类型","答案":"AB","选项C":"是一个关系型数据库","选项B":"数据多版本","选项A":"面向列存储","类型":"2-多选"},{"题干":"HBASE支持的查询方式有","选项F":"","选项E":"","选项D":"各种丰富的查询语句","答案":"ABC","选项C":"全表查询","选项B":"通过rowkey的range查询","选项A":"单个rowkey 查询","类型":"2-多选"},{"题干":"在Linux系统中，卸载软件的为","选项F":"","选项E":"","选项D":"apt-get�purge remove�packagename","答案":"BD","选项C":"apt-get�delete�packagename","选项B":"apt-get�remove�packagename","选项A":"apt-get�delete�packagename","类型":"2-多选"},{"题干":"在深度学习训练中，包含以下步骤；","选项F":"","选项E":"","选项D":"按照梯度dY，确定的更新参数，更新X，继续循环","答案":"ABCD","选项C":"求出反向的梯度dY","选项B":"前向传递，求出loss","选项A":"准备样本集合","类型":"2-多选"},{"题干":"关于LeNet深度神经网络的描述，它的组成部分是","选项F":"","选项E":"","选项D":"全连接层","答案":"ABCD","选项C":"池化层","选项B":"激活函数","选项A":"卷积层","类型":"2-多选"},{"题干":"在tf平台中，能实现卷积运算的函数是：","选项F":"","选项E":"","选项D":"tf.random_normal","答案":"ABC","选项C":"tf.nn.convolution","选项B":"tf.nn.depthwise_conv2d","选项A":"tf.nn.conv2d","类型":"2-多选"},{"题干":"卷积核是个张量，它本身的参数包括有：","选项F":"","选项E":"","选项D":"输出通道","答案":"ABCD","选项C":"输入通道","选项B":"宽度","选项A":"高度","类型":"2-多选"},{"题干":"在tf平台中，能实现两个向量内积运算的语句包括有：","选项F":"","选项E":"","选项D":"tf.norm","答案":"AB","选项C":"tf.reduce_mean","选项B":"tf.multiply","选项A":"tf.reduce_sum","类型":"2-多选"},{"题干":"对于Padding的描述，正确的是","选项F":"","选项E":"","选项D":"图像尺寸变小","答案":"AB","选项C":"步长为1","选项B":"填充厚度是卷积核一半","选项A":"以0填充","类型":"2-多选"},{"题干":"关于多项式次数d与代价函数误差关系,下列说法中描述错误的是（）（其中d代表多项式的次数）","选项F":"","选项E":"","选项D":"对于训练集：当 d 较小时，模型拟合程度更高，误差较大；随着 d 的增长，拟合程度降低，误差增大","答案":"BCD","选项C":"对于训练集：当 d 较小时，模型拟合程度更低，误差较大；随着 d 的增长，拟合程度提高，误差增大","选项B":"对于训练集：当 d 较小时，模型拟合程度更高，误差较大；随着 d 的增长，拟合程度提高，误差减小","选项A":"对于训练集：当 d 较小时，模型拟合程度更低，误差较大；随着 d 的增长，拟合程度提高，误差减小","类型":"2-多选"},{"题干":"下面有关正则化参数lamda，错误的说法有（）","选项F":"","选项E":"","选项D":"正则化可以解决过拟合问题与欠拟合问题","答案":"ACD","选项C":"正则化用来解决欠拟合问题","选项B":"当lamda较小时，训练集误差较小（过拟合）而交叉验证集误差较大","选项A":"当lamda较大时，训练集误差较小（过拟合）而交叉验证集误差较大","类型":"2-多选"},{"题干":"有关过拟合现象产生原因，下列说法错误的是：","选项F":"","选项E":"","选项D":"很好地拟合训练数据","答案":"ABD","选项C":"没有足够的数据集（训练集）去约束变量过多的模型","选项B":"有足够的数据集（训练集）去约束变量过多的模型","选项A":"没有很好地拟合训练数据","类型":"2-多选"},{"题干":"通常，多层神经网络包含：","选项F":"","选项E":"","选项D":"链路层","答案":"ABC","选项C":"输出层","选项B":"输入层","选项A":"隐藏层","类型":"2-多选"},{"题干":"非监督学习可以没有（）","选项F":"","选项E":"","选项D":"标签","答案":"BD","选项C":"真实结果","选项B":"特征","选项A":"输入数据","类型":"2-多选"},{"题干":"关于java多线程，下列关于线程的优先级说法中，正确的是","选项F":"","选项E":"","选项D":"线程的优先级的范围在1-10之间","答案":"BD","选项C":"在创建线程后的任何时候都可以重新设置","选项B":"线程的优先级是在创建线程时设置的","选项A":"线程的优先级是不能改变的","类型":"2-多选"},{"题干":"关于java多线程，有关线程的哪些叙述是对的","选项F":"","选项E":"","选项D":"一个线程可能因为不同的原因停止并进入就绪状态","答案":"BCD","选项C":"当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面","选项B":"使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行","选项A":"一旦一个线程被创建，它就立即开始运行","类型":"2-多选"},{"题干":"关于java多线程，有几种原因可以导致线程不能运行","选项F":"","选项E":"","选项D":"挂起及由于I/O操作而阻塞","答案":"ACD","选项C":"休眠","选项B":"少量内存泄漏","选项A":"等待","类型":"2-多选"},{"题干":"关于java多线程，下列说法正确的包括哪些","选项F":"","选项E":"","选项D":"新建的线程调用start()方法就能立即进入运行状态","答案":"ABC","选项C":"线程操作的数据来自Runnable实例","选项B":"线程从传递给线程的Runnable实例的run方法开始运行","选项A":"一个线程是一个Thread类的实例","类型":"2-多选"},{"题干":"关于java多线程，java线程有几种创建方式","选项F":"","选项E":"","选项D":"使用Callable和Future创建线程","答案":"ACD","选项C":"实现Runnable接口","选项B":"继承Object类","选项A":"继承Thread类","类型":"2-多选"},{"题干":"关于spring与Hibernate整合，HibernateTemplate常用的方法有哪些","选项F":"","选项E":"","选项D":"save","答案":"ABCD","选项C":"delete","选项B":"update","选项A":"find","类型":"2-多选"},{"题干":"在Spring中可以为bean的哪些属性赋值","选项F":"","选项E":"","选项D":"普通属性","答案":"ABCD","选项C":"集合","选项B":"Properties","选项A":"Map","类型":"2-多选"},{"题干":"Spring包装Hibernate之后，能够来保存数据的方法有","选项F":"","选项E":"","选项D":"merge()","答案":"AC","选项C":"saveOrUpdate()","选项B":"load()","选项A":"save()","类型":"2-多选"},{"题干":"关于spring与Hibernate整合，使用Spring简化Hibernate的开发，需要的步骤是","选项F":"","选项E":"","选项D":"在Spring的配置文件中为Dao注入SessionFactory","答案":"ABD","选项C":"Dao接口的实现类提供SessionFactory的set/get方法","选项B":"在Dao接口的实现类继承HibernateDaoSupport","选项A":"在Spring配置文件ApplicationContext.xml创建一个名为SessionFactory的bean类的\n实现是org.Springframework.orm.hibemate3.LoactionFactoryBean","类型":"2-多选"},{"题干":"关于spring与Hibernate整合，对Hibernate的支持用到的Spring的模块中哪些不是主要的模块","选项F":"","选项E":"","选项D":"Spring\u00A0Web模块","答案":"ACD","选项C":"Spring\u00A0MVC模块","选项B":"Spring\u00A0ORM模块","选项A":"Spring\u00A0Context模块","类型":"2-多选"},{"题干":"以下哪种类型不能再MapReduce中充当键值类型传输","选项F":"","选项E":"","选项D":"NullWritable","答案":"AC","选项C":"Null","选项B":"Text","选项A":"String","类型":"2-多选"},{"题干":"以下三元表达式结果为true的是","选项F":"","选项E":"","选项D":"false?true:false","答案":"BC","选项C":"false?false:true","选项B":"true?true:false","选项A":"true?false:true","类型":"2-多选"},{"题干":"在MapReduce程序开中，可以在Map端编写Combiner组件，其作用是？","选项F":"","选项E":"","选项D":"所有的MapReduce中都可以使用","答案":"AB","选项C":"可以替代Reduce","选项B":"可以提高MapReduce运行效率","选项A":"可以节省网络资源","类型":"2-多选"},{"题干":"当我们在集群中使用Yarn作为资源管理的时候存在两个节点分别是ResourceManager和NodeManager,其中NodeManager是","选项F":"","选项E":"","选项D":"单个节点上资源管理和任务管理","答案":"ABCD","选项C":"处理来至\u00A0ApplicationMaster\u00A0的命令","选项B":"处理来至\u00A0ResourceManager\u00A0的命令","选项A":"集群中可以有多个","类型":"2-多选"},{"题干":"当MapReduce运行时，资源管理器会开启一个ApplicationMaster，以下关于ApplicationMaster的描述正确的是","选项F":"","选项E":"","选项D":"容错处理","答案":"ABCD","选项C":"为应用的执行向\u00A0ResourceManager\u00A0申请计算资源","选项B":"分布式计算数据的切片","选项A":"每个应用有一个，\u00A0负责应用程序整个生命周期的管理","类型":"2-多选"},{"题干":"（大数据）电商上  以下属于Field的属性是（）","选项F":"","选项E":"","选项D":"Names","答案":"ABC","选项C":"Stored","选项B":"Indexed","选项A":"Type","类型":"2-多选"},{"题干":"（大数据）电商上  以下对于Solr的功能特点描述正确的是()","选项F":"","选项E":"","选项D":"低度扩展","答案":"ABC","选项C":"相似匹配","选项B":"高度容错","选项A":"全文检索","类型":"2-多选"},{"题干":"（大数据）电商上  Solr查询语法正确的有()","选项F":"","选项E":"","选项D":"支持范围匹配","答案":"ABD","选项C":"不支持通配符查询","选项B":"匹配所有文档","选项A":"支持布尔操作","类型":"2-多选"},{"题干":"（大数据）电商上  Solr后台的重用的3个模板模块是()","选项F":"","选项E":"","选项D":"Document","答案":"ACD","选项C":"Query","选项B":"MutiValued","选项A":"Analysis","类型":"2-多选"},{"题干":"1539775199（大数据）电商上\u00A0\u00A0以下描述正确的有（\u00A0\u00A0）","选项F":"","选项E":"","选项D":"Solr支持全文检索","答案":"ABCD","选项C":"Solr支持rest风格API","选项B":"Solr是apache组织维护的","选项A":"Solr支持持久化","类型":"2-多选"},{"题干":"1535017513974springmvc框架中除了根标签还可以有以下哪些标签","选项F":"","选项E":"","选项D":"mvc:annotation-driven","答案":"ABCD","选项C":"property","选项B":"context:component-scan","选项A":"bean","类型":"2-多选"},{"题干":"1535017389714以下选项中属于事务特性的是","选项F":"","选项E":"","选项D":"原子性","答案":"ABCD","选项C":"隔离性","选项B":"持久性","选项A":"一致性","类型":"2-多选"},{"题干":"1535017432017springmvc框架作为表现层框架，以下描述准确的是","选项F":"","选项E":"","选项D":"不可以单独使用","答案":"ABC","选项C":"可以单独使用","选项B":"优秀的mvc框架，符合mvc的设计理念","选项A":"springmvc被包含在spring当中","类型":"2-多选"},{"题干":"1535017468069在spring框架中包含以下哪些模块","选项F":"","选项E":"","选项D":"orm","答案":"ABCD","选项C":"dao","选项B":"aop","选项A":"core","类型":"2-多选"},{"题干":"在spring框架中的核心模块是","选项F":"","选项E":"","选项D":"dao","答案":"AC","选项C":"aop","选项B":"orm","选项A":"core","类型":"2-多选"},{"题干":"下面算子中哪些是转换算子","选项F":"","选项E":"","选项D":"flatMap","答案":"CD","选项C":"map","选项B":"count","选项A":"cache","类型":"2-多选"},{"题干":"driver的特性的说法，哪些是正确的","选项F":"","选项E":"","选项D":"driver可以回收task运行的结果","答案":"BCD","选项C":"driver可以对task任务的执行情况进行检测","选项B":"driver可以分发task任务","选项A":"driver只有一个创建连接的功能","类型":"2-多选"},{"题干":"以下算子中可以遍历List并能将每个元素都输出的是","选项F":"","选项E":"","选项D":"flatmap","答案":"ACD","选项C":"map","选项B":"count","选项A":"foreach","类型":"2-多选"},{"题干":"在Linux当中，关闭操作系统的指令是","选项F":"","选项E":"","选项D":"shutdown -h","答案":"BD","选项C":"shutdown -r","选项B":"halt","选项A":"reboot","类型":"2-多选"},{"题干":"Linux中重启系统的指令有哪些","选项F":"","选项E":"","选项D":"shutdown -h","答案":"AC","选项C":"shutdown -r","选项B":"halt","选项A":"reboot","类型":"2-多选"},{"题干":"动态代理的用途有","选项F":"","选项E":"","选项D":"分布式","答案":"ABC","选项C":"做事务控制","选项B":"解耦","选项A":"添加调用日志","类型":"2-多选"},{"题干":"JAVA动态代理主要","选项F":"","选项E":"","选项D":"cgLib动态代理","答案":"AD","选项C":"简单代理","选项B":"spring代理","选项A":"jdk动态代理","类型":"2-多选"},{"题干":"实现静态代理需要做哪些事情","选项F":"","选项E":"","选项D":"实现一个拦截器","答案":"BC","选项C":"完成一个代理类","选项B":"完成一个被代理类","选项A":"实现一个过滤器","类型":"2-多选"},{"题干":"实现CGLIB动态代理需要引入的JDK额外包是","选项F":"","选项E":"","选项D":"rt包","答案":"AB","选项C":"spring包","选项B":"cglib包","选项A":"asm包","类型":"2-多选"},{"题干":"关于CGLIB动态代理说法正确的是","选项F":"","选项E":"","选项D":"Cglib是无法代理final修饰的方法的","答案":"BCD","选项C":"Cglib动态代理执行代理方法效率比JDK的高","选项B":"Cglib的动态代理类是继承了被代理对象","选项A":"Cglib的机制是通过java反射机制调用","类型":"2-多选"},{"题干":"在servlet生命周期中，哪些方法只被容器调用一次","选项F":"","选项E":"","选项D":"destroy()","答案":"CD","选项C":"init()","选项B":"getServletConfig()","选项A":"service()","类型":"2-多选"},{"题干":"以下有关JSP和Servlet关系的论述正确的有","选项F":"","选项E":"","选项D":"JSP更适合做控制层","答案":"AB","选项C":"Servlet更适合做表现层","选项B":"Servlet能够实现的功能均可由JSP实现","选项A":"JSP能够实现的功能均可由Servlet实现","类型":"2-多选"},{"题干":"在Servlet里，能实现跳转的方法有哪几种","选项F":"","选项E":"","选项D":"运用ResponseDispatcher接口的forward方法","答案":"BC","选项C":"运用RequestDispatcher接口的forward方法","选项B":"运用HttpServletResponse接口的sendRedirect方法","选项A":"运用HttpServletRequest接口的sendRedirect方法","类型":"2-多选"},{"题干":"在HTTP协议中，哪些方法不能用于发送特别大量的数据","选项F":"","选项E":"","选项D":"delete","答案":"ACD","选项C":"put","选项B":"post","选项A":"get","类型":"2-多选"},{"题干":"关于JSP四大作用域，在最小作用范围和最大作用范围之间（不包括最小、最大）的是哪些？","选项F":"","选项E":"","选项D":"application","答案":"BC","选项C":"session","选项B":"request","选项A":"page","类型":"2-多选"},{"题干":"关于jQuery的描述，以下哪个描述是错误的","选项F":"","选项E":"","选项D":"jQuery的核心功能不是根据选择器查找HTML元素，然后对这些元素执行相关的操作。","答案":"AD","选项C":"jQuery的宗旨是“write\u00A0less,do\u00A0more”","选项B":"jQuery极大地简化了JavaScript编程","选项A":"jQuery是一个java函数库","类型":"2-多选"},{"题干":"下列对jQuery中的ajax描述，错误的包括哪些","选项F":"","选项E":"","选项D":"jQuery对js代码进行的封装方便了前台代码的编写","答案":"AB","选项C":"第三层封装的方法有$.getJSON()，$.getScript()","选项B":"第一层封装的方法有$.get()","选项A":"第二层封装的方法有$.ajax()","类型":"2-多选"},{"题干":"对$.ajax()方法中的属性说法，正确的包括哪些？","选项F":"","选项E":"","选项D":"error：请求失败时调用此函数","答案":"ABD","选项C":"async：默认值false","选项B":"type：请求方式","选项A":"url：请求地址","类型":"2-多选"},{"题干":"Jquery的ajax中，$.post(url,data,success,dataType)方法中的参数，哪些说法是错误的","选项F":"","选项E":"","选项D":"url：请求地址","答案":"BC","选项C":"success：请求成功执行的回调函数，是必填的参数","选项B":"dataType：发送到服务器的数据类型","选项A":"data：发送的服务器的数据","类型":"2-多选"},{"题干":"jquery中ajax，以下哪几种调用方式功能是完全等价的","选项F":"","选项E":"","选项D":"$.ajax({\n  type: 'DELETE',\n  url: '/test.jsp',\n  success:function(result){}\n});","答案":"AC","选项C":"$.ajax({\n  type: 'GET',\n  url: '/test.jsp',\n  success:function(result){}\n});","选项B":"$.ajax({\n  type: 'POST',\n  url: '/test.jsp',\n  success:function(result){}\n});","选项A":"$.get(\"/test.jsp\",function(result){});","类型":"2-多选"},{"题干":"在SpringMVC中下面哪些选项不是springmvc转发或重定向的关键字","选项F":"","选项E":"","选项D":"RedirectAct","答案":"BD","选项C":"redirect","选项B":"Dispatch","选项A":"forward","类型":"2-多选"},{"题干":"SpringMVC的注解@RequestMapping(value={\"/get\",\"/fetch\"}\u00A0)能匹配的URL包括","选项F":"","选项E":"","选项D":"/fet","答案":"AC","选项C":"/fetch","选项B":"/set","选项A":"/get","类型":"2-多选"},{"题干":"在ssm框架使用中关于SpringMVC，Resource注解的说法正确的是（）","选项F":"","选项E":"","选项D":"默认按照名称装配","答案":"BD","选项C":"属于Spring的","选项B":"属于JavaEE的","选项A":"默认按照类型装配","类型":"2-多选"},{"题干":"在ssm框架使用中SpringMVC处理文件上传和下载时需要第三方jar是（）","选项F":"","选项E":"","选项D":"servlet.jar","答案":"AC","选项C":"commons-io.jar","选项B":"log4j.jar","选项A":"commons-fileupload.jar","类型":"2-多选"},{"题干":"在ssm框架使用中关于SpringMVC，核心控制器DispatcherServlet的作用，以下说法正确的包括（）","选项F":"","选项E":"","选项D":"初始化上下文应用对象ApplicationContext","答案":"BCD","选项C":"加载配置文件","选项B":"它负责接收HTTP请求","选项A":"实现业务操作","类型":"2-多选"},{"题干":"在ssm框架使用中SpringMVC框架中，ModelAndView对象描述正确的是（）","选项F":"","选项E":"","选项D":"控制层的方法的返回值可以是ModelAndView","答案":"ABCD","选项C":"称之为模型视图对象","选项B":"可以添加指定的对象，然后再跳转的JSP视图中取到所存放的值","选项A":"可以用来设置去往哪一个页面","类型":"2-多选"},{"题干":"在ssm框架使用中SpringMVC框架中拦截器的实现方式是（）","选项F":"","选项E":"","选项D":"继承InterceptorAdapter类","答案":"AB","选项C":"实现Interceptor接口","选项B":"继承HandleInterceptorAdapter类","选项A":"实现HandleInterceptor接口","类型":"2-多选"},{"题干":"在ssm框架使用中SpringMVC框架中控制器组件包括（）","选项F":"","选项E":"","选项D":"ModelAndView","答案":"ABC","选项C":"处理业务的Controller组件","选项B":"HandlerMapping组件","选项A":"核心控制器DispatcherServlet","类型":"2-多选"},{"题干":"在ssm框架使用中SpringMVC框架提供了丰富的前台参数值获取方案，以下不是获取前台数据的方式是（）","选项F":"","选项E":"","选项D":"RequestMapping","答案":"BD","选项C":"参数","选项B":"ActionForm","选项A":"getParameter","类型":"2-多选"},{"题干":"在ssm框架使用中SpringMVC框架拦截器可以实现的功能有（）","选项F":"","选项E":"","选项D":"日志记录","答案":"ABCD","选项C":"可以解决静态资源被拦截","选项B":"性能监测","选项A":"登录验证","类型":"2-多选"},{"题干":"java的访问控制符的包括以下的哪些？","选项F":"","选项E":"","选项D":"protected","答案":"ACD","选项C":"public","选项B":"static","选项A":"private","类型":"2-多选"},{"题干":"以下属于Java中常见的设计模式的有","选项F":"","选项E":"","选项D":"装饰器模式","答案":"ABCD","选项C":"原型模式","选项B":"代理模式","选项A":"工厂模式","类型":"2-多选"},{"题干":"以下属于代理模式使用场景的有","选项F":"","选项E":"","选项D":"智能引用（Smart Reference）代理","答案":"ABCD","选项C":"Cache代理","选项B":"虚拟代理","选项A":"远程代理","类型":"2-多选"},{"题干":"以下属于代理模式应用的优点有","选项F":"","选项E":"","选项D":"扩展性低","答案":"ABC","选项C":"智能化","选项B":"高扩展性","选项A":"职责清晰","类型":"2-多选"},{"题干":"以下场景可以理解为代理模式的有","选项F":"","选项E":"","选项D":"spring aop","答案":"ABCD","选项C":"买火车票不一定在火车站买，也可以去代售点","选项B":"猪八戒去找高翠兰结果是孙悟空变的","选项A":"Windows 里面的快捷方式","类型":"2-多选"},{"题干":"以下属于动态代理的常见api的有","选项F":"","选项E":"","选项D":"MethodInterceptor","答案":"ABCD","选项C":"Method","选项B":"InvocationHandler","选项A":"Proxy","类型":"2-多选"},{"题干":"facet查询就是group查询","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Facet 是 solr 的高级搜索功能之一 , 在搜索关键字的同时 , 能够按照Facet 的字段进行分组并统计 。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"适宜被Facet 的字段,一般代表了实体的某种公共属性 , 如商品的分类 , 商品的制造厂家 , 书籍的出版商等等","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Facet 的字段必须被索引 . 一般来说该字段无需分词 , 无需存储 .","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"进行\u00A0Facet\u00A0查询需要在请求参数中加入\u00A0facet=true”Facet\u00A0组件才不起作用\u00A0.","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"springmvc拦截器中的afterCompletion方法类似于aop中的后置通知","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"springmvc自定义拦截器可以实现的接口是HandlerInterceptor","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"mybatis的动态sql技术可以为代码的改良奠定一定的基础","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"springdata由于底层的核心是jpa，所以只支持hql语句","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"springdata可以完全替代spring","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"原生ajax的status表示页面状态","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"对于原生ajax，核心对象是XMLHttpRequest","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"原生ajax的核心对象是XMLHttpResponse","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"jQuery封装的ajax中$.ajax()中的参数不可更改位置","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"jQuery对js的ajax进行了三层封装,其中一层封装的方法有$.post(),$.get和obj.load()","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"多线程没有安全问题","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"关于多线程，当一个线程进入一个对象的一个synchronized方法后，其它线程不可以再进入该对象同步的其它方法执行。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"一个进程中只能包含一个线程","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"关于java多线程，A线程的优先级是10，B线程的优先级是1，那么当进行调度时一定会先调用A","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"stop()方法是终止当前线程的一种方法","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Solr是一个全文检索框架","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Solr支持模式配置、无模式配置","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Solr支持查询结果高亮显示，这种说法正确么","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Solr的索引库不支持添加索引","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Solr的索引库支持修改索引","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"SSH整合时为了防止Session提前关闭而导致延迟加载失败只能放弃Hibernate的延迟加载策略，而改变为立即加载。","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Hibernate中实现双向多对一关联配置后，在对关联对象生成JSON数据时不会产生任何不利的影响，也无需对重复引用问题进行处理。","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Spring与Hibernate整合过程中事务的控制可以采用声明式的事务管理配置文件方式配置或者在service层使用注解@Transactional","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"事务的传播特性确定了业务方式使用事务的方式。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"在Spring与Hibernate整合后DAO实现类可以继承HiberanteDaoSupport类，并允许注入HibernateTemplate或者SessionFactory。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"（大数据）关于Dubbo，当一个接口有多种实现时，可以用group区分","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"（大数据）Socket是传输层供给应用层的编程接口，是应用层与传输层之间的桥梁","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"（大数据）关于Dubbo，Cluster属于Dubbo提供的容错方案","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"（大数据）关于Dubbo，Redis能作为dubbo的注册中心","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"（大数据）TCP/IP传输控制协议是Internet的主要协议，定义了计算机和外设进行通信的规则。TCP/IP网络参考模型包括七个层次：应用层、会话层、表示层、传输层、网络层、链路层和物理层","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"电商下-Redis能作为dubbo的注册中心（\u00A0\u00A0）","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"电商下-Socket是传输层供给应用层的编程接口，是应用层与传输层之间的桥梁（\u00A0\u00A0）","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"电商下-Cluster属于Dubbo\u00A0提供的容错方案（\u00A0\u00A0）","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"实现接口的类不能是抽象类。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"一个类可以实现多个接口，接口可以实现“多重继承”。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Java语言中，构造方法是可以继承的。","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"request这个对象是可以获取客户端IP地址的.","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Servlet生命周期结束执行销毁的方法是destroy()，对么？","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"1535332399113Servlet生命周期的Service()方法能被多次调用;","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"请求转发是客户端跳转，响应重定向是服务器跳转;","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Servlet接口中在客户端发送请求时候调用init()方法;","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"cd不是更改当前工作目录命令","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"在终端执行sudo -s，然后输入当前登录的普通用户密码，进入到root用户模式。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"设A和B是任两个n*m的矩阵，则B+A=A+B","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"两个n乘m矩阵的和是一个m乘n矩阵","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"threading 模块提供了Thread,Lock,Rlock,Ccondition,Event,Timer和Semaphore等大量类来支持多线程编程。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"threading 模块中threading.current_thread()方法是返回当前Thread对象","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"所有回归和分类一定都是无监督学习问题","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"数据挖掘中的预测器可以看作一个映射或函数y=f(X)","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"数据挖掘任务主要是分类、聚类、回归、推荐","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"后向传播是一种神经网络学习算法","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"支持向量机不可以用来回归预测","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"常用的聚类方法主要有：快速聚类、层次聚类、两步聚类。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"损失函数有两个表达方式，均方差表达，和信息熵表达。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"SOFTMAX函数，是用来将全数域函数结果映射到概率空间。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"sigmoid函数也能将全数域函数，映射到概率空间。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"事件的信息量，与事件发生的概率无关。","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"分类问题用逻辑回归，预测问题用线性回归。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"信息量就是信息熵。","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"在linux系统中，cd不是更改当前工作目录命令","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"在linux系统中，在终端执行sudo -s，然后输入当前登录的普通用户密码，进入到root用户模式。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"设A和B是任两个n*m的矩阵，那么B+A=A+B","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Python支持单继承同时也支持多继承","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"两个n乘m矩阵的和等于一个m乘n矩阵","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"通常选择较大的神经网络并采用正则化处理，会比采用较小的神经网络效果要好","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"通常神经网络模型的层数越多，隐藏层神经元个数越多，模型效果越好","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"中文分词和英文分词的主要区别是中文词语之间没有空格，英文直接可以用空格分词","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"在Python中，__init__方法是内置的初始化函数。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Python列表中所有元素必须为相同类型的数据。","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Python字典中的“键”可以是元组","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"在Python中，执行下列语句后t= (1,2,3) ，print(type(t))的显示结果是<class 'list'>","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Python集合可以包含相同的元素。","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"大数据：神经网络中的基本成分是神经元模型","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"大数据：通常选择较大的神经网络并采用正则化处理，会比采用较小的神经网络效果要好","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"大数据：通常神经网络模型的层数越多，隐藏层神经元个数越多，模型效果越好","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"HBASE可以完全替代传统的关系型数据库","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"HBASE是一个列式数据库","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"hbase是一个关系型数据库","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Hadoop1.0和2.0都具备完善的HDFS HA。","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"HBase是建立在Hadoop文件系统之上的分布式面向列的数据库","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"在linux中，cd不是更改当前工作目录命令","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"在linux中，在终端执行sudo -s，然后输入当前登录的普通用户密码，进入到root用户模式。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"张量维度或形状，是用一个向量描述。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"张量的数轴数，就是描述它形状的那个向量的维数。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"relu 是一个激活函数","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"relu函数只能在全连接层的神经网络里面有意义，在卷积层没有意义","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"在卷积层神经网络中，可以利用多个不同的卷积核进行卷积操作","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"卷积神经网络中，其中，卷积层是分类的，全连接层是特征提取的。","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"神经元模型是组成神经网络中的基本结构","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"神经网络模型可以看作是许多逻辑回归模型的叠加而成","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"只有线性回归问题有可能发生过拟合","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"通常采用较小的神经网络比选择较大的神经网络效果要好","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"神经网络模型不会产生过拟合现象","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"关于java多线程，线程优先级可以用从1到10的范围指定。10表示最高优先级，1表示最低优先级，5是普通优先级。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"关于java多线程，进程是线程Thread内部的一个执行单元，它是程序中一个单一顺序控制流程。","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"关于java多线程，如果线程死亡，它便不能运行","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"关于java多线程，一个进程可以包括多个线程。两者的一个主要区别是：线程是资源分配的单位，而进程是CPU调度和执行的单位。","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"关于java多线程，用new关键字建立一个线程对象后，该线程对象就处于新生状态。处于新生状态的线程有自己的内存空间，通过调用start进入就绪状态。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"关于spring与Hibernate整合，HibernateTemplate是Hibernate\u00A0Session的轻量级封装","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Spring AOP中注解@Transactional的属性中包括rollback","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"关于spring与Hibernate整合，HibernateDaoSupport继承了HibernateTemplate类","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"关于spring与Hibernate整合，在Spring集成Hibernate必须使用HibernateDaoSupport类","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"关于spring与Hibernate整合，HibernateTemplate不支持setFirstResult方法","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Hadoop分布式计算框架MapReduce的特点是移动计算而非移动数据","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"MapReduce框架中，shuffle阶段是最重要的阶段，是MapReduce框架的核心内容","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Hadoop不支持数据随机读写，适合一次写入多次读取的场景","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"hdfs中NameNode负责管理metadata（数据的元数据信息）","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Hadoop每个版本都具备完善的\u00A0HA策略。","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"（大数据）电商上  Solr下fields节点中required的作用是是否必填","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"（大数据）电商上  Solr的索引库不支持修改索引","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"（大数据）电商上  Solr是关系型数据库","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"（大数据）电商上  Solr下fields节点中name的作用是定义的类型","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"（大数据）电商上  Solr支持对查询结果的高亮显示","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"1535017601165springmvc框架中拦截器的afterCompletion方法类似于aop中的后置通知","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"1535017649453在springmvc框架中自定义拦截器可以实现的接口是HandlerInterceptor","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"1535017711033在Mybatis框架中动态sql技术可以为代码的改良奠定一定的基础","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"1535017583203springdata模块由于底层的核心是jpa，所以只支持hql语句","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"1535017565928springdata模块可以完全替代spring","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"sparkSql可以访问hive数据，并将其结果取回作为RDD使用","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"sparkSql不能够连接jdbc","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"sparkSql仅仅支持查询原生的RDD，其他方式的查询都不支持","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"spark程序无法连接和访问mysql中的数据","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"dataFrame和RDD类似，也是一个分布式数据容器","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"JDK动态代理必须要有接口","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"CGLIB动态代理必须有接口","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"静态代理需要有接口","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"CGLIB动态代理不需要引入jdk额外的包","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"动态代理是对于静态代理的继承","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"客户端的请求参数都被封装在Jsp隐含变量对象request对象里","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Servlet生命周期结束时，可调用多次destroy()方法","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"servlet请求转发时，url也会发生变化","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"HTTP缺省的请求方法是POST","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"servlet的init方法是在Servlet实例化之后执行的，并且只执行一次。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"jQuery.ajax的Async()方法用于执行异步HTTP请求","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"jQuery是一个javascript库","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"jQuery.getJSON()中的data参数是必须的","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"jQuery.get()可以用等价的方法$.ajax(）代替","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"jQuery.post()方法必须使用url参数","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"web.xml中配置servlet需要配置servlet-mapping标签","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"对于ssm使用的SpringMVC，spring与springmvc是两个独立的软件，没有任何联系","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"在ssm框架中SpringMVC能够支持处理REST风格的URL请求","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"在使用SpringMVC时候应用表现层（控制器）的注解除了用Controller，某些情况下还可以用别的注解代替","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"SpringMVC是apache的开发的产品","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"在ssm中使用的SpringMVC是一个模型-视图-控制器（MVC）的Web框架","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"SpringMVC中，拦截器能否获取IOC容器中的各个bean","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"1537939692890配置SpringMVC拦截器，哪个不是springmvc配置文件中用到的标签","选项F":"","选项E":"","选项D":"","答案":"","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"在ssm框架使用关于SpringMVC，Controller类默认Scope是单例（singleton）的。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"在ssm框架使用关于SpringMVC，SpringMVC把所有的Controller请求都提交给DispatcherServlet，它会委托应用系","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"在ssm框架使用关于SpringMVC，SpringMVC把所有的Controller请求都提交给DispatcherServlet，它会委托应用系统的HandlerMapping模块负责负责对请求交给特定的Controller进行真正的处理工作。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"在ssm框架使用关于SpringMVC，SpringMVC通过一套MVC注解，让POJO成为处理请求的控制器，而无须实现任何接口。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"在ssm框架使用关于SpringMVC，SpingMVC中的控制器的注解可以使用Controller。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"在ssm框架使用中SpringMVC中控制器的组件包括前端控制器DispatcherServlet、HandlerMapping和Controller。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"在ssm框架使用中关于SpringMVC，Springmvc属于spring框架的一部分。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"在ssm框架使用中关于SpringMVC，SpringMVC采用了松散耦合可插拔组件结构，比其他MVC框架更具扩展性和灵活性。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"在ssm框架使用中除了SpringMVC，还可以用其它方式实现文件上传下载功能。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"在ssm框架使用中SpringMVC中的Controller默认Scope不是单例（singleton）的。","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"String temp = new String(\"abc\");创建了2个实例对象","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Math.ceil(-5.2)返回的结果是-5","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"代理模式只含有动态代理和静态代理模式两种","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"动态代理模式是基于类实现的","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Cglib代理模式是基于接口实现的","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"}]