[{"题干":"<? extends T>与<? super T>都是规范数据类型的范围的，那么，extends与super关键字，可以连用吗？同时指定上下限？","选项F":"","选项E":"","选项D":"可以","答案":"A","选项C":"有的人写可以","选项B":"有时候可以","选项A":"不可以","类型":"1-单选"},{"题干":"下列选项中,反射常用方法getName()的功能是","选项F":"","选项E":"","选项D":"返回此Class对象所表示的实体的全限定名称","答案":"D","选项C":"返回此Class对象所表示的实体的所有公共方法","选项B":"返回此Class对象所表示的实体的所有公共字段","选项A":"返回此Class对象所表示的实体的简称","类型":"1-单选"},{"题干":"下列选项中,正则表达式中能匹配正则xx或者yy的是","选项F":"","选项E":"","选项D":"Pattern p = Pattern.compile(\"xx\\\\|YY\");","答案":"A","选项C":"Pattern p = Pattern.compile(\"\\xxyy*\");","选项B":"Pattern p = Pattern.compile(\"xx\\|yy\");","选项A":"Pattern p = Pattern.compile(\"xx|yy\");","类型":"1-单选"},{"题干":"java反射，不可以获取类类型的是","选项F":"","选项E":"","选项D":"Class c1=new Class(\"entity.Car\");","答案":"D","选项C":"Class c1= new Car.getClass();","选项B":"Class c1= Car.class;","选项A":"Class c1= Class.forName(\"entity.Car\");","类型":"1-单选"},{"题干":"下列选项中,可以通过反射获取本类所有属性，正确的是","选项F":"","选项E":"","选项D":"getDeclaredMethod()","答案":"C","选项C":"getDeclaredFields()","选项B":"getFields()","选项A":"getMethods()","类型":"1-单选"},{"题干":"2018/03/05我们在MySQL中用什么数据类型表示","选项F":"","选项E":"","选项D":"double","答案":"B","选项C":"varchar2","选项B":"date","选项A":"int","类型":"1-单选"},{"题干":"下列选项中，可以通过反射创建对象正确的是","选项F":"","选项E":"","选项D":"Class person = Person.class.forName(\"Person\");","答案":"A","选项C":"Class clazz = Person.class.newInstance();","选项B":"Person person = Person.class.getClass();","选项A":"Person person = Person.class.newInstance();","类型":"1-单选"},{"题干":"下列选项中能编译通过的Java代码是","选项F":"","选项E":"","选项D":"List<? extends Integer> x34 = new ArrayList<Number>();","答案":"C","选项C":"List<? extends Number> x313 = new ArrayList<Integer>();","选项B":"List<? extends Number> x312 = new ArrayList<String>();","选项A":"List<? extends String> x31 = new ArrayList<Integer>();","类型":"1-单选"},{"题干":"可以通过java反射获取方法的是","选项F":"","选项E":"","选项D":"newInstance();","答案":"C","选项C":"getDeclaredMethods()","选项B":"getDeclaredFields()","选项A":"getConstructors()","类型":"1-单选"},{"题干":"Java面向对象中，继承使用的关键字是","选项F":"","选项E":"","选项D":"extends","答案":"D","选项C":"super","选项B":"excute","选项A":"implements","类型":"1-单选"},{"题干":"java中，哪个表达式可用得到x和y的最大值","选项F":"","选项E":"","选项D":"x==y?y:x","答案":"B","选项C":"x>y?(x+y):(x-y)","选项B":"x<y?y:x","选项A":"x>y?y:x","类型":"1-单选"},{"题干":"java反射中，getDeclaredField需要几个参数","选项F":"","选项E":"","选项D":"3个","答案":"C","选项C":"1个","选项B":"0个","选项A":"2个","类型":"1-单选"},{"题干":"java中，定义一个类，必须使用的关键字是","选项F":"","选项E":"","选项D":"static","答案":"B","选项C":"interface","选项B":"class","选项A":"public","类型":"1-单选"},{"题干":"java反射中，通过反射获取方法，错误的是哪个","选项F":"","选项E":"","选项D":"c1.getDeclaredMethods();","答案":"C","选项C":"c1.getDeclaredMethods(\"name\");","选项B":"c1.getMethod(\"name\",Person.class);","选项A":"c1.getMethods();","类型":"1-单选"},{"题干":"java中，定义一个接口必须使用的关键字是","选项F":"","选项E":"","选项D":"static","答案":"C","选项C":"interface","选项B":"class","选项A":"public","类型":"1-单选"},{"题干":"java反射中，以下哪种类可以获取和设置类的方法","选项F":"","选项E":"","选项D":"Constructor类","答案":"C","选项C":"Method类","选项B":"Field类","选项A":"Class类","类型":"1-单选"},{"题干":"java反射中，getFields的返回类型是什么","选项F":"","选项E":"","选项D":"Map","答案":"B","选项C":"Set","选项B":"Array","选项A":"List","类型":"1-单选"},{"题干":"java中，构造函数何时被调用","选项F":"","选项E":"","选项D":"使用对象的属性时","答案":"A","选项C":"使用对象的方法时","选项B":"类定义时","选项A":"创建对象时","类型":"1-单选"},{"题干":"java反射中，与泛型的关系，哪个说法是正确的","选项F":"","选项E":"","选项D":"反射查不到泛型的所有参数","答案":"C","选项C":"通过反射可以获取泛型的类型","选项B":"通过反射无法获取泛型的类型","选项A":"类型参数化是反射的本质","类型":"1-单选"},{"题干":"java中，抽象方法","选项F":"","选项E":"","选项D":"抽象类中的方法都是抽象方法","答案":"C","选项C":"是没有方法体的方法","选项B":"可以出现在非抽象类中","选项A":"可以有方法体","类型":"1-单选"},{"题干":"下列选项中，通过反射技术，打破封装的方法错误的是","选项F":"","选项E":"","选项D":"setAccessible(true);","答案":"ABC","选项C":"setAccessible(\"false\");","选项B":"setAccessible(false);","选项A":"setAccessible(\"true\");","类型":"2-多选"},{"题干":"下列选项中，属于Java 支持正则的类的是","选项F":"","选项E":"","选项D":"Regular","答案":"AC","选项C":"Matcher","选项B":"ObjectOutputStream","选项A":"Pattern","类型":"2-多选"},{"题干":"下列选项中，Java代码写法错误的是","选项F":"","选项E":"","选项D":"List<String> list = new ArrayList<String>();","答案":"AB","选项C":"List<String> list = new LinkedList<String>();","选项B":"List<String> list = new ArrayList<Integer>();","选项A":"List<String> list = new List<String>();","类型":"2-多选"},{"题干":"1530601522下列选项中，那些是反射常用的方法","选项F":"","选项E":"","选项D":"getDeclaredFields()","答案":"ABCD","选项C":"getInterfaces();","选项B":"getSimpleName();","选项A":"getSuperClass();","类型":"2-多选"},{"题干":"1533518682491下列选项中，通过反射，获取构造，正确的是","选项F":"","选项E":"","选项D":"c1.getConstructor(Person.getClass);","答案":"AC","选项C":"c1.getConstructor(Person.class);","选项B":"c1.getConstructor(\"aa\");","选项A":"c1.getConstructors();","类型":"2-多选"},{"题干":"下列选项中，那些是反射常用的方法","选项F":"","选项E":"","选项D":"getDeclaredFields();","答案":"ABCD","选项C":"getInterfaces();","选项B":"getSimpleName();","选项A":"getSuperclass();","类型":"2-多选"},{"题干":"java反射中，有哪些优点","选项F":"","选项E":"","选项D":"实现软件工程理论里所提及的类与类，模块与模块之间的解耦","答案":"BCD","选项C":"更加容易实现面向对象","选项B":"可以实现动态创建对象和编译，体现出很大的灵活性","选项A":"提高了性能","类型":"2-多选"},{"题干":"java反射中，通过反射机制可以获得任意一个类的哪些信息","选项F":"","选项E":"","选项D":"包","答案":"ABCD","选项C":"构造方法","选项B":"方法","选项A":"成员变量","类型":"2-多选"},{"题干":"java反射中，Class对象的哪些方法只可以获得类的名称","选项F":"","选项E":"","选项D":"getSimpleName()","答案":"ABD","选项C":"forName()","选项B":"getClassName()","选项A":"getName()","类型":"2-多选"},{"题干":"java反射中，Class对象的哪些方法返回值是数组类型","选项F":"","选项E":"","选项D":"getDeclaredConstructors()","答案":"BD","选项C":"getConstructor();","选项B":"getDeclaredMethods()","选项A":"getMethod();","类型":"2-多选"},{"题干":"java反射中，Java的反射机制的实现不需要借助的类包括","选项F":"","选项E":"","选项D":"Object","答案":"CD","选项C":"String","选项B":"Constructor","选项A":"Class","类型":"2-多选"},{"题干":"java中，下面哪些选项属于构造方法的作用","选项F":"","选项E":"","选项D":"初始化属性值","答案":"BCD","选项C":"开辟内存空间","选项B":"创建实例","选项A":"声明对象","类型":"2-多选"},{"题干":"Java中，正则表达式中+代表可以出现0次获取多次","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"关于Java的反射中，Class对象的getDeclaredFields()方法只可以获得类中的所有public级别的属性，包括继承过来的所有属性。","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"正则表达式中\\\\W匹配是非字母、数字、下划线","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"如果想知道类都实现了哪些接口，使用Java反射调用的方法是getInterfaces();","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Java泛型的好处是在运行期间的时候检查类型安全问题","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"java反射中，反射可以增加程序的灵活性","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"java反射中，getDeclaredFields()返回类型为是List","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"java反射中，通过反射能越过泛型检查","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"java反射中，反射必须先得到代表的字节码的Class","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"java反射中，暴力反射可以获取类中私有的属性和方法","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"}]