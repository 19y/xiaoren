[{"题干":"反射中，使用对象名.getDeclaredFields()返回类型是","选项F":"","选项E":"","选项D":"Queue","答案":"C","选项C":"Array","选项B":"Map","选项A":"List","类型":"1-单选"},{"题干":"下列选项中，不可以获取类类型的是","选项F":"","选项E":"","选项D":"Class c3 = new Person().getClass();","答案":"C","选项C":"Class c4 = new Class(\"entity.Person\");","选项B":"Class c2 = Class.forName(\"entity.Person\");","选项A":"Class c1 = Person.class","类型":"1-单选"},{"题干":"通过反射，获取父类以及本类所有公共的属性，不包括本类中的私有属性的方法是","选项F":"","选项E":"","选项D":"c1.getDeclaredFields() ;","答案":"C","选项C":"c1.getFields() ;","选项B":"c1.getMethods();","选项A":"c1.getDeclaredMethods();","类型":"1-单选"},{"题干":"通过反射，能够获取本类所有属性，包括私有属性的方法是","选项F":"","选项E":"","选项D":"c1.getDeclaredFields() ;","答案":"D","选项C":"c1.getFields();","选项B":"c1.getMethods();","选项A":"c1.getDeclaredMethods();","类型":"1-单选"},{"题干":"通过反射，能够获取本类中声明的所有方法，包括私有方法的方法是","选项F":"","选项E":"","选项D":"c1.getDeclaredFields();","答案":"A","选项C":"c1.getFields();","选项B":"c1.getMethods();","选项A":"c1.getDeclaredMethods();","类型":"1-单选"},{"题干":"已知Car类，创建此 Class 对象所表示的类的一个新的实例，下面能够正确创建的是( )","选项F":"","选项E":"","选项D":"Car.class.newInstance()","答案":"D","选项C":"Car.getClass.newInstance()","选项B":"class.forName(\"Car.getClass\")","选项A":"Car.getClass().newInstance()","类型":"1-单选"},{"题干":"Java反射中，可以获取访问修饰符的方法是","选项F":"","选项E":"","选项D":"getModify()","答案":"A","选项C":"getModel()","选项B":"getMethods()","选项A":"getModifiers()","类型":"1-单选"},{"题干":"通过反射技术，能够打破封装的方法是（）","选项F":"","选项E":"","选项D":"setAccessible(\"false\");","答案":"A","选项C":"setAccessible(\"true\");","选项B":"setAccessible(false);","选项A":"setAccessible(true);","类型":"1-单选"},{"题干":"关于getDeclaredConstructors(),以下说法正确的是","选项F":"","选项E":"","选项D":"返回此Class对象所表示的实体的所有公共字段","答案":"A","选项C":"返回此Class对象所表示的实体的公共方法","选项B":"返回此Class对象表示的类声明的公共构造方法","选项A":"返回此Class对象表示的类声明的所有构造方法","类型":"1-单选"},{"题干":"通过反射，可以获取实现接口的方法是","选项F":"","选项E":"","选项D":"getInstanceof();","答案":"B","选项C":"getInterfaca();","选项B":"getInterfaces();","选项A":"getInstance();","类型":"1-单选"},{"题干":"java的反射，利用反射获得所有公共构造方法，不包括私有构造","选项F":"","选项E":"","选项D":"c1.getDeclaredFields();","答案":"B","选项C":"c1.getFields();","选项B":"c1.getConstructors();","选项A":"c1.getDeclaredConstructors();","类型":"1-单选"},{"题干":"java语言间的继承关系是","选项F":"","选项E":"","选项D":"不能继承","答案":"B","选项C":"线程的","选项B":"单重的","选项A":"多重的","类型":"1-单选"},{"题干":"java反射，\n   Class<?> ca1 = String.class;\n   Class<?> ca2 = new String().getClass();\n   Class<?> ca3 = Class.forName(\"java.lang.String\");   \n   System.out.println(ca1==ca2);\n   System.out.println(ca2==ca3);\n   System.out.println(ca1==ca3);\n运行结果是","选项F":"","选项E":"","选项D":"true\ntrue","答案":"C","选项C":"true\ntrue\ntrue","选项B":"运行报异常","选项A":"false\ntrue\ntrue","类型":"1-单选"},{"题干":"java中，int x=1;float y=2;表达式x/y的值是","选项F":"","选项E":"","选项D":"0.5","答案":"D","选项C":"2","选项B":"1","选项A":"0","类型":"1-单选"},{"题干":"java的反射，利用反射获取方法，包括从父类继承来的方法，不包括本类中的私有方法","选项F":"","选项E":"","选项D":"c1.getDeclaredFields();","答案":"B","选项C":"c1.getFields();","选项B":"c1.getMethods();","选项A":"c1.getDeclaredMethods();","类型":"1-单选"},{"题干":"java中，在使用interface声明一个接口时，只可以使用（）修饰符修饰该接口","选项F":"","选项E":"","选项D":"public","答案":"D","选项C":"default","选项B":"protected","选项A":"private","类型":"1-单选"},{"题干":"java的反射，利用反射获取构造，包括本类的所有构造，包括私有构造","选项F":"","选项E":"","选项D":"c1.getDeclaredFields();","答案":"A","选项C":"c1.getFields();","选项B":"c1.getConstructors();","选项A":"c1.getDeclaredConstructors();","类型":"1-单选"},{"题干":"java中，以下语句有语法错误的是","选项F":"","选项E":"","选项D":"for(;;);","答案":"A","选项C":"while(a>4);","选项B":"for(int a=10,b=0;a>0;a++);","选项A":"int a=1;b=2;c=3;","类型":"1-单选"},{"题干":"java的反射，下列关于通过反射方式获取方法并执行的过程说法正确的是","选项F":"","选项E":"","选项D":"通过invoke(对象名,参数列表)方法来执行一个方法","答案":"D","选项C":"通过Class.getDeclaredMethod(方法名，参数类型列表)获取私有方法","选项B":"通过Class.getMethod(方法名，参数类型列表)的方式获取该方法","选项A":"通过对象名.方法名(参数列表)的方式调用该方法","类型":"1-单选"},{"题干":"java中，以下哪个不是java语言关键字","选项F":"","选项E":"","选项D":"while","答案":"B","选项C":"instanceof","选项B":"sizeof","选项A":"int","类型":"1-单选"},{"题干":"下列选项中关于JAVA反射机制提供了什么功能说法正确的有","选项F":"","选项E":"","选项D":"在运行时获取类的子类","答案":"ABC","选项C":"运行时构造任意一个类的对象","选项B":"运行时判断任意一个类所具有的成员变量和方法","选项A":"运行时调用任意一个对象的方法","类型":"2-多选"},{"题干":"下列选项中可以通过反射,获取方法，正确的有","选项F":"","选项E":"","选项D":"c1.getDeclaredMethods(“fddf”);","答案":"ABC","选项C":"c1.getDeclaredMethods();","选项B":"c1.getMethod(\"name\",Person.class);","选项A":"c1.getMethods();","类型":"2-多选"},{"题干":"下列选项中能够通过反射获取类类型，正确的有","选项F":"","选项E":"","选项D":"Class c3 = new Person().getClass();","答案":"ABD","选项C":"Class c4 = new Class(\"entity.Person\");","选项B":"Class c2 = Class.forName(\"entity.Person\");","选项A":"Class c1 = Person.class;","类型":"2-多选"},{"题干":"下列选项中能够通过反射获取构造，正确的有","选项F":"","选项E":"","选项D":"c1.getConstructor(Person.getClass);","答案":"AC","选项C":"c1.getConstructor(Person.class);","选项B":"c1.getConstructor(\"aa\");","选项A":"c1.getConstructors();","类型":"2-多选"},{"题干":"下列选项中，能够通过反射获取方法正确的有哪些","选项F":"","选项E":"","选项D":"new�Object().getClass().getDeclaredMethods()�;","答案":"ABCD","选项C":"new�Object().getClass().getMethods();","选项B":"Object.class.getMethods();","选项A":"Object.class.getDeclaredMethods()�;","类型":"2-多选"},{"题干":"java中下面哪些关键字能用来控制对类成员的访问","选项F":"","选项E":"","选项D":"default","答案":"ABC","选项C":"private","选项B":"protected","选项A":"public","类型":"2-多选"},{"题干":"java语言的特点包括哪些","选项F":"","选项E":"","选项D":"跨平台性","答案":"BD","选项C":"分布式","选项B":"面向对象","选项A":"面向过程","类型":"2-多选"},{"题干":"java语言中，合法的运算符有包括","选项F":"","选项E":"","选项D":"!=","答案":"AD","选项C":"<>","选项B":"===","选项A":"&&","类型":"2-多选"},{"题干":"java中，作为switch语句后面的控制表达式，可用的数据类型包括哪些","选项F":"","选项E":"","选项D":"float","答案":"ABC","选项C":"byte","选项B":"char","选项A":"int","类型":"2-多选"},{"题干":"java中，当子类重写从父类中继承来的方法时，必须相同的部分有哪些","选项F":"","选项E":"","选项D":"方法的返回值类型","答案":"AC","选项C":"形参列表","选项B":"访问修饰符","选项A":"方法名称","类型":"2-多选"},{"题干":"Java反射中，通过Class对象的getSimpleName（）方法可以获得类的全限定名。","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Java反射中，通过Class对象的getFields()方法只可以获得类中的所有public级别的属性，包括继承过来的公有属性。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Java反射中，通过Class对象的getSuperclass()方法可以获取父类。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Java反射中，通过Class对象的getDeclaredFields()方法是可以获得类中所有的属性，包括私有属性。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Java反射中，通过Class对象的newInstance()方法可以获取类实例。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"java的反射不影响系统性能","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"java中，一个java类可以实现多个接口，接口可以实现“多重继承”。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"java的反射，Class对象的getConstructors方法只可以获得类的所有public级别的构造器","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"java的反射，反射机制指的是在程序编译期间，通过.class文件加载并使用一个类的过程","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"java的反射，可以通过invoke方法调用类的某个方法","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"}]