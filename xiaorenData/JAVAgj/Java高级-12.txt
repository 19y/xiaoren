[{"题干":"下列选项中，可以使用哪个方法改变线程的优先级","选项F":"","选项E":"","选项D":"yield","答案":"C","选项C":"setPriority","选项B":"sleep","选项A":"run","类型":"1-单选"},{"题干":"下列选项中，那个方法可以启动线程","选项F":"","选项E":"","选项D":"wait","答案":"B","选项C":"sleep","选项B":"start","选项A":"run","类型":"1-单选"},{"题干":"Java多线程中可以通过_方法进行休眠一段时间，然后恢复运行","选项F":"","选项E":"","选项D":"setPriority","答案":"C","选项C":"sleep","选项B":"yield","选项A":"run","类型":"1-单选"},{"题干":"那个方法是实现Runnable接口所需的？","选项F":"","选项E":"","选项D":"update()","答案":"B","选项C":"stop()","选项B":"run()","选项A":"wait()","类型":"1-单选"},{"题干":"关于多线程，在多个线程访问同一个资源时，可以使用（）关键字来实现线程同步，保证对资源安全访问。","选项F":"","选项E":"","选项D":"Yield","答案":"A","选项C":"Serializable","选项B":"Transient","选项A":"Synchronized","类型":"1-单选"},{"题干":"关于多线程，Thread.sleep()方法调用后，当等待时间未到，该线程所处状态为（）状态。当等待时间已到，该线程所处状态为运行状态。","选项F":"","选项E":"","选项D":"死亡(DEAD)","答案":"C","选项C":"阻塞(BLOCKED)","选项B":"运行(RUNNING)","选项A":"可运行","类型":"1-单选"},{"题干":"关于多线程，notify是唤醒所在对象wait pool中的哪个线程","选项F":"","选项E":"","选项D":"运行时间最长的","答案":"C","选项C":"随机","选项B":"第一个","选项A":"线程优先级最高的","类型":"1-单选"},{"题干":"关于多线程，关于sleep()和wait()，以下描述错误的一项是","选项F":"","选项E":"","选项D":"wait后进入等待锁定池，只有针对此对象发出notify方法后获得对象锁进入运行状态","答案":"D","选项C":"sleep暂停线程、但监控状态仍然保持，结束后会自动恢复","选项B":"sleep不释放对象锁，wait放弃对象锁","选项A":"sleep是线程类（Thread）的方法，wait是Object类的方法","类型":"1-单选"},{"题干":"关于java多线程，多个线程并发执行时，线程之间的相对执行顺序是","选项F":"","选项E":"","选项D":"明确的","答案":"A","选项C":"可控制的","选项B":"确定的","选项A":"不确定的","类型":"1-单选"},{"题干":"关于多线程，Java中线程安全问题是通过关键字（）解决的","选项F":"","选项E":"","选项D":"notify()","答案":"C","选项C":"Synchronized","选项B":"wait()","选项A":"Finally","类型":"1-单选"},{"题干":"关于java多线程，下列关于Java线程的说法正确的是","选项F":"","选项E":"","选项D":"使用new Thread(new X()).run();方法启动一个线程","答案":"A","选项C":"Thread类属于java.util程序包","选项B":"创建线程的两种方法中，从Thread类中继承方式可以防止出现多父类的问题","选项A":"每一个Java线程可以看成由代码、一个真实的CPU以及数据三部分组成","类型":"1-单选"},{"题干":"关于java多线程，如下代码创建一个新线程并启动线程，问:四个选项中可以保证正确代码创建target对象，并能编译正确的是\npublic static void main(String[] args) {\n          Runnable target=new MyRunnable( ); \n          Thread myThread=new Thread(target);\n}","选项F":"","选项E":"","选项D":"public class MyRunnable  implements Runnable  {\n    void run(){}\n}","答案":"C","选项C":"public class MyRunnable  implements Runnable  {\n    public void run(){}\n}","选项B":"public class MyRunnable extends Runnable {\n    void run(){}\n}","选项A":"public class MyRunnable extends Runnable {\n    public void run( ){}\n}","类型":"1-单选"},{"题干":"关于java多线程，线程执行完了或者因异常退出了run()方法，变成什么状态","选项F":"","选项E":"","选项D":"新建状态","答案":"A","选项C":"就绪状态","选项B":"运行状态","选项A":"死亡状态","类型":"1-单选"},{"题干":"关于java多线程，下列关于Thread类提供的线程控制方法的说法中，错误的是","选项F":"","选项E":"","选项D":"currentThread()方法返回当前线程的引用","答案":"C","选项C":"若线程A调用方法isAlive()返回值为false，则说明A正在执行中，也可能是可运行状态","选项B":"线程A通过调用interrupt()方法来中断其阻塞状态","选项A":"线程A中执行线程B的join()方法，则线程A等待直到B执行完成","类型":"1-单选"},{"题干":"关于java多线程，下面说法不正确的是","选项F":"","选项E":"","选项D":"Java中的线程可以共享代码","答案":"B","选项C":"Java中的线程可以共享数据","选项B":"Java中线程是分时的","选项A":"Java中线程是抢占式的","类型":"1-单选"},{"题干":"关于java多线程，方法resume()负责恢复哪些线程的执行","选项F":"","选项E":"","选项D":"通过调用suspend()方法而停止的线程","答案":"D","选项C":"通过调用wait()方法而停止的线程","选项B":"通过调用sleep()方法而停止的线程","选项A":"通过调用stop()方法而停止的线程","类型":"1-单选"},{"题干":"关于java多线程，继承Thread类，必须重写该类的哪种方法","选项F":"","选项E":"","选项D":"synchronized()","答案":"A","选项C":"start()","选项B":"init()","选项A":"run()","类型":"1-单选"},{"题干":"关于java多线程，下列描述正确的是","选项F":"","选项E":"","选项D":"一个线程可以包含多个进程","答案":"C","选项C":"Java提供对多线程同步提供语言级的支持","选项B":"启动一个线程直接调用线程对象的run()方法","选项A":"线程对象必须实现Runnable接口","类型":"1-单选"},{"题干":"关于java多线程，线程run()、main() 方法执行结束，或者因异常退出了run()方法，线程处于什么状态","选项F":"","选项E":"","选项D":"死亡(DEAD)","答案":"D","选项C":"阻塞(BLOCKED)","选项B":"运行(RUNNING)","选项A":"可运行(RUNNABLE)","类型":"1-单选"},{"题干":"关于java多线程，下列选项中不属于多线程作用的是","选项F":"","选项E":"","选项D":"使多CPU系统更加有效","答案":"A","选项C":"改善程序结构","选项B":"提高应用程序的响应","选项A":"提高内存存储空间","类型":"1-单选"},{"题干":"下列选项中，File类的哪些方法可以创建文件夹","选项F":"","选项E":"","选项D":"mkdirs()","答案":"BD","选项C":"newFile()","选项B":"mkdir","选项A":"createFile()","类型":"2-多选"},{"题干":"下列选项中，属于线程生命周期状态的有","选项F":"","选项E":"","选项D":"运行状态","答案":"ABCD","选项C":"阻塞状态","选项B":"就绪状态","选项A":"新建状态","类型":"2-多选"},{"题干":"下列选项中，属于SQL中DML语言关键字的有","选项F":"","选项E":"","选项D":"select","答案":"ABC","选项C":"update","选项B":"delete","选项A":"insert","类型":"2-多选"},{"题干":"下列选项中，可以实现多线程的有","选项F":"","选项E":"","选项D":"实现Thread","答案":"AB","选项C":"实现Serializable","选项B":"实现Runnable","选项A":"继承Thread","类型":"2-多选"},{"题干":"下列选项中，属于Thread类提供的线程控制方法的有哪些？","选项F":"","选项E":"","选项D":"yield","答案":"ABD","选项C":"init","选项B":"interrupt","选项A":"sleep","类型":"2-多选"},{"题干":"关于java多线程，下列关于线程的优先级说法中，正确的是","选项F":"","选项E":"","选项D":"线程的优先级的范围在1-10之间","答案":"BD","选项C":"在创建线程后的任何时候都可以重新设置","选项B":"线程的优先级是在创建线程时设置的","选项A":"线程的优先级是不能改变的","类型":"2-多选"},{"题干":"关于java多线程，有关线程的哪些叙述是对的","选项F":"","选项E":"","选项D":"一个线程可能因为不同的原因停止并进入就绪状态","答案":"BCD","选项C":"当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面","选项B":"使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行","选项A":"一旦一个线程被创建，它就立即开始运行","类型":"2-多选"},{"题干":"关于java多线程，有几种原因可以导致线程不能运行","选项F":"","选项E":"","选项D":"挂起及由于I/O操作而阻塞","答案":"ACD","选项C":"休眠","选项B":"少量内存泄漏","选项A":"等待","类型":"2-多选"},{"题干":"关于java多线程，下列说法正确的包括哪些","选项F":"","选项E":"","选项D":"新建的线程调用start()方法就能立即进入运行状态","答案":"ABC","选项C":"线程操作的数据来自Runnable实例","选项B":"线程从传递给线程的Runnable实例的run方法开始运行","选项A":"一个线程是一个Thread类的实例","类型":"2-多选"},{"题干":"关于java多线程，java线程有几种创建方式","选项F":"","选项E":"","选项D":"使用Callable和Future创建线程","答案":"ACD","选项C":"实现Runnable接口","选项B":"继承Object类","选项A":"继承Thread类","类型":"2-多选"},{"题干":"多线程没有安全问题","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"关于多线程，当一个线程进入一个对象的一个synchronized方法后，其它线程不可以再进入该对象同步的其它方法执行。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"一个进程中只能包含一个线程","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"关于java多线程，A线程的优先级是10，B线程的优先级是1，那么当进行调度时一定会先调用A","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"stop()方法是终止当前线程的一种方法","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"关于java多线程，线程优先级可以用从1到10的范围指定。10表示最高优先级，1表示最低优先级，5是普通优先级。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"关于java多线程，进程是线程Thread内部的一个执行单元，它是程序中一个单一顺序控制流程。","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"关于java多线程，如果线程死亡，它便不能运行","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"关于java多线程，一个进程可以包括多个线程。两者的一个主要区别是：线程是资源分配的单位，而进程是CPU调度和执行的单位。","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"关于java多线程，用new关键字建立一个线程对象后，该线程对象就处于新生状态。处于新生状态的线程有自己的内存空间，通过调用start进入就绪状态。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"}]