[{"题干":"Thread类定义在以下哪个包中？","选项F":"","选项E":"","选项D":"java.awt","答案":"B","选项C":"java.util","选项B":"java.lang","选项A":"java.io","类型":"1-单选"},{"题干":"如果要一个线程等待一段时间后再恢复执行此线程，需要调用什么方法？","选项F":"","选项E":"","选项D":"notify()","答案":"B","选项C":"join()","选项B":"yield()","选项A":"wait()","类型":"1-单选"},{"题干":"Thread类的方法中，getName()方法的作用是","选项F":"","选项E":"","选项D":"获取当前线程优先级","答案":"B","选项C":"获取当前类名称","选项B":"返回线程的名称","选项A":"设置线程的名称","类型":"1-单选"},{"题干":"编写线程类，要继承的父类是","选项F":"","选项E":"","选项D":"Serializable","答案":"C","选项C":"Thread","选项B":"Runnable","选项A":"Object","类型":"1-单选"},{"题干":"以下不属于Thread类提供的线程控制方法是","选项F":"","选项E":"","选项D":"join()","答案":"A","选项C":"yield()","选项B":"sleep()","选项A":"break()","类型":"1-单选"},{"题干":"1533517925234Java反射中，能够获取本类中声明的所有方法，包括私有方法的是","选项F":"","选项E":"","选项D":"c1.getDeclaredFields();","答案":"A","选项C":"c1.getFields();","选项B":"c1.getMethods();","选项A":"c1.getDeclaredMethods();","类型":"1-单选"},{"题干":"编写线程类，可以通过实现那个接口来实现？","选项F":"","选项E":"","选项D":"Throwable","答案":"A","选项C":"Serializable","选项B":"Thread","选项A":"Runnable","类型":"1-单选"},{"题干":"实现线程体的方式除了继承Thread类，还可以实现（）接口。","选项F":"","选项E":"","选项D":"Cloneable","答案":"A","选项C":"Serializable","选项B":"Iterable","选项A":"Runnable","类型":"1-单选"},{"题干":"1533623855434Java中对象序列化，相对应的类需要实现的接口是哪个","选项F":"","选项E":"","选项D":"Cloneable","答案":"C","选项C":"Serializable","选项B":"List","选项A":"Map","类型":"1-单选"},{"题干":"关于java多线程，以下说法中关于线程通信的说法错误的是","选项F":"","选项E":"","选项D":"wait()、notify()、notifyAll()是Object类提供的方法，子类可以重写","答案":"D","选项C":"wait()有多个重载的方法，可以指定等待的时间","选项B":"wait()、notify()、notifyAll()是Object类提供的方法，子类不可以重写","选项A":"可以调用wait()、notify()、notifyAll()三个方法实现线程通信","类型":"1-单选"},{"题干":"关于java多线程，在多线程环境下，使用什么关键字修饰的公共变量，能保证此变量的可见性","选项F":"","选项E":"","选项D":"protect","答案":"B","选项C":"static","选项B":"volatile","选项A":"final","类型":"1-单选"},{"题干":"关于java多线程，下面说法正确的是其中的哪个","选项F":"","选项E":"","选项D":"java中的线程不可以共享代码","答案":"C","选项C":"每个java程序都至少有一个线程，即主线程","选项B":"java中的线程不可以共享数据","选项A":"java中线程是非抢占式的","类型":"1-单选"},{"题干":"java中一个线程如果出现了运行时异常，这个异常没有被捕获，线程处于什么状态？","选项F":"","选项E":"","选项D":"死亡状态","答案":"D","选项C":"阻塞状态","选项B":"运行状态","选项A":"新建状态","类型":"1-单选"},{"题干":"在线程通信中，调用wait()可以是当前线程处于等待状态，而为了唤醒一个等待的线程，需要调用的方法是","选项F":"","选项E":"","选项D":"start()","答案":"B","选项C":"join()","选项B":"notify()","选项A":"wait()","类型":"1-单选"},{"题干":"java中，处于新建状态的线程被启动后，将进入线程队列排队等待CPU，此时它已具备了运行条件，一旦轮到享用CPU资源就可以获得执行机会。上述线程是处于什么状态？","选项F":"","选项E":"","选项D":"死亡状态","答案":"A","选项C":"阻塞状态","选项B":"运行状态","选项A":"就绪状态","类型":"1-单选"},{"题干":"java线程中，start()方法启动线程将自动调用run()方法，run()方法必需是public访问权限，返回值类型必须是？","选项F":"","选项E":"","选项D":"byte","答案":"C","选项C":"void","选项B":"boolean","选项A":"int","类型":"1-单选"},{"题干":"关于java多线程，Thread中的哪个方法用来检测当前线程是否拥有锁","选项F":"","选项E":"","选项D":"getLock()","答案":"B","选项C":"isLock()","选项B":"holdsLock()","选项A":"hasLock()","类型":"1-单选"},{"题干":"一个正在执行的线程可能被人为地中断，让出CPU的使用权，暂时中止自己的执行，进入（）状态","选项F":"","选项E":"","选项D":"死亡","答案":"C","选项C":"阻塞","选项B":"运行","选项A":"就绪","类型":"1-单选"},{"题干":"在线程控制中，可以调用（）方法，阻塞当前正在执行的线程，等插队线程执行完后后再执行阻塞线程。","选项F":"","选项E":"","选项D":"run()","答案":"A","选项C":"notify()","选项B":"wait()","选项A":"join()","类型":"1-单选"},{"题干":"假设test类运行于多线程环境下，那么关于A处的同步下面描述正确的是？\npublic class Test {\n  List list= new java.util.ArrayList();\n  public void test() {\n    synchronized ( list) {\n      list.add( String.valueOf(System.currentTimeMillis()));\n    }\n  }\n}","选项F":"","选项E":"","选项D":"Test类为singleton时也没有必要增加synchronized","答案":"D","选项C":"test方法中没有必要增加synchronized","选项B":"Test类为singleton时有必要增加synchronized","选项A":"test方法中必须增加synchronized","类型":"1-单选"},{"题干":"java的BufferWriter的方法中，写入单个字符的方法是","选项F":"","选项E":"","选项D":"void write()","答案":"C","选项C":"void write(int c)","选项B":"void write(String s, int off, int len)","选项A":"void write(char[] cbuf, int off, int len)","类型":"1-单选"},{"题干":"由于同步锁被其他线程占用，运行状态中的线程在获取synchronized同步锁失败时，进入什么状态","选项F":"","选项E":"","选项D":"阻塞状态","答案":"D","选项C":"死亡状态","选项B":"就绪状态","选项A":"运行状态","类型":"1-单选"},{"题干":"1533540956266Java\u00A0IO中，属于字节流的是那个","选项F":"","选项E":"","选项D":"BufferedReader","答案":"AB","选项C":"PrintWriter","选项B":"FileOutputStream","选项A":"FileInputStream","类型":"2-多选"},{"题干":"Java多线程中，关于synchronized和Lock说法正确的是","选项F":"","选项E":"","选项D":"Lock一定要求程序员手工释放，并且要在finally从句中释放","答案":"ABCD","选项C":"synchronized会自动释放锁","选项B":"Lock有比synchronized更精确的线程语义和更好的性能","选项A":"Lock能完成synchronized所实现的所有功能","类型":"2-多选"},{"题干":"关于java多线程，线程死锁的发生必须满足哪些条件","选项F":"","选项E":"","选项D":"循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。","答案":"ABCD","选项C":"不剥夺条件：线程程已获得的资源，在末使用完之前，不能强行剥夺。","选项B":"请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。","选项A":"互斥条件：一个资源每次只能被一个线程使用。","类型":"2-多选"},{"题干":"关于多线程，Java中解决线程并发同步问题有哪些方法","选项F":"","选项E":"","选项D":"使用final关键字","答案":"AC","选项C":"使用Lock类","选项B":"使用volatie关键字","选项A":"使用synchronized关键字","类型":"2-多选"},{"题干":"SQL语句可以分为多类，以下属于SQL语句的有()","选项F":"","选项E":"","选项D":"TCL","答案":"ABCD","选项C":"DCL","选项B":"DML","选项A":"DDL","类型":"2-多选"},{"题干":"关于java多线程，下面能让线程停止执行的有","选项F":"","选项E":"","选项D":"notify();","答案":"ABC","选项C":"wait();","选项B":"synchronized();","选项A":"stop();","类型":"2-多选"},{"题干":"关于java多线程，以下选项中关于Java中线程控制方法的说法正确的是","选项F":"","选项E":"","选项D":"setDaemon()的作用是将指定的线程设置成后台线程","答案":"AD","选项C":"yield()的作用是使线程停止运行一段时间，将处于阻塞状态","选项B":"sleep()的作用是让当前正在执行线程暂停，线程将转入就绪状态","选项A":"join()的作用是阻塞指定线程等到另一个线程完成以后再继续执行","类型":"2-多选"},{"题干":"哪些方法是Object类提供的public方法","选项F":"","选项E":"","选项D":"join()","答案":"ABC","选项C":"notifyAll()","选项B":"notify()","选项A":"wait()","类型":"2-多选"},{"题干":"在线程通信中，调用wait( )可以是当前线程处于等待状态，而为了唤醒一个等待的线程，可以调用哪些方法","选项F":"","选项E":"","选项D":"join()","答案":"BC","选项C":"notifyAll()","选项B":"notify()","选项A":"run()","类型":"2-多选"},{"题干":"以下选项中可以填写到横线处，让代码正确编译和运行的是\npublic class Test implements Runnable {\n    public static void main(String[] args) {\n___________________________________\n        t.start();\n        System.out.println(\"main\");\n    }\n    public void run() {\n        System.out.println(\"thread1!\");\n    }\n}","选项F":"","选项E":"","选项D":"Thread t = new Thread();","答案":"AD","选项C":"Thread t = new Test();","选项B":"Test t = new Test();","选项A":"Thread t = new Thread(new Test());","类型":"2-多选"},{"题干":"java多线程中，处于运行状态的线程可以变为其它哪些状态","选项F":"","选项E":"","选项D":"死亡状态","答案":"ABD","选项C":"新建状态","选项B":"就绪状态","选项A":"阻塞状态","类型":"2-多选"},{"题干":"方法Integer.parseInt()的作用是将一个整数转变成String类型","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Java中线程的优先级从低到高以整数0-9表示","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"当调用一个正在进行线程的stop()方法时，该线程便会进入休眠状态","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"一旦一个线程被创建，它就可以立即开始运行","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"多线程安全问题的解决方案可以使用Lock提供的具体的锁对象操作","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"关于java多线程，volatile关键字能保证线程安全","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"在Java中，高优先级的可运行线程会抢占低优先级线程","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"java中的线程不可以共享代码","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"关于java多线程，使用synchronized关键字来实现线程同步会影响性能，甚至出现死锁","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"关于java多线程，线程可以用yield使低优先级的线程运行。","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"}]