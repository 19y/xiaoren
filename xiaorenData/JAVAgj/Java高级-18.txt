[{"题干":"下列选项中不属于设计模式的原则的是","选项F":"","选项E":"","选项D":"依赖注入原则","答案":"C","选项C":"高耦合原则——牵一发而动全身","选项B":"开闭原则","选项A":"单一职责原则","类型":"1-单选"},{"题干":"对于原型模式中的深克隆，可以理解为","选项F":"","选项E":"","选项D":"深度克隆中，引用数据类型没有被克隆，还指向原来旧对象的中的引用数据类型的对象","答案":"A","选项C":"深度克隆必须重写Object类的clone()方法","选项B":"深克隆需要实现Cloneable接口","选项A":"深克隆就是对象的序列化与反序列化","类型":"1-单选"},{"题干":"原型模式中用原型实例指定创建对象的种类，并且通过拷贝这些原型创建___对象","选项F":"","选项E":"","选项D":"新的","答案":"D","选项C":"旧的","选项B":"方法","选项A":"属性","类型":"1-单选"},{"题干":"下列选项中，关于单例模式说法正确的是","选项F":"","选项E":"","选项D":"单例模式不属于23种设计模式","答案":"A","选项C":"一个类用到多个实例时","选项B":"单例模式是一个具体工厂类","选项A":"当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。","类型":"1-单选"},{"题干":"单例模式可以保证一个类仅有____实例，并且提供一个访问它的全局访问点","选项F":"","选项E":"","选项D":"2","答案":"A","选项C":"多个","选项B":"0","选项A":"1","类型":"1-单选"},{"题干":"下列选项中，不属于创建型模式的是","选项F":"","选项E":"","选项D":"代理模式","答案":"D","选项C":"原型模式","选项B":"工厂模式","选项A":"单例模式","类型":"1-单选"},{"题干":"下列选项中，属于结构型模式的是","选项F":"","选项E":"","选项D":"代理模式","答案":"D","选项C":"原型模式","选项B":"工厂模式","选项A":"单例模式","类型":"1-单选"},{"题干":"下列选项，不属于设计模式的是","选项F":"","选项E":"","选项D":"适配器模式","答案":"A","选项C":"原型模式","选项B":"单例模式","选项A":"MVC模式","类型":"1-单选"},{"题干":"下列选项中，不属于工厂模式的是？","选项F":"","选项E":"","选项D":"简单工厂","答案":"C","选项C":"接口工厂","选项B":"抽象工厂","选项A":"简单工厂","类型":"1-单选"},{"题干":"关于原型模式中的浅克隆，被克隆的类需要实现一个接口，这个接口为","选项F":"","选项E":"","选项D":"Serializable","答案":"A","选项C":"List","选项B":"Map","选项A":"Cloneable","类型":"1-单选"},{"题干":"关于设计模式，工厂模式形态描述错误的是","选项F":"","选项E":"","选项D":"抽象工厂模式","答案":"B","选项C":"工厂方法模式","选项B":"动态工厂模式","选项A":"简单工厂模式","类型":"1-单选"},{"题干":"关于设计模式，当我们想创建一个具体的对象而又不希望指定具体的类时，可以使用（ ）模式","选项F":"","选项E":"","选项D":"任何一种","答案":"A","选项C":"行为型","选项B":"结构型","选项A":"创建型","类型":"1-单选"},{"题干":"常用的设计模式可分为","选项F":"","选项E":"","选项D":"抽象型、接口型和实现型","答案":"A","选项C":"过程型、创建型和结构型","选项B":"对象型、结构型和行为型","选项A":"创建型、结构型和行为型","类型":"1-单选"},{"题干":"以下哪一条不属于设计模式的基本原则","选项F":"","选项E":"","选项D":"依赖倒转原则","答案":"C","选项C":"优先使用继承的原则","选项B":"里氏代换原则","选项A":"开闭原则","类型":"1-单选"},{"题干":"关于设计模式，Factory Method模式和Prototype模式之间的区别可以理解为","选项F":"","选项E":"","选项D":"Factory Method模式是利用现有的对象进行克隆","答案":"A","选项C":"Prototype模式没有利用现有的对象进行克隆","选项B":"Prototype模式是重新创建一个对象","选项A":"Factory Method模式是重新创建一个对象","类型":"1-单选"},{"题干":"java中，下面的哪些赋值语句是错误的","选项F":"","选项E":"","选项D":"double d=3.14D;","答案":"A","选项C":"double d=3.14159;","选项B":"double d=5.3E12;","选项A":"float f=11.1;","类型":"1-单选"},{"题干":"java中，从ArrayList集合中删除元素需要调用哪个方法","选项F":"","选项E":"","选项D":"set()","答案":"B","选项C":"del();","选项B":"remove()","选项A":"delete()","类型":"1-单选"},{"题干":"java中，异常处理模型中，无论是否发生异常，以下选项中，什么块中的代码都会执行？","选项F":"","选项E":"","选项D":"finally","答案":"D","选项C":"throw","选项B":"catch","选项A":"try","类型":"1-单选"},{"题干":"java中，声明抽象类和抽象方法都需要用到的关键字是","选项F":"","选项E":"","选项D":"implements","答案":"C","选项C":"abstract","选项B":"interface","选项A":"class","类型":"1-单选"},{"题干":"以下哪个是java基本数据类型的封装类","选项F":"","选项E":"","选项D":"byte","答案":"C","选项C":"Long","选项B":"short","选项A":"int","类型":"1-单选"},{"题干":"下列属于设计模式原则的是","选项F":"","选项E":"","选项D":"依赖倒转原则","答案":"ABCD","选项C":"接口隔离原则","选项B":"迪米特法则","选项A":"合成复用原则","类型":"2-多选"},{"题干":"下列选择中，属于设计模式的有","选项F":"","选项E":"","选项D":"原型模式","答案":"AD","选项C":"MVC模式","选项B":"生存模式","选项A":"单例模式","类型":"2-多选"},{"题干":"原型模式包括哪些？","选项F":"","选项E":"","选项D":"懒汉式","答案":"AB","选项C":"饿汉式","选项B":"深克隆","选项A":"浅克隆","类型":"2-多选"},{"题干":"下列选项中，符合JDK代理特点的是","选项F":"","选项E":"","选项D":"代理对象一定实现接口","答案":"BCD","选项C":"JDK代理属于动态代理的一种","选项B":"JDK是实现代理需要使用newProxyInstance方法","选项A":"代理对象,不需要实现接口","类型":"2-多选"},{"题干":"单例模式类要求有哪些？","选项F":"","选项E":"","选项D":"变量私有化","答案":"ABCD","选项C":"变量静态化","选项B":"公共的访问节点","选项A":"构造器私有化","类型":"2-多选"},{"题干":"关于设计模式，工厂模式可以分为几种","选项F":"","选项E":"","选项D":"适配器模式","答案":"ABC","选项C":"抽象工厂模式","选项B":"工厂方法模式","选项A":"简单工厂模式","类型":"2-多选"},{"题干":"关于设计模式，设计模式的优点有哪些","选项F":"","选项E":"","选项D":"设计模式使人们可以方便简单的复用设计模式","答案":"ABCD","选项C":"设计模式有助于初学者理解面向对象的思想","选项B":"设计模式的使用将提高软件开发效率与质量，节约成本","选项A":"设计模式融合了众多专家的经验，并以标准的形式给广大群众使用，她提供了一种通用的设计词汇，和一种通用的设计语言，以方便开发人员之间开发和交流，使得设计方案更加通俗易懂","类型":"2-多选"},{"题干":"关于设计模式，不属于结构型模式有哪些","选项F":"","选项E":"","选项D":"适配器模式","答案":"ABC","选项C":"原型模式","选项B":"工厂模式","选项A":"单例模式","类型":"2-多选"},{"题干":"关于设计模式，代理模式的优点是","选项F":"","选项E":"","选项D":"简化业务逻辑","答案":"ABC","选项C":"智能化","选项B":"高扩展性","选项A":"职责清晰","类型":"2-多选"},{"题干":"java中，this和super的说法正确的是","选项F":"","选项E":"","选项D":"意义不同","答案":"CD","选项C":"不能用在main()方法中","选项B":"都是指一个内存地址","选项A":"都可以用在main()方法中","类型":"2-多选"},{"题干":"Java设计模式中，代理类在程序运行时创建的代理方式被称为动态代理","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Java设计模式中，代理是一种模式，提供了对目标对象的直接访问方式","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"单例设计模式中饿汉式在多线程时不会出现线程安全问题","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"代理模式可分为静态代理和动态代理","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"工厂模式只有简单工厂和抽象工厂两种","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"关于设计模式，工厂方法模式中一个抽象产品类，可以派生出多个具体产品类","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"关于设计模式，抽象工厂模式中每个具体工厂类只能创建一个具体产品类的实例","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"设计模式使代码编制不能真正工程化","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"关于设计模式，工厂方法模式的缺点是不易于维护，假如某个具体产品类需要进行一定的修改，很可能需要修改对应的工厂类。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"设计模式使人们可以方便简单的复用设计模式","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"}]