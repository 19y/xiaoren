[{"题干":"代理模式的作用是","选项F":"","选项E":"","选项D":"为其他对象提供一种锁的机制","答案":"A","选项C":"为其他对象提供一种多态的方式","选项B":"为其他对象提供一种继承的方式","选项A":"为其他对象提供一种代理以控制对这个对象的访问","类型":"1-单选"},{"题干":"CGLIB实现动态代理不需要做内容是","选项F":"","选项E":"","选项D":"完成实例化Enhancer","答案":"A","选项C":"完成拦截器","选项B":"完成被代理类","选项A":"完成接口","类型":"1-单选"},{"题干":"JDK动态代理需要实现的内容是","选项F":"","选项E":"","选项D":"实现回调接口InvocationHandler","答案":"D","选项C":"完成实例化Enhancer","选项B":"接口","选项A":"被代理类","类型":"1-单选"},{"题干":"JDK动态代理利用是Java的那个机制","选项F":"","选项E":"","选项D":"面向对象机制","答案":"A","选项C":"依赖注入机制","选项B":"注解机制","选项A":"反射机制","类型":"1-单选"},{"题干":"实现jdk动态代理一定要到的类是","选项F":"","选项E":"","选项D":"String","答案":"B","选项C":"Arrays","选项B":"Proxy","选项A":"Thread","类型":"1-单选"},{"题干":"实现CGLIB需要实现的类或接口是","选项F":"","选项E":"","选项D":"MethodInterceptor","答案":"D","选项C":"Thread","选项B":"Arrays","选项A":"Proxy","类型":"1-单选"},{"题干":"CGLIB生成的动态代理类与目标类的关系，是以下的哪个？","选项F":"","选项E":"","选项D":"依赖","答案":"A","选项C":"实现共同接口","选项B":"实现","选项A":"继承","类型":"1-单选"},{"题干":"JDK生成的动态代理类与目标类关系是","选项F":"","选项E":"","选项D":"没有关系","答案":"C","选项C":"实现共同接口","选项B":"实现","选项A":"继承","类型":"1-单选"},{"题干":"关于CGLIb原理说法正确的是","选项F":"","选项E":"","选项D":"使用反射机制转换字节码并修改目标类","答案":"A","选项C":"使用反射机制转换字节码并生成新的类","选项B":"使用字节码处理框架ASM转换字节码并修改目标类","选项A":"使用字节码处理框架ASM转换字节码并生成新的类","类型":"1-单选"},{"题干":"关于Proxy说法正确的是","选项F":"","选项E":"","选项D":"需要实例化后才能使用","答案":"B","选项C":"是一个抽象类","选项B":"是一个工具类","选项A":"是一个接口","类型":"1-单选"},{"题干":"CGLIB实现动态代理是基于什么实现","选项F":"","选项E":"","选项D":"数组","答案":"A","选项C":"类和接口","选项B":"接口","选项A":"类","类型":"1-单选"},{"题干":"JDK动态代理是基于什么实现","选项F":"","选项E":"","选项D":"数组","答案":"B","选项C":"类和接口","选项B":"接口","选项A":"类","类型":"1-单选"},{"题干":"实现jdk动态代理调用Proxy类中的那个方法实现","选项F":"","选项E":"","选项D":"checkNewProxyPermission(Reflection.getCallerClass(), cl);","答案":"A","选项C":"isProxyClass(Class<?> cl)","选项B":"getInvocationHandler(Object proxy)","选项A":"Proxy.newProxyInstance(target.getClass().getClassLoader(),target.getClass().getInterfaces(),this);","类型":"1-单选"},{"题干":"以下不属于代理模式所涉及到的角色是","选项F":"","选项E":"","选项D":"物理角色","答案":"D","选项C":"代理角色","选项B":"真实角色","选项A":"抽象角色","类型":"1-单选"},{"题干":"以下不属于CGlib代理模式使用的api是","选项F":"","选项E":"","选项D":"java.lang.reflect.InvocationHandler","答案":"D","选项C":"net.sf.cglib.proxy.MethodProxy","选项B":"net.sf.cglib.proxy.MethodInterceptor","选项A":"net.sf.cglib.proxy.Enhancer","类型":"1-单选"},{"题干":"以下关于单例模式说法错误的是","选项F":"","选项E":"","选项D":"单例类提供有多个实例","答案":"D","选项C":"单例类必须给所有其他对象提供这一实例","选项B":"单例类必须自己创建自己的唯一实例","选项A":"单例类只能有一个实例","类型":"1-单选"},{"题干":"Java在使用反射中获取访问修饰符的方法是","选项F":"","选项E":"","选项D":"getModify()","答案":"A","选项C":"getModel()","选项B":"getMethods()","选项A":"getModifiers()","类型":"1-单选"},{"题干":"JAVA反射机制提供功能不包括","选项F":"","选项E":"","选项D":"在运行时获取类的子类","答案":"D","选项C":"运行时构造任意一个类的对象","选项B":"运行时判断任意一个类所具有的成员变量和方法","选项A":"运行时调用任意一个对象的方法","类型":"1-单选"},{"题干":"在Java的反射中，以下那个方法可以通过反射获取父类","选项F":"","选项E":"","选项D":"getSuperclass();","答案":"D","选项C":"newInstance();","选项B":"getMethod();","选项A":"getClassLoader();","类型":"1-单选"},{"题干":"在Java反射中，Class对象的方法getName()的功能是","选项F":"","选项E":"","选项D":"返回此Class对象所表示的实体的全限定名称","答案":"D","选项C":"返回此Class对象所表示的实体的所有公共方法","选项B":"返回此Class对象所表示的实体的所有公共字段","选项A":"返回此Class对象所表示的实体的简称","类型":"1-单选"},{"题干":"动态代理的用途有","选项F":"","选项E":"","选项D":"分布式","答案":"ABC","选项C":"做事务控制","选项B":"解耦","选项A":"添加调用日志","类型":"2-多选"},{"题干":"JAVA动态代理主要","选项F":"","选项E":"","选项D":"cgLib动态代理","答案":"AD","选项C":"简单代理","选项B":"spring代理","选项A":"jdk动态代理","类型":"2-多选"},{"题干":"实现静态代理需要做哪些事情","选项F":"","选项E":"","选项D":"实现一个拦截器","答案":"BC","选项C":"完成一个代理类","选项B":"完成一个被代理类","选项A":"实现一个过滤器","类型":"2-多选"},{"题干":"实现CGLIB动态代理需要引入的JDK额外包是","选项F":"","选项E":"","选项D":"rt包","答案":"AB","选项C":"spring包","选项B":"cglib包","选项A":"asm包","类型":"2-多选"},{"题干":"关于CGLIB动态代理说法正确的是","选项F":"","选项E":"","选项D":"Cglib是无法代理final修饰的方法的","答案":"BCD","选项C":"Cglib动态代理执行代理方法效率比JDK的高","选项B":"Cglib的动态代理类是继承了被代理对象","选项A":"Cglib的机制是通过java反射机制调用","类型":"2-多选"},{"题干":"以下属于Java中常见的设计模式的有","选项F":"","选项E":"","选项D":"装饰器模式","答案":"ABCD","选项C":"原型模式","选项B":"代理模式","选项A":"工厂模式","类型":"2-多选"},{"题干":"以下属于代理模式使用场景的有","选项F":"","选项E":"","选项D":"智能引用（Smart Reference）代理","答案":"ABCD","选项C":"Cache代理","选项B":"虚拟代理","选项A":"远程代理","类型":"2-多选"},{"题干":"以下属于代理模式应用的优点有","选项F":"","选项E":"","选项D":"扩展性低","答案":"ABC","选项C":"智能化","选项B":"高扩展性","选项A":"职责清晰","类型":"2-多选"},{"题干":"以下场景可以理解为代理模式的有","选项F":"","选项E":"","选项D":"spring aop","答案":"ABCD","选项C":"买火车票不一定在火车站买，也可以去代售点","选项B":"猪八戒去找高翠兰结果是孙悟空变的","选项A":"Windows 里面的快捷方式","类型":"2-多选"},{"题干":"以下属于动态代理的常见api的有","选项F":"","选项E":"","选项D":"MethodInterceptor","答案":"ABCD","选项C":"Method","选项B":"InvocationHandler","选项A":"Proxy","类型":"2-多选"},{"题干":"JDK动态代理必须要有接口","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"CGLIB动态代理必须有接口","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"静态代理需要有接口","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"CGLIB动态代理不需要引入jdk额外的包","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"动态代理是对于静态代理的继承","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"String temp = new String(\"abc\");创建了2个实例对象","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Math.ceil(-5.2)返回的结果是-5","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"代理模式只含有动态代理和静态代理模式两种","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"动态代理模式是基于类实现的","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Cglib代理模式是基于接口实现的","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"}]