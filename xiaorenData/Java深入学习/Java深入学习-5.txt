[{"题干":"有关java内部类的说法，以下的哪个描述是正确的？","选项F":"","选项E":"","选项D":"内部类可以被继承","答案":"D","选项C":"两个内部类之间不能相互访问","选项B":"外部类不可以访问内部类的方法","选项A":"内部类不可以访问外部类的方法","类型":"1-单选"},{"题干":"关于java内部类说法正确的是","选项F":"","选项E":"","选项D":"关于修饰成员没有特殊的要求","答案":"D","选项C":"不可以用protected修饰其成员","选项B":"不可以用public修饰其成员","选项A":"不可以用private修饰其成员","类型":"1-单选"},{"题干":"class�A{\n����int�y=6;\n����class�Inner{\n��������static�int�y=3;\n��������void�show(){\n���������int�y�=�9;\n������������System.out.println(y);\n��������}\n����}\n}\nclass�Demo{\n����public�static�void�main(String�[]�args){\n��������A.Inner�inner=new�A().new�Inner();\n��������inner.show();\n����}\n}","选项F":"","选项E":"","选项D":"编译失败","答案":"D","选项C":"9","选项B":"6","选项A":"3","类型":"1-单选"},{"题干":"完成代码，以下代码能否被放置在相应的位置上\nclass\u00A0Demo{\n\u00A0\u00A0\u00A0\u00A0public\u00A0void\u00A0func(){\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0//位置1\n\u00A0\u00A0\u00A0\u00A0}\n\u00A0\u00A0\u00A0\u00A0class\u00A0Inner{}\n\u00A0\u00A0\u00A0\u00A0public\u00A0static\u00A0void\u00A0main(String\u00A0[]\u00A0args){\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0Demo\u00A0d=new\u00A0Demo();\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0//位置2\n\u00A0\u00A0\u00A0\u00A0}\n}","选项F":"","选项E":"","选项D":"位置2：new\u00A0Demo.Inner();","答案":"A","选项C":"位置2：new\u00A0d.Inner();","选项B":"位置2：new\u00A0Inner();","选项A":"位置1：new\u00A0Inner();","类型":"1-单选"},{"题干":"class\u00A0Base{\n\u00A0private\u00A0void\u00A0amethod(int\u00A0iBase){\n\u00A0\u00A0System.out.println(“Base.amethod”);\n\u00A0}\n}\nclass\u00A0Example\u00A0extends\u00A0Base{\n\u00A0public\u00A0static\u00A0void\u00A0main(String[]\u00A0args){\n\u00A0\u00A0Example\u00A0o\u00A0=\u00A0new\u00A0Example();\n\u00A0\u00A0int\u00A0iBase\u00A0=\u00A00;\n\u00A0\u00A0o.amethod(iBase);\n\u00A0}\n\u00A0public\u00A0void\u00A0amethod(int\u00A0iover){\n\u00A0\u00A0System.out.println(“Example.amethod”);\n\u00A0}\n}","选项F":"","选项E":"","选项D":"输出Example.amethod","答案":"D","选项C":"输出Base.amethod","选项B":"运行错误","选项A":"编译错误","类型":"1-单选"},{"题干":"下面不属于java类中的类修饰符的是（\u00A0）：","选项F":"","选项E":"","选项D":"abstract","答案":"C","选项C":"extends","选项B":"final","选项A":"public","类型":"1-单选"},{"题干":"下面为数组初始化正确的写法是（\u00A0）：","选项F":"","选项E":"","选项D":"double�c[]�=�new�double(1,2)","答案":"A","选项C":"double�c[]�=�new�double[](1,2)","选项B":"double�c[]�=�new�double{1,2}","选项A":"double�c[]�=�new�double[]{1,2}","类型":"1-单选"},{"题干":"下面对final关键字的使用，错误的是(\u00A0).。","选项F":"","选项E":"","选项D":"定义成final的方法有时可以提高程序性能","答案":"C","选项C":"可以通过继承的方式来建立一个final类的子类","选项B":"子类不能重写父类的final方法","选项A":"final可以定义常量","类型":"1-单选"},{"题干":"关于static关键字描述错误的是(\u00A0\u00A0)。","选项F":"","选项E":"","选项D":"static修饰的方法不能直接调用非static属性","答案":"B","选项C":"static修饰的属性，所有对象共用同一地址","选项B":"用来创建对象","选项A":"表示静态","类型":"1-单选"},{"题干":"关于构造方法，描述错误的是(\u00A0\u00A0\u00A0)。","选项F":"","选项E":"","选项D":"构造方法不能有参数","答案":"D","选项C":"构造方法不能是抽象的","选项B":"可以使用private关键字修饰构造方法","选项A":"定义构造方法时，不需要加返回值类型","类型":"1-单选"},{"题干":"哪个关键字可以对对象加互斥锁(\u00A0\u00A0)。","选项F":"","选项E":"","选项D":"static","答案":"B","选项C":"serialize","选项B":"synchronized","选项A":"transient","类型":"1-单选"},{"题干":"关于StringBuffer说法错误的是","选项F":"","选项E":"","选项D":"执行reverse后开辟新的内存空间存储数据，并释放原来的存储空间","答案":"D","选项C":"线程安全","选项B":"默认容量是长度16","选项A":"继承于\u00A0\u00A0AbstractStringBuilder","类型":"1-单选"},{"题干":"设有下面的一个类定义：\n\u00A0\u00A0 class AA {\n\u00A0\u00A0\u00A0\u00A0 static\u00A0 void\u00A0 show( ){\n             System.out.println(\"我喜欢Java编程!\"); \n         }\n\u00A0\u00A0 }\n\u00A0\u00A0 class\u00A0 BB {\u00A0\n       void\u00A0 show( ){ \n            System.out.println(\"我喜欢android编程!\");\n       }\n }\n若已经使用AA类创建对象a和BB类创建对象b，则下面（     ）方法调用是正确的。","选项F":"","选项E":"","选项D":"a.show( );BB.show( );","答案":"C","选项C":"AA.show( );b.show( );","选项B":"AA.show( );BB.show( )","选项A":"a.show( )b.show( )","类型":"1-单选"},{"题干":"以下有关类继承的叙述中，正确的是（    ）","选项F":"","选项E":"","选项D":"子类不能继承父类的私有属性","答案":"D","选项C":"子类只能继承父类的非私有属性，不能继承父类的方法","选项B":"子类只能继承父类的方法，不能继承父类的属性","选项A":"子类能直接继承父类所有的非私有属性，也可通过接口继承父类的私有属性","类型":"1-单选"},{"题干":"下列类的定义，错误的是","选项F":"","选项E":"","选项D":"void class Point{\n      ……\n\u00A0 }","答案":"D","选项C":"class Point{\n      ……\n\u00A0 }","选项B":"final class Operators{\n      ……\n   }","选项A":"public class Test extends Object{\n      ……\n\u00A0}","类型":"1-单选"},{"题干":"关于以下application的说明，正确的是（       ）\n1．  class   StaticStuff\n2． { \n3．                  static  int  x=10；\n4．                  static  { x+=5；}\n5．                  public  static  void  main（String  args[ ]）\n6．                  {\n7．                       System.out.println(“x=” + x);\n8．                  }\n9．                  static  { x/=3;}\n10.   }","选项F":"","选项E":"","选项D":"编译通过，执行结果为：x=3","答案":"C","选项C":"编译通过，执行结果为：x=5","选项B":"9行不能通过编译，因为只能有一个静态初始化器","选项A":"4行与9行不能通过编译，因为缺少方法名和返回类型","类型":"1-单选"},{"题干":"关于以下程序代码的说明正确的是（      ）\n1．class  HasStatic{\n2．    private  static  int  x=100；\n3．    public  static  void  main(String  args[  ]){\n4．        HasStatic  hs1=new  HasStatic(  );\n5．        hs1.x++;\n6．        HasStatic  hs2=new  HasStatic(  );\n7．        hs2.x++;\n8．        hs1=new  HasStatic( );\n9．        hs1.x++;\n10．       HasStatic.x- -;\n11．       System.out.println(“x=”+x);\n12．    }\n13． }","选项F":"","选项E":"","选项D":"程序通过编译，输出结果为：x=102","答案":"D","选项C":"程序通过编译，输出结果为：x=103","选项B":"10行不能通过编译，因为x是私有静态变量","选项A":"5行不能通过编译，因为引用了私有静态变量","类型":"1-单选"},{"题干":"类Test1定义如下：\n1．public  class  Test1{\n2．         public  float  aMethod（float  a，float  b）{   } \n3．    \n4．}       \n将以下哪种方法插入行3是不合法的。（       ）","选项F":"","选项E":"","选项D":"private float aMethod（int a，int b，int c）{  }","答案":"B","选项C":"public  int  aMethod（int  a， int b）{  }","选项B":"public  float  aMethod（float  c，float d）{  }","选项A":"public  float  aMethod（float  a， float  b，float  c）{  }","类型":"1-单选"},{"题干":"有以下程序片段，下列哪个选项不能插入到行1。（      ）\n1.\n2.public  class  Interesting{\n3.//do sth   \n4. }","选项F":"","选项E":"","选项D":"public class MyClass{ }","答案":"D","选项C":"class OtherClass{   }","选项B":"package mypackage;","选项A":"import java.awt.*;","类型":"1-单选"},{"题干":"A派生出子类B，B派生出子类C，并且在Java源代码中有如下声明： \n1.    A  a0=new  A();\n2.    A  a1 =new  B();\n3.    A  a2=new  C();\n问以下哪个说法是正确的？","选项F":"","选项E":"","选项D":"第1行、第2行和第3行的声明都是正确的","答案":"D","选项C":"第1、2、3行能通过编译，但第2、3行运行时出错","选项B":"第1、2行能通过编译，但第3行编译出错","选项A":"只有第1行能通过编译","类型":"1-单选"},{"题干":"以下关于继承的叙述正确的是（   ）。","选项F":"","选项E":"","选项D":"在Java中接口只允许单一继承","答案":"A","选项C":"在Java中一个类不能同时继承一个类和实现一个接口","选项B":"在Java中一个类只能实现一个接口","选项A":"在Java中类只允许单一继承","类型":"1-单选"},{"题干":"编译并运行以下程序，以下描述哪个选项是正确的（   ）\n1.  class  A{\n2.      protected  boolean  equals(){\n3.           return  super.equals();\n4． }\n5. }","选项F":"","选项E":"","选项D":"不能成功编译，行3出错","答案":"D","选项C":"行2出错，不能成功编译","选项B":"编译通过但运行时出错","选项A":"编译通过运行无异常","类型":"1-单选"},{"题干":"面向对象的基本特征","选项F":"","选项E":"","选项D":"重载","答案":"ABC","选项C":"多态","选项B":"继承","选项A":"封装","类型":"2-多选"},{"题干":"实现多态的方式","选项F":"","选项E":"","选项D":"函数调用","答案":"ABC","选项C":"重载","选项B":"实现接口","选项A":"继承（重写）","类型":"2-多选"},{"题干":"内部类包括","选项F":"","选项E":"","选项D":"静态内部类","答案":"ABCD","选项C":"成员内部类","选项B":"局部内部类","选项A":"匿名内部类","类型":"2-多选"},{"题干":"关于代码执行顺序，下列说法正确的是：","选项F":"","选项E":"","选项D":"构造函数先于变量和代码块","答案":"AC","选项C":"父类的构造函数先于子类的构造函数","选项B":"父类的变量和代码块先于先于子类静态变量和静态代码块","选项A":"父类静态变量和静态代码块先于子类静态变量和静态代码块","类型":"2-多选"},{"题干":"下列关于修饰符混合使用的说法，正确的是(\u00A0\u00A0\u00A0\u00A0\u00A0)。","选项F":"","选项E":"","选项D":"static方法中能处理非static的属性","答案":"ABC","选项C":"abstract方法必须在abstract类中或接口中","选项B":"abstract类中可以有private的成员","选项A":"abstract不能与final并列修饰同一个类","类型":"2-多选"},{"题干":"以下关于构造函数的描述正确的是","选项F":"","选项E":"","选项D":"一般在创建新对象时，系统会自动调用构造函数","答案":"BCD","选项C":"构造函数的主要作用是完成对类的对象的初始化工作","选项B":"构造函数是类的一种特殊函数，它的方法名必须与类名相同","选项A":"构造函数的返回类型只能是void型","类型":"2-多选"},{"题干":"下述概念中属于面向对象方法的是","选项F":"","选项E":"","选项D":"过程调用","答案":"ABC","选项C":"类、封装","选项B":"继承、多态","选项A":"对象、消息","类型":"2-多选"},{"题干":"关于访问控制符,在同一包中可以访问的访问控制符有","选项F":"","选项E":"","选项D":"static","答案":"AC","选项C":"protected","选项B":"private","选项A":"public","类型":"2-多选"},{"题干":"Java类中关于方法以下描述正确的是（  ）。","选项F":"","选项E":"","选项D":"方法中的参数至少要定义1个","答案":"AB","选项C":"方法如果没有返回值，则需要使用null来声明","选项B":"方法如果没有返回值，则返回类型需要声明为void","选项A":"方法中的参数根据业务的需要可以不定义","类型":"2-多选"},{"题干":"以下属于Integer的内部类IntegerCache的静态变量有","选项F":"","选项E":"","选项D":"static final Integer caches[]","答案":"ABC","选项C":"static final Integer cache[]","选项B":"static final int high","选项A":"static final int low = -128","类型":"2-多选"},{"题干":"内部类可以方便将存在一定逻辑关系的类组织在一起，又可以对外界隐藏","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"封装就是把对象的属性和操作（或服务）结合为一个独立的整体，并尽可能隐藏对象的内部实现细节","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"抽象就是从具体事物抽出、概括出它们共同的方面、本质属性与关系等，而将个别的、非本质的方面、属性与关系舍弃","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"匿名内部类是唯一一种没有构造器的类","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"同一个类的多个实例，他们的引用类型成员使用同一个存储地址。","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"同一个类的所有实例方法存储在同一区域","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Stream 自己不会存储元素","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Java 8 没有内置了Base64 编码的编码器和解码器","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"int类型自动装箱成Integer类型调用Integer类中的valueOf(int i)方法实现","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Integer类型自动拆箱为int类型调用Integer类中的intValue()方法实现","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"}]