[{"题干":"关于反射，正确的说法是以下选项中的哪个？","选项F":"","选项E":"","选项D":"强调测试期","答案":"A","选项C":"强调编码时","选项B":"强调编译时","选项A":"强调运行时","类型":"1-单选"},{"题干":"反射的英文写法是","选项F":"","选项E":"","选项D":"Parameter","答案":"B","选项C":"Serializable","选项B":"Reflection","选项A":"react","类型":"1-单选"},{"题干":"Class.forName(\"com.mmcro.reflection.MyClsField\") 的返空对象的类型是","选项F":"","选项E":"","选项D":"Field","答案":"B","选项C":"Object","选项B":"Class","选项A":"MyClsField","类型":"1-单选"},{"题干":"下列代码返回的内容是\nClass\u00A0c1\u00A0=\u00A0XXXXX；\nreturn\u00A0\u00A0c1.getInterfaces();","选项F":"","选项E":"","选项D":"c1的方法","答案":"B","选项C":"c1的父类","选项B":"c1的所有接口","选项A":"c1的一个接口","类型":"1-单选"},{"题干":"关于静态绑定描述正确的是","选项F":"","选项E":"","选项D":"在测试的时候知道哪个方法属于哪个类","答案":"C","选项C":"在编译的时候知道哪个方法属于哪个类","选项B":"在编码的时候就已经知道哪个方法属于哪个类","选项A":"在运行的时候就知道哪个方法属于哪个类","类型":"1-单选"},{"题干":"下列代码执行的结果是\nreturn Class.forName(\"String\");","选项F":"","选项E":"","选项D":"抛出异常：java.lang.ClassNotFoundException: String","答案":"D","选项C":"返回空","选项B":"获得一个String类型对象","选项A":"获得一个Class对象","类型":"1-单选"},{"题干":"利用反射机制动态调用函数的的方法是","选项F":"","选项E":"","选项D":"getDeclaredMethod","答案":"A","选项C":"execute","选项B":"getMethod","选项A":"invoke","类型":"1-单选"},{"题干":"getDeclaredMethods不能反射得到的方法是","选项F":"","选项E":"","选项D":"公有方法","答案":"B","选项C":"静态方法","选项B":"继承于的父类方法","选项A":"私有方法","类型":"1-单选"},{"题干":"反射机制不能利用getMethods得到的方法是","选项F":"","选项E":"","选项D":"实例方法","答案":"A","选项C":"静态方法","选项B":"继承于的父类方法","选项A":"私有方法","类型":"1-单选"},{"题干":"关于invoke说法正确的是","选项F":"","选项E":"","选项D":"不能直接调用私有函数","答案":"D","选项C":"不能调用执行静态方法","选项B":"不能有返回值","选项A":"不能传递参数","类型":"1-单选"},{"题干":"Java中通过Class的以下哪个方法，获取类的加载器","选项F":"","选项E":"","选项D":"getModify();","答案":"C","选项C":"getClassLoader();","选项B":"newInstance();","选项A":"getSuperclass();","类型":"1-单选"},{"题干":"Java中，对象名.getDeclaredFields()返回类型为","选项F":"","选项E":"","选项D":"Queue","答案":"C","选项C":"Array","选项B":"Map","选项A":"List","类型":"1-单选"},{"题干":"Java中通过反射技术,打破封装能够采用的方法是","选项F":"","选项E":"","选项D":"setAccessible(\"false\");","答案":"A","选项C":"setAccessible(\"true\");","选项B":"setAccessible(false);","选项A":"setAccessible(true);","类型":"1-单选"},{"题干":"在Java中如何获取一个类的字节码文件对象( )","选项F":"","选项E":"","选项D":"其他说法都正确","答案":"C","选项C":"Class类中的forName()方法","选项B":"类名.getClass()","选项A":"对象名.class","类型":"1-单选"},{"题干":"在Java中反射技术中，返回所有具有public属性的构造函数数组的方法是","选项F":"","选项E":"","选项D":"getDeclaredConstructors()","答案":"B","选项C":"getDeclaredConstructor(Class[] params)","选项B":"Constructor getConstructors()","选项A":"getConstructor(Class[] params)","类型":"1-单选"},{"题干":"在Java中反射技术中，返回所有具有public属性的方法数组","选项F":"","选项E":"","选项D":"getDeclaredMethods()","答案":"A","选项C":"getDeclaredMethod(String name, Class[] params)","选项B":"getMethod(String name, Class[] params)","选项A":"getMethods()","类型":"1-单选"},{"题干":"在Java中反射技术中，返回具有public属性的成员变量的数组","选项F":"","选项E":"","选项D":"getDelcaredField()","答案":"A","选项C":"getDeclaredField(String name)","选项B":"getField(String name)","选项A":"getFields()","类型":"1-单选"},{"题干":"在Java中反射技术中，返回该类中的所有的方法数组（不分public和非public属性）","选项F":"","选项E":"","选项D":"getDeclaredMethods()","答案":"D","选项C":"getDeclaredMethod(String name, Class[] params)","选项B":"getMethod(String name, Class[] params)","选项A":"getMethods()","类型":"1-单选"},{"题干":"在Java中反射技术中,返回该类中所有的构造函数数组（不分public和非public属性）","选项F":"","选项E":"","选项D":"getDeclaredConstructors()","答案":"D","选项C":"getDeclaredConstructor(Class[] params)","选项B":"Constructor getConstructors()","选项A":"getConstructor(Class[] params)","类型":"1-单选"},{"题干":"在Java中反射技术中, 返回所有成员变量组成的数组（不分public和非public属性）","选项F":"","选项E":"","选项D":"getDelcaredField()","答案":"D","选项C":"getDeclaredField(String name)","选项B":"getField(String name)","选项A":"getFields()","类型":"1-单选"},{"题干":"Java反射机制能做些什么","选项F":"","选项E":"","选项D":"在运行时调用任意一个对象的方法","答案":"ABCD","选项C":"在运行时判断任意一个对象所属的类","选项B":"在运行时判断任意一个类所具有的成员变量和方法","选项A":"在运行时构造任意一个类的对象","类型":"2-多选"},{"题干":"关于instanceof说法正确的是","选项F":"","选项E":"","选项D":"判断两个对象是不是属于同一个类","答案":"AB","选项C":"判断某个对象是不是由某个类创建构造的","选项B":"（str   instanceof Object)中只要str不为空就为真","选项A":"判断一个对象是不是属于某个类","类型":"2-多选"},{"题干":"生成一个对象的方式有","选项F":"","选项E":"","选项D":"new","答案":"ABCD","选项C":"反序列化","选项B":"克隆","选项A":"newInstance（）","类型":"2-多选"},{"题干":"获取类的方式有","选项F":"","选项E":"","选项D":"[类名].newInstance();","答案":"ABC","选项C":"[对象].getClass","选项B":"[类名].class","选项A":"Class.forName()","类型":"2-多选"},{"题干":"反射机制可以做下列哪些事情","选项F":"","选项E":"","选项D":"动态测试","答案":"AB","选项C":"动态生成文档","选项B":"动态调用方法","选项A":"动态生成对象","类型":"2-多选"},{"题干":"Java中，以下通过反射获取构造方法不正确的是","选项F":"","选项E":"","选项D":"Class clazz = Person.class.getConstructor();","答案":"AD","选项C":"Constructor cons = Person.class.getConstructor();","选项B":"Constructor[] cons = Person.class.getDeclaredConstructors();","选项A":"Constructor[] cons = Person.class.getDeclaredConstructor();","类型":"2-多选"},{"题干":"以下方法哪些是在Class中定义的","选项F":"","选项E":"","选项D":"getFullName()","答案":"ABC","选项C":"getName()","选项B":"getDeclaredAnnotation()","选项A":"getConstructors()getConstructors()","类型":"2-多选"},{"题干":"Java中那些是反射常用的方法","选项F":"","选项E":"","选项D":"getDeclaredFields()","答案":"ABCD","选项C":"getInterfaces();","选项B":"getSimpleName();","选项A":"getSuperClass();","类型":"2-多选"},{"题干":"利用Java反射技术可以获取以下哪些选项","选项F":"","选项E":"","选项D":"公有方法","答案":"ABCD","选项C":"构造函数","选项B":"私有属性","选项A":"私有方法","类型":"2-多选"},{"题干":"在JAVA中关于反射机制提供的功能描述正确的有","选项F":"","选项E":"","选项D":"在运行时获取类的子类","答案":"ABC","选项C":"运行时构造任意一个类的对象","选项B":"运行时判断任意一个类所具有的成员变量和方法","选项A":"运行时调用任意一个对象的方法","类型":"2-多选"},{"题干":"没有办法利用反射机制调用一个类的私有方法","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"可以利用反射机制获取注解","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"可以利用反射机制动态调用构造器","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"RTTI就是Runtime Type Information，意思是运行时类型信息","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"不能利用反射机制修改final修饰的变量的值","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Java反射机制只能够获取方法、属性、接口","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"通过反射技术，打破封装的方法与私有属性的操作是setAccessable(true)","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Java反射中，Class对象的newInstance()方法可以获取类实例。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Class对象的getDeclaredFields()方法只可获所有public级别的属性，包括继承过来的所有属性。","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Java反射中，调用的方法是getInterfaces();可以获取该类都实现了哪些接口，","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"}]