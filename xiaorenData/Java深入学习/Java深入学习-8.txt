[{"题干":"hashMap的初始容量是","选项F":"","选项E":"","选项D":"32","答案":"C","选项C":"16","选项B":"4","选项A":"2","类型":"1-单选"},{"题干":"hashMap的默认加载因子是","选项F":"","选项E":"","选项D":"125%","答案":"B","选项C":"80%","选项B":"75%","选项A":"50%","类型":"1-单选"},{"题干":"hashMap的数据存储形式是","选项F":"","选项E":"","选项D":"哈希桶的数组","答案":"D","选项C":"二叉树","选项B":"链表","选项A":"key-value数组","类型":"1-单选"},{"题干":"java中，关于HashMap和Hashtable说法，正确的解释是什么？","选项F":"","选项E":"","选项D":"没有太大区别","答案":"C","选项C":"Hashtable\u00A0比HashMap安全","选项B":"为了安全，应该彻底放弃使用HashMap，而使用HashTable","选项A":"Hashtable效率高于HashMap","类型":"1-单选"},{"题干":"关于LinkeList 和ArrayList说法正确的是","选项F":"","选项E":"","选项D":"LinkList线程安全","答案":"A","选项C":"ArrayList线程安全","选项B":"ArrayList插入效率高","选项A":"LinkeList插入效率高","类型":"1-单选"},{"题干":"ArrayList 的初始容量是","选项F":"","选项E":"","选项D":"32","答案":"B","选项C":"16","选项B":"10","选项A":"8","类型":"1-单选"},{"题干":"ArrayList 的默认加载因子","选项F":"","选项E":"","选项D":"120%","答案":"C","选项C":"100%","选项B":"75%","选项A":"50%","类型":"1-单选"},{"题干":"java中的hashMap 每次扩容后是原来的多少倍？","选项F":"","选项E":"","选项D":"约400%","答案":"C","选项C":"约200%","选项B":"约150%","选项A":"约75%","类型":"1-单选"},{"题干":"ArrayList 每次扩容后是原来的多少倍？","选项F":"","选项E":"","选项D":"约400%","答案":"B","选项C":"约200%","选项B":"约150%","选项A":"约75%","类型":"1-单选"},{"题干":"LinkeList什么时候扩容？","选项F":"","选项E":"","选项D":"达到容量的100%","答案":"A","选项C":"达到容量的75%","选项B":"达到容量的50%","选项A":"没有扩容机制","类型":"1-单选"},{"题干":"下列数据有序的是","选项F":"","选项E":"","选项D":"TreeMap","答案":"D","选项C":"Hashtable","选项B":"HashMap","选项A":"ArrayList","类型":"1-单选"},{"题干":"阅读以下代码，关于语句的作用是（    ）。\nVector\u00A0 MyVector = new\u00A0 Vector(80,10);","选项F":"","选项E":"","选项D":"创建一个向量类对象MyVector，有80个元素的空间，若空间使用完时，以10个元素空间单位递增","答案":"D","选项C":"创建一个数组类对象MyVector，有80个元素的空间，若空间使用完时，以10个元素空间单位递增","选项B":"创建一个向量类对象MyVector，有80个元素的空间，每个元素的初值为10","选项A":"创建一个数组类对象MyVector，有80个元素的空间，每个元素的初值为10","类型":"1-单选"},{"题干":"定义在Math类中的round(double d)方法的返回类型是","选项F":"","选项E":"","选项D":"int","答案":"B","选项C":"float","选项B":"long","选项A":"short","类型":"1-单选"},{"题干":"定义在Math类中的round(float f)方法的返回类型是","选项F":"","选项E":"","选项D":"int","答案":"D","选项C":"float","选项B":"long","选项A":"short","类型":"1-单选"},{"题干":"以下关于String类的代码的执行结果是\nString s1 =\u00A0new\u00A0String(\"bjsxt\");\nString s2 =\u00A0new\u00A0String(\"bjsxt\");\nif\u00A0(s1 == s2)\nSystem.out.println(\"s1 == s2\");\nif\u00A0(s1.equals(s2))\nSystem.out.println(\"s1.equals(s2)\");","选项F":"","选项E":"","选项D":"没有正确选项","答案":"B","选项C":"s1 == s2\n\ns1.equals(s2)","选项B":"s1.equals(s2)","选项A":"s1 == s2","类型":"1-单选"},{"题干":"以下代码运行的结果是:\n public static void main(String[] args) {\n        StringBuffer a = new StringBuffer(\"A\");\n        StringBuffer b = new StringBuffer(\"B\");\n        mb_operate(a, b);\n        System.out.println(a + \".\" + b);\n    }\n\n    static void mb_operate(StringBuffer x, StringBuffer y) {\n        x.append(y);\n        y = x;\n    }","选项F":"","选项E":"","选项D":"AB.B","答案":"D","选项C":"AB.AB","选项B":"A.A","选项A":"A.B","类型":"1-单选"},{"题干":"以下代码运行结果是:\nString s1= new String(\"pb_java_OOP_T5\");\nString s2 = s1.substring(s1.lastIndexOf(\"_\"));\nSystem.out.println(\"s2=\"+s2);","选项F":"","选项E":"","选项D":"编译出错","答案":"C","选项C":"s2=_T5","选项B":"s2=_OOP_T5","选项A":"s2=_java_OOP_T5","类型":"1-单选"},{"题干":"对于语句String s=\"my name is kitty\"，以下选项中可以从其中截取”kitty”的是","选项F":"","选项E":"","选项D":"s.substring(12)","答案":"AB","选项C":"s.substring(12,17)","选项B":"s.substring(11)","选项A":"s.substring(11,16)","类型":"1-单选"},{"题干":"以下代码执行的结果是:\n  public static void main(String[] args) {\n\n        Integer aa=new Integer(5);\n        Integer bb=new Integer(6);\n        mb_num(aa,bb);\n        System.out.println(\"aa=\"+aa+\",bb=\"+bb);\n    }\n\n  \n    static void mb_num(Integer c,Integer d){\n        Integer temp=c;\n        c=d;\n        d=temp;\n    }","选项F":"","选项E":"","选项D":"aa=6,bb=6","答案":"A","选项C":"aa=5,bb=5","选项B":"aa=6,bb=5","选项A":"aa=5,bb=6","类型":"1-单选"},{"题干":"File类中的（  ）方法可以用来判断文件或目录是否存在","选项F":"","选项E":"","选项D":"fileExists()","答案":"B","选项C":"fileExist()","选项B":"exists()","选项A":"exist()","类型":"1-单选"},{"题干":"在Java中，以下File类的方法中（  ）用来判断是否是目录","选项F":"","选项E":"","选项D":"getPath( )","答案":"C","选项C":"isDirectory( )","选项B":"getFile( )","选项A":"isFile( )","类型":"1-单选"},{"题干":"java集合类主要包含以下哪些？","选项F":"","选项E":"","选项D":"heap","答案":"ABC","选项C":"Set","选项B":"List","选项A":"Map","类型":"2-多选"},{"题干":"数据不能重复的有","选项F":"","选项E":"","选项D":"DelayQueue","答案":"AB","选项C":"vector","选项B":"TreeSet","选项A":"HashSet","类型":"2-多选"},{"题干":"下列属于Set接口的函数有","选项F":"","选项E":"","选项D":"isEmpty","答案":"ABCD","选项C":"size","选项B":"clear","选项A":"addAll","类型":"2-多选"},{"题干":"在集合类中下列数据有序的是","选项F":"","选项E":"","选项D":"SortedMap","答案":"ABCD","选项C":"TreeMap","选项B":"TreeSet","选项A":"SortedSet","类型":"2-多选"},{"题干":"属于ArrayList方法的有","选项F":"","选项E":"","选项D":"subList()","答案":"ABCD","选项C":"iterator()","选项B":"remove( )","选项A":"size()","类型":"2-多选"},{"题干":"Collection和 Collections的区别错误的说法有","选项F":"","选项E":"","选项D":"Collections是针对Collection集合操作的工具类","答案":"ABC","选项C":"List、Set、Map都继承自Collection接口","选项B":"Collection是针对Collections集合操作的工具类","选项A":"Collections是集合顶层接口","类型":"2-多选"},{"题干":"下列哪些是List集合的遍历方式","选项F":"","选项E":"","选项D":"get()和length()方法结合实现","答案":"ABC","选项C":"get()和size()方法结合实现","选项B":"增强for循环实现","选项A":"Iterator迭代器实现\u00A0","类型":"2-多选"},{"题干":"执行javac Body.java产生的class文件有（）\npublic class Body { //外部类\n\n    //成员内部类\n     class Heart{\n\n    }\n}","选项F":"","选项E":"","选项D":"Body#Heart.class","答案":"AB","选项C":"Heart.class","选项B":"Body.class","选项A":"Body$Heart.class","类型":"2-多选"},{"题干":"以下Java代码中在本类中或者在外部类文件中创建Heart类对象的方式正确的有：\npublic class Body { //外部类\n\n  \n    //成员内部类\n     class Heart {\n\n        public void jump() {\n            System.out.println(\"心脏噗通噗通的跳\");\n        }\n    }\n}","选项F":"","选项E":"","选项D":"Heart bh = new Heart();","答案":"ABCD","选项C":"Body.Heart bh = new Body.Heart();","选项B":"Body.Heart bh = new Body().new Heart();","选项A":"Body body = new Body();\n Body.Heart heart = body.new Heart();","类型":"2-多选"},{"题干":"关于Vector类以下描述错误的是","选项F":"","选项E":"","选项D":"增删快","答案":"BCD","选项C":"底层采用链表实现","选项B":"线程不同步","选项A":"线程同步","类型":"2-多选"},{"题干":"迭代器Iterator是一个接口","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"HashMap类实现Map接口","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"ArrayList 的 iterator  与 LinkList的iterator是同一个类","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"TreeSet 是基于TreeMap 实现的","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"JDK1.8 的HashMap 用到了红黑树","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Integer.parseInt()的作用是将一个整数转变成String","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"执行语句String\u00A0str=\"abcedf\";\u00A0int\u00A0len=str.length;\u00A0后，能够得到字符串的长度是6","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"运算符“==”用于比较引用时，如果两个引用指向内存同一个对象，则返回true","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"在使用File类中的delete( )方法时，删除时可能文件不存在，所以我们最好先判断一下是否存在，不然会出现NullPointerException异常","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"求x的y次方，其表达式为：Math.pow(x,y)","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"}]