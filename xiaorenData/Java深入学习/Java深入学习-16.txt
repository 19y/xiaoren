[{"题干":"ThreadPoolExecutor 构造函数corePoolSize含义是","选项F":"","选项E":"","选项D":"线程池中保持线程的数量","答案":"D","选项C":"最多可以有多少个线程可以同时运行","选项B":"线程池任务的数量","选项A":"线程池的容量","类型":"1-单选"},{"题干":"ThreadPoolExecutor 构造函数maximumPoolSize含义是什么","选项F":"","选项E":"","选项D":"线程池中保持线程的数量","答案":"A","选项C":"最多可以有多少个线程可以同时运行","选项B":"线程池任务的数量","选项A":"线程池的容量","类型":"1-单选"},{"题干":"ThreadPoolExecutor\u00A0构造函数keepAliveTime含义是什么","选项F":"","选项E":"","选项D":"多余空闲线程的存活时间","答案":"D","选项C":"线程执行任务的时间","选项B":"线程池的存活时间","选项A":"空闲线程存活时间","类型":"1-单选"},{"题干":"ThreadPoolExecutor线程池的默认拒绝策略是下列选项中的哪个","选项F":"","选项E":"","选项D":"CallerRunsPolicy：由调用线程处理该任务","答案":"A","选项C":"DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）","选项B":"DiscardPolicy：丢弃任务，但是不抛出异常。","选项A":"AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。","类型":"1-单选"},{"题干":"ThreadPoolExecutor的 execute()作用是","选项F":"","选项E":"","选项D":"创建新的线程;","答案":"C","选项C":"向线程池提交任务，交由线程池去执行 无返回结果。","选项B":"开始执行一个任务。","选项A":"向线程池提交任务，交由线程池去执行，有任务执行的结果","类型":"1-单选"},{"题干":"ThreadPoolExecutor 中workQueue说法正确的是","选项F":"","选项E":"","选项D":"用来存放所有任务","答案":"B","选项C":"用存放执行完成的任务","选项B":"用来存放等待执行的任务","选项A":"用来存放正在执行的任务","类型":"1-单选"},{"题干":"关于volatile说法不正确的是","选项F":"","选项E":"","选项D":"不一定保证线程安全","答案":"A","选项C":"不一定保证原子性","选项B":"去掉了优化","选项A":"修饰的变量能保证线程安全","类型":"1-单选"},{"题干":"关于线程同步的理解正确的是","选项F":"","选项E":"","选项D":"多个线程随机运行","答案":"B","选项C":"多个线程按照给定的顺序执行","选项B":"多个线程协调运行","选项A":"多个线程同时运行","类型":"1-单选"},{"题干":"被synchronized\u00A0关键字修饰的方法特点是","选项F":"","选项E":"","选项D":"在同一时刻可能有多个进程能执行该方法","答案":"C","选项C":"在同一时刻一个进程中只能有一个线程执行该方法","选项B":"只有一个线程能执行该方法","选项A":"只有一个进程能执行该方法","类型":"1-单选"},{"题干":"关于ReentrantLock说法正确的是","选项F":"","选项E":"","选项D":"是非公平锁","答案":"A","选项C":"是公平锁","选项B":"不需要手动释放","选项A":"是重入锁","类型":"1-单选"},{"题干":"关于ThreadLocal说法正确的是","选项F":"","选项E":"","选项D":"修饰后的变量被线程共享","答案":"A","选项C":"基本类型和引用类型都可以修饰","选项B":"只能修饰基本类型","选项A":"只能修饰引用类型","类型":"1-单选"},{"题干":"线程同步中，对象的锁在（\u00A0\u00A0\u00A0\u00A0\u00A0）情况下持有的线程释放锁","选项F":"","选项E":"","选项D":"其他选项都是","答案":"D","选项C":"当持有锁的线程调用该对象的wait()方法时","选项B":"当在synchronized()语句块执行中出现例外（exception）时","选项A":"当synchronized()语句块执行完后","类型":"1-单选"},{"题干":"在多个线程访问同一个资源时，可以使用（   ）关键字来实现线程同步，保证对资源安全访问","选项F":"","选项E":"","选项D":"static","答案":"A","选项C":"yield","选项B":"transient","选项A":"synchronized","类型":"1-单选"},{"题干":"Java中线程安全问题是通过关键字（ ）解决的","选项F":"","选项E":"","选项D":"notify","答案":"A","选项C":"wait","选项B":"transient","选项A":"synchronized","类型":"1-单选"},{"题干":"Java线程中wait()方法描述错误的是","选项F":"","选项E":"","选项D":"wait(100) 单位毫秒 超时自动不被唤醒，必须等待notify()唤醒","答案":"D","选项C":"wait(100) 单位毫秒 超时自动被唤醒","选项B":"wait()调用后，释放调用wait对象的线程锁","选项A":"java.lang.Object类里的非静态方法","类型":"1-单选"},{"题干":"Java线程中notify() 方法描述错误的是","选项F":"","选项E":"","选项D":"notify()调用后，通知所有线程锁下wait()，继续往下执行","答案":"D","选项C":"notifyAll()调用后，通知所有线程锁下wait()，继续往下执行","选项B":"notify()调用后，通知同一个线程锁下wait()，继续往下执行","选项A":"java.lang.Object类里的非静态方法","类型":"1-单选"},{"题干":"Java线程中join()方法描述错误的是","选项F":"","选项E":"","选项D":"main{ a.start();b.start();a.join();}\n      main线程先开启了A,B线程，b线程执行受a.join影响的","答案":"D","选项C":"main{ a.start();b.start();a.join();}\n      main线程先开启了A,B线程，B线程执行不受a.join影响的 \n      只是说主线程等待A执行完再执行，B线程是独立的不受影响的","选项B":"a.join() 等待a线程执行完毕再接着执行a.join()所在的线程","选项A":"Thread类里的非静态方法","类型":"1-单选"},{"题干":"Java线程中interrupt()方法描述错误的是","选项F":"","选项E":"","选项D":"thread.interrupt();//设置中断标志位为true","答案":"C","选项C":"Thread的静态方法","选项B":"抛出InterruptedException 清除中断标志位","选项A":"Thread的非静态方法","类型":"1-单选"},{"题干":"Java线程中yield()方法描述错误的是","选项F":"","选项E":"","选项D":"线程在 this.start()准备执行—>就绪状态-->run()运行就是运行状态","答案":"C","选项C":"Thread的非静态方法","选项B":"线程 从运行状态--到就绪状态","选项A":"Thread的静态方法","类型":"1-单选"},{"题干":"关于wait()和sleep()方法的不同点描述错误的有","选项F":"","选项E":"","选项D":"wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用","答案":"A","选项C":"wait()方法导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的notify()方法（或notifyAll()方法）时才能唤醒等待池中的线程进入等锁池（lock pool），如果线程重新获得对象的锁就可以进入就绪状态。","选项B":"sleep()方法让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，但是对象的锁依然保持，休眠结束后线程会自动回到就绪状态;","选项A":"sleep()，wait()属于Object类中的方法","类型":"1-单选"},{"题干":"关于sleep()方法和yield()方法的不同点描述错误的有","选项F":"","选项E":"","选项D":"sleep()方法不需要声明抛出异常，而yield()方法需要抛出异常","答案":"D","选项C":"sleep()方法比yield()方法（跟操作系统CPU调度相关）具有更好的可移植性","选项B":"sleep()方法需要声明抛出InterruptedException，而yield()方法没有声明任何异常","选项A":"线程执行sleep()方法后转入阻塞（blocked）状态，而执行yield()方法后转入就绪（ready）状态","类型":"1-单选"},{"题干":"ThreadPoolExecutor线程池的拒绝策略有","选项F":"","选项E":"","选项D":"CallerRunsPolicy：由调用线程处理该任务","答案":"ABCD","选项C":"DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）","选项B":"DiscardPolicy：丢弃任务，但是不抛出异常。","选项A":"AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。","类型":"2-多选"},{"题干":"关于Callable说法正确的是","选项F":"","选项E":"","选项D":"支持泛型","答案":"AD","选项C":"是线程池","选项B":"是个抽象类","选项A":"是个接口","类型":"2-多选"},{"题干":"Future接口的作用有","选项F":"","选项E":"","选项D":"取消执行任务","答案":"ABCD","选项C":"获取线程执行结果","选项B":"等待线程执行结果","选项A":"查看异步计算是否执行完成","类型":"2-多选"},{"题干":"synchronized关键字可以修饰的内容有","选项F":"","选项E":"","选项D":"基本类型变量","答案":"ABC","选项C":"实例化后的引用类型的属性","选项B":"实例方法","选项A":"类方法","类型":"2-多选"},{"题干":"使用ReentrantLock需要注意的事项有","选项F":"","选项E":"","选项D":"需要判断获得锁是否成功","答案":"ABCD","选项C":"需要先获得锁再使用","选项B":"需要手动释放，尤其是在异常处理的时候","选项A":"需要实例化一个对象","类型":"2-多选"},{"题干":"以下说法中关于线程通信的说法正确的有","选项F":"","选项E":"","选项D":"wait()、notify()、notifyAll()是Object类提供的方法，子类可以重写","答案":"ABC","选项C":"wait()有多个重载的方法，可以指定等待的时间","选项B":"wait()、notify()、notifyAll()必须在synchronized方法或者代码块中使用","选项A":"可以调用wait()、notify()、notifyAll()三个方法实现线程通信","类型":"2-多选"},{"题干":"在Java中以下属于多线程编程的概念的有","选项F":"","选项E":"","选项D":"线程控制：挂起、停止和恢复","答案":"ABCD","选项C":"线程死锁","选项B":"线程间通信","选项A":"线程同步","类型":"2-多选"},{"题干":"在Java中关于多线程的使用说法正确的有","选项F":"","选项E":"","选项D":"通过对多线程的使用，可以编写出非常高效的程序","答案":"ABCD","选项C":"如果你创建了太多的线程，CPU 花费在上下文的切换的时间将多于执行程序的时间","选项B":"如果你创建太多的线程，程序执行的效率实际上是降低了，而不是提升了","选项A":"有效利用多线程的关键是理解程序是并发执行而不是串行执行的","类型":"2-多选"},{"题干":"在Java中以下可以创建一个线程的方式有","选项F":"","选项E":"","选项D":"通过实现 Thread接口","答案":"ABC","选项C":"通过 Callable 和 Future 创建线程","选项B":"通过继承 Thread 类本身","选项A":"通过实现 Runnable 接口","类型":"2-多选"},{"题干":"以下关于线程中Thread中的sleep(100)方法的说法正确的有","选项F":"","选项E":"","选项D":"释放所在线程锁","答案":"ABC","选项C":"不释放所在线程锁","选项B":"睡眠时间毫秒","选项A":"Thread类里的静态方法","类型":"2-多选"},{"题干":"ThreadPoolExecutor 一共有四个构造函数，但是最终都是使用的同一个构造函数进行构造。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"线程并发就是线程同步","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Java当中提供了多种线程同步方法","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Thread.sleep 与 wait（） 作用完全一样","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"notify 和notifyAll 作用没有区别","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"进程是线程Thread内部的一个执行单元，它是程序中一个单一顺序控制流程","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Thread类实现了Runnable接口","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"线程可以用yield使低优先级的线程运行","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Thread.sleep( )方法调用后，当等待时间未到，该线程所处状态为阻塞状态。当等待时间已到，该线程所处状态为运行状态","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"notify是唤醒所在对象wait pool中的第一个线程","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"}]