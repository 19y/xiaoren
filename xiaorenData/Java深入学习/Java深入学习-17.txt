[{"题干":"数据被频繁的访问和修改的情况下，应该使用哪种锁？","选项F":"","选项E":"","选项D":"公平锁","答案":"B","选项C":"轻量级锁","选项B":"悲观锁","选项A":"乐观锁","类型":"1-单选"},{"题干":"悲观锁得含义是","选项F":"","选项E":"","选项D":"在读取数据的时候，认为其他线程不会修改数据","答案":"B","选项C":"在写数据之前，认为其他线程不会修改数据","选项B":"在读取数据的时候，认为其他线程会修改数据","选项A":"在写数据之前，认为其他线程会修改数据","类型":"1-单选"},{"题干":"能够释放锁对象的是","选项F":"","选项E":"","选项D":"创建新的线程;","答案":"C","选项C":"当前线程执行结束","选项B":"线程执行run函数","选项A":"线程执行start函数","类型":"1-单选"},{"题干":"关于notifyAll说法正确的是","选项F":"","选项E":"","选项D":"当前线程结束","答案":"B","选项C":"通知一个等待该对象的线程","选项B":"通知所有的等待该对象的线程","选项A":"所有等待该对象的线程都会进入运行状态","类型":"1-单选"},{"题干":"关于ReadWriteLock的特点说法错误的是","选项F":"","选项E":"","选项D":"自旋冲突","答案":"D","选项C":"读读不冲突","选项B":"写读冲突","选项A":"写写冲突","类型":"1-单选"},{"题干":"下列使用了分段锁的集合类是","选项F":"","选项E":"","选项D":"ArrayList","答案":"B","选项C":"HashTable","选项B":"ConcurrentHashMap","选项A":"HashMap","类型":"1-单选"},{"题干":"避免死锁的办法不可行的是","选项F":"","选项E":"","选项D":"使用轻量级别锁","答案":"D","选项C":"打破循环等待条件，实行资源有序分配策略","选项B":"打破占有且申请条件","选项A":"打破互斥条件","类型":"1-单选"},{"题干":"关于ReentrantLock说法不正确的是","选项F":"","选项E":"","选项D":"是分段锁","答案":"D","选项C":"是重入锁","选项B":"可以实现是非公平锁","选项A":"可以实现公平锁","类型":"1-单选"},{"题干":"ReentrantLock默认实现的是锁是","选项F":"","选项E":"","选项D":"是分段锁","答案":"B","选项C":"读写锁","选项B":"是非公平锁","选项A":"是公平锁","类型":"1-单选"},{"题干":"关于CAS的说法正确的是","选项F":"","选项E":"","选项D":"CAS操作彻底解决了ABA问题","答案":"B","选项C":"悲观锁的一种实现办法","选项B":"乐观锁的一种实现办法","选项A":"是 Compare and Swap 的缩写，仅仅java中能实现","类型":"1-单选"},{"题干":"关于Java中线程控制方法的说法正确的是","选项F":"","选项E":"","选项D":"setDaemon( )的作用是将指定的线程设置成后台线程","答案":"D","选项C":"yield ( ) 的作用是使线程停止运行一段时间，将处于阻塞状态","选项B":"sleep ( ) 的作用是让当前正在执行线程暂停，线程将转入就绪状态","选项A":"join ( ) 的作用是不能阻塞线程","类型":"1-单选"},{"题干":"在多线程的开发中关于线程优先级说法正确的是","选项F":"","选项E":"","选项D":"线程的优先级的范围在1-10之间","答案":"D","选项C":"在创建线程后的任何时候都可以重新设置","选项B":"线程的优先级是最小值是0","选项A":"线程的优先级是不能改变的","类型":"1-单选"},{"题干":"在多线程处理中，不可以导致线程不能运行的有","选项F":"","选项E":"","选项D":"挂起及由于I/O操作而阻塞","答案":"D","选项C":"休眠","选项B":"阻塞","选项A":"等待","类型":"1-单选"},{"题干":"以下关于多线程的说法中错误的是","选项F":"","选项E":"","选项D":"线程A中执行线程B的join()方法，则线程A等待直到B执行完成","答案":"C","选项C":"在Java的多线程编程中没有安全问题","选项B":"在多线程处理中，高优先级的可运行线程会抢占低优先级线程","选项A":"如果线程死亡，它便不能运行","类型":"1-单选"},{"题干":"在Java中不能创建一个线程的方式是","选项F":"","选项E":"","选项D":"通过实现 Thread接口","答案":"D","选项C":"通过 Callable 和 Future 创建线程","选项B":"通过继承 Thread 类本身","选项A":"通过实现 Runnable 接口","类型":"1-单选"},{"题干":"在Thread类中的sleep(100)方法的说法错误的是","选项F":"","选项E":"","选项D":"释放所在线程锁","答案":"D","选项C":"不释放所在线程锁","选项B":"睡眠时间毫秒","选项A":"Thread类里的静态方法","类型":"1-单选"},{"题干":"关于线程通信的说法错误的有","选项F":"","选项E":"","选项D":"wait()、notify()、notifyAll()是Object类提供的方法，子类可以重写","答案":"D","选项C":"wait()有多个重载的方法，可以指定等待的时间","选项B":"wait()、notify()、notifyAll()必须在synchronized方法或者代码块中使用","选项A":"可以调用wait()、notify()、notifyAll()三个方法实现线程通信","类型":"1-单选"},{"题干":"在常用的集合类中属于线程安全的类有","选项F":"","选项E":"","选项D":"LinkedList","答案":"B","选项C":"ArrayList","选项B":"Hashtable","选项A":"HashMap","类型":"1-单选"},{"题干":"那个关键字可以对对象加互斥锁","选项F":"","选项E":"","选项D":"notify","答案":"A","选项C":"wait","选项B":"transient","选项A":"synchronized","类型":"1-单选"},{"题干":"使当前线程进入阻塞状态，直到被唤醒的方法是","选项F":"","选项E":"","选项D":"notify()方法","答案":"D","选项C":"ruspend()方法","选项B":"wait()方法","选项A":"resume()方法","类型":"1-单选"},{"题干":"线程通信的方式有","选项F":"","选项E":"","选项D":"管道","答案":"ABCD","选项C":"wait/notify","选项B":"while轮询","选项A":"同步","类型":"2-多选"},{"题干":"死锁产生的必要条件有","选项F":"","选项E":"","选项D":"请求和保持","答案":"ABCD","选项C":"循环等待","选项B":"不可剥夺","选项A":"互斥","类型":"2-多选"},{"题干":"乐观锁的实现方式有","选项F":"","选项E":"","选项D":"ReentrantLock","答案":"AB","选项C":"synchronized","选项B":"版本号","选项A":"CAS","类型":"2-多选"},{"题干":"悲观锁的实现方式有","选项F":"","选项E":"","选项D":"ReentrantLock","答案":"CD","选项C":"synchronized","选项B":"版本号","选项A":"CAS","类型":"2-多选"},{"题干":"线程安全出现的根本原因","选项F":"","选项E":"","选项D":"使用了反射","答案":"AB","选项C":"利用了泛型","选项B":"多线程操作共享资源代码有多个语句","选项A":"存在两个或者两个以上的线程对象共享同一个资源","类型":"2-多选"},{"题干":"在线程中关于wait()和sleep()方法的不同点描述正确的有","选项F":"","选项E":"","选项D":"wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用","答案":"ABCD","选项C":"wait()方法导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的notify()方法（或notifyAll()方法）时才能唤醒等待池中的线程进入等锁池（lock pool），如果线程重新获得对象的锁就可以进入就绪状态。","选项B":"sleep()方法让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，但是对象的锁依然保持，休眠结束后线程会自动回到就绪状态;","选项A":"Thread类中的方式有sleep()。wait()属于Object类中的方法","类型":"2-多选"},{"题干":"在线程中关于sleep()方法和yield()方法的不同点描述正确的有","选项F":"","选项E":"","选项D":"sleep()方法不需要声明抛出异常，而yield()方法需要抛出异常","答案":"ABC","选项C":"sleep()方法比yield()方法（跟操作系统CPU调度相关）具有更好的可移植性","选项B":"sleep()方法需要声明抛出InterruptedException，而yield()方法没有声明任何异常","选项A":"线程执行sleep()方法后转入阻塞（blocked）状态，而执行yield()方法后转入就绪（ready）状态","类型":"2-多选"},{"题干":"关于线程Thread常用的方法描述正确的有","选项F":"","选项E":"","选项D":"isAlive(): 判断一个线程是否存活","答案":"ABCD","选项C":"wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁","选项B":"yeild(): 线程让步，暂停当前正在执行的线程对象让出CPU资源，将当前线程从运行状态转换到就绪状态并执行其他优先级相同或更高的线程；","选项A":"join():  让一个线程等待另一个线程完成才继续执行","类型":"2-多选"},{"题干":"关于同步代码块和同步方法的说法描述正确的有","选项F":"","选项E":"","选项D":"使用同步代码块(同步代码块可以传入任意对象)","答案":"ABCD","选项C":"如果一个类中需要使用到多个锁，为了避免锁的冲突，必然需要使用不同的对象，这时候同步方法不能满足需求","选项B":"对于实例的同步方法，因为只能使用this来作为同步锁","选项A":"两者的区别主要体现在同步锁上面","类型":"2-多选"},{"题干":"在线程通信中使用到的方法有","选项F":"","选项E":"","选项D":"wait(long timeout)","答案":"ABCD","选项C":"notifyAll()","选项B":"notify()","选项A":"wait()","类型":"2-多选"},{"题干":"volatile保证变量对各个线程的可见和原子性","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"synchronized就是一种独占锁 ，也是悲观锁","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"所有的独占锁都是悲观锁","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"ReentrantLock可以实现等待可中断、可以实现公平锁，可以绑定多个条件","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"ReentrantLock 需要与 wait（）和notify（）以及notifyAll以及配合使用","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"在Java的多线程处理中存在安全问题","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"线程调度是对处于可运行状态的多个线程对象进行系统级的协调，防止多个线程争用有限资源而导致系统死机或者崩溃","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"java线程的调度策略是基于线程优先级的抢先式调度,意思就是谁的优先级高那我就先给谁使用系统资源","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"在Java中启动一个线程是调用run()方法","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"wait()和notify()属于Thread类自身的方法","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"}]