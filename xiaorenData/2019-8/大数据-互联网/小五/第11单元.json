{"data":[{"题干":"下列对于JPA的注解Query的属性描述正确的是","选项D":"当设置nativeQuery的属性是true的时候，此时nativeQuery支持直接的sort参数查询","知识点":"缺省知识点","答案":"A","选项C":"当设置nativeQuery的属性是false的时候，此时nativeQuery不支持直接的sort参数查询","选项B":"nativeQuery属性的值默认是true","选项A":"当nativeQuery属性的值是true的话表示value属性的值可以是原生的SQL","类型":"1-单选"},{"题干":"下列是JPA的注解@Query的用法，错误的是","选项D":"@Query分页直接用Page对象接收接口，参数直接用Pageable的实现类即可。","知识点":"缺省知识点","答案":"A","选项C":"@Query在JPQL下想实现排序，直接用PageRequest或者直接用Sort参数都可以","选项B":"在@query注解中 当使用Like查询的时候条件字段不会自动的加上%","选项A":"该注解声明在Repository类上","类型":"1-单选"},{"题干":"下列是对JPA的注解@Id的描述，正确的是的是","选项D":"使用@Id的实体类必须实现Serializable","知识点":"缺省知识点","答案":"A","选项C":"@Id表示外部类的联合主键","选项B":"@Id定义在实体类上","选项A":"@Id定义的属性是数据库的主键，一个实体里边必须有一个","类型":"1-单选"},{"题干":"下列给定的JPA的注解当中可以定义主键的生成策略的是","选项D":"@GeneratedValue","知识点":"缺省知识点","答案":"D","选项C":"@Id","选项B":"@IdClass","选项A":"@GeneratedId","类型":"1-单选"},{"题干":"下列是关于HashSet的特性一些描述其中正确的是","选项D":"HashSet的值都存储在一个Set集合中","知识点":"缺省知识点","答案":"C","选项C":"HashSet的底层是HashMap实现的所以，HashSet中可以存储null值","选项B":"在HashSet的构造法中会初始化一个HashMap对象，因为HashMap的Value值可以重复所以HashSet的值也可以重复","选项A":"HashSet的实现是依赖自身的一套存储机制的","类型":"1-单选"},{"题干":"Java中的==和equals的区别，下列选项中说法错误的是","选项D":"equals和==其实不存在什么区别","知识点":"缺省知识点","答案":"D","选项C":"类没有覆盖equals()方法。则通过equals()比较该类的两个对象时，等价于通过\u201C==\u201D比较这两个对象。","选项B":"equals() : 它的作用也是判断两个对象是否相等","选项A":"\"==\" 的作用是判断两个对象的地址是不是相等。即判断两个对象是不是同一个对象。(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)","类型":"1-单选"},{"题干":"下列是对Spring AOP代理的一些描述其中正确的是","选项D":"Spring中使用的AOP都是静态代理","知识点":"缺省知识点","答案":"A","选项C":"Spring主要是用的是JDK的动态代理","选项B":"Spring除了可以使用JDK动态代理，其他的代理方式不合适","选项A":"Spring默认使用JDK的动态代理","类型":"1-单选"},{"题干":"Spring和Hibernate的集成下面说法错误的是","选项D":"通过Spring可以在Dao层代码中无需直接实例化DAO类，而是通过注入得到","知识点":"缺省知识点","答案":"C","选项C":"通过集成Spring和Hibernate用Spring管理程序的依赖关系将SessionFactory注入到DataSource中","选项B":"在Spring配置文件中可以通过Spring提供的LocalSessionFactoryBean来获得SessionFactory的实例","选项A":"Spring提供了HibernateDaoSupport类来简化HIbernate的使用","类型":"1-单选"},{"题干":"下列是关于AOP的理解，下列选项中正确的是","选项D":"AOP不是面向对象的替代品是面向对象很好的补充","知识点":"缺省知识点","答案":"B","选项C":"AOp的面向过程的替代品","选项B":"将项目中的公共问题集中解决，减少代码量，提高系统的可维护性","选项A":"能够降低组件之间的依赖关系","类型":"1-单选"},{"题干":"Bean在Spring中的管理的方式下列说法中正确的是","选项D":"Spring默认的利用原型模式管理Bean","知识点":"缺省知识点","答案":"B","选项C":"Spring默认的利用工厂模式管理Bean","选项B":"Bean在Spring中的管理方式有两种原型模式和单例模式","选项A":"Bean在Spring的管理方式是工厂模式和单例模式","类型":"1-单选"},{"题干":"下列关于流的选项中属于是字符流的是","选项D":"StringReader ","知识点":"缺省知识点","答案":"D","选项C":"FileReader","选项B":"FileOutputStream","选项A":"FileInputStream ","类型":"1-单选"},{"题干":"下列的流当中不属于是Java的处理流的是","选项D":"FileInputStream ","知识点":"缺省知识点","答案":"D","选项C":"InputStreamReader  ","选项B":"OutputStreamReader  ","选项A":"BufferedInputStrean ","类型":"1-单选"},{"题干":"下列的选项中的容器类属于是线程安全的有哪些","选项D":"HashMap","知识点":"缺省知识点","答案":"B","选项C":"LinkedList ","选项B":"Vector ","选项A":"Arraylist","类型":"1-单选"},{"题干":"下列是关于异常和error的描述错误的是","选项D":"Error（错误）表示运行应用程序中较严重问题，这种问题虚拟机本身可以处理，并恢复虚拟机运行","知识点":"缺省知识点","答案":"D","选项C":"NullPointerException属于是运行时异常","选项B":"Exception 类有一个重要的子类 RuntimeException。RuntimeException 类及其子类表示\u201CJVM 常用操作\u201D引发的错误","选项A":"Exception（异常）是应用程序中可能的可预测、可恢复问题","类型":"1-单选"},{"题干":"下面几组数组的复制方法中那个效率最高","选项D":"使用clone方法","知识点":"缺省知识点","答案":"B","选项C":"Array.copyof","选项B":"System.arraycopy","选项A":"for循环逐一复制","类型":"1-单选"},{"题干":"下列代码的描述正确的是 public class TestClass {    private static void testMethod(){         System.out.println(\"testMethod\");    }    public static void main(String[] args) {         ((TestClass)null).testMethod();    } }","选项D":"编译通过，运行异常，报NoSuchMethodException","知识点":"缺省知识点","答案":"B","选项C":"编译通过，运行异常，报NullPointerException","选项B":"运行正常，输出testMethod","选项A":"编译失败","类型":"1-单选"},{"题干":"下列关于构造函数何时执行描述正确的是","选项D":"使用对象的变量时","知识点":"缺省知识点","答案":"B","选项C":"调用对象方法时","选项B":"创建对象时 ","选项A":"类定义时","类型":"1-单选"},{"题干":"关于事务的四个特性中的持久性的描述正确的是","选项D":"一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。","知识点":"缺省知识点","答案":"B","选项C":"一个事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的","选项B":" 一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。","选项A":"一个事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做。","类型":"1-单选"},{"题干":"MYSQL中创建数据库表的命令是什么","选项D":"ALTER TABLE 表名","知识点":"缺省知识点","答案":"C","选项C":"Create TABLE 表名","选项B":"Create VIEW 表名","选项A":"Create database 表名","类型":"1-单选"},{"题干":"下列的HTML代码那个可以产生一个超链接","选项D":"4","知识点":"缺省知识点","答案":"C","选项C":"3","选项B":"2","选项A":"1","类型":"1-单选"},{"题干":"下列关于JPA的注解的说法正确的是","选项D":"@Entity定义对象将会成为被JPA管理的实体，将映射到指定的数据库表。","知识点":"缺省知识点","答案":"ABCD","选项C":"@Procedure用来访问存储过程","选项B":"@Modifying修改查询，如果配置了一级缓存这个时候clearAutomatically=true,就会刷新一级缓存不然在同一个接口中更新一个对象，接着查询这个对象，查出来的对象就是没有更新之前的状态","选项A":"用@Param注解指定方法参数的具体名称，通过绑定的参数名字做查询条件","类型":"2-多选"},{"题干":"下列是一些（JPA）注解的含义其中正确的是","选项D":"@Table指定数据库的表名该注解一般应用在类的构造方法上","知识点":"缺省知识点","答案":"BC","选项C":"@Column定义该属性对应数据库中的列名，当数据库的列名称和该属性名不一致时可以使用","选项B":"@Basic表示属性是到数据库表的字段的映射。如果实体的字段上没有任何注解，默认即为@Basic。","选项A":"@Transient表示该属性是一个到数据库表的字段的映射，表示持久化属性","类型":"2-多选"},{"题干":"下列是对@Cloumn注解中的属性的描述，正确的是","选项D":"length表示存储的数据的字节的长度","知识点":"缺省知识点","答案":"ABC","选项C":"inserttable执行insert操作的时候是否包含此字段，默认是true","选项B":"nullable表示字段是否为空，该属性是一个布尔类型，如果为true表示","选项A":"name表示数据库表的列明，如果不写表示字段名和实体属性名一样","类型":"2-多选"},{"题干":"下列是JPA中的关联关系的注解是","选项D":"@MoreToMore","知识点":"缺省知识点","答案":"ABC","选项C":"@ManyToOne","选项B":"@OneToMany","选项A":"@OneTOOne","类型":"2-多选"},{"题干":"下列是JPA中Repository的子接口的是","选项D":"PagingAndSortingRepository","知识点":"缺省知识点","答案":"ABC","选项C":"ReactiveCrudRepository","选项B":"RevisionRepository","选项A":"CrudRepository","类型":"2-多选"},{"题干":"以下是JPA的主键生成策略的类型描述正确的是","选项D":"GenerationType.AUTO 自动选择合适的策略，是默认选项","知识点":"缺省知识点","答案":"ABCD","选项C":"GenerationType.IDENTITY 采用数据库ID自增长，一般用于MYSQL数据库","选项B":"GenerationType.SEQUENCE通过序列产生主键","选项A":"GenerationType.TABLE通过表产生主键","类型":"2-多选"},{"题干":"下列是JPA中定义外键关联字段名称的注解@JoinCloumn，下列选项是对该注解中属性的描述正确的是","选项D":"nullable外键字段是否为空","知识点":"缺省知识点","答案":"ABCD","选项C":"unique外键是不是唯一","选项B":"referencedColumnName实体的字段名默认是本表的ID","选项A":"name目标表的字段名","类型":"2-多选"},{"题干":"下列是对Spring中的几种作用域的解释其中正确的是","选项D":"global-session\u2002：在一个全局的HTTP\u2002Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring\u2002ApplicationContext情形下有效。","知识点":"缺省知识点","答案":"ABCD","选项C":"session\u2002：在一个HTTP\u2002Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring\u2002ApplicationContext情形下有效。","选项B":"prototype\u2002：一个bean的定义可以有多个实例","选项A":"singleton\u2002:\u2002bean在每个Spring\u2002ioc\u2002容器中只有一个实例","类型":"2-多选"},{"题干":"下列是对Spring的切面可以使用的几种通知类型的描述正确的是","选项D":"around:\u2002在方法执行之前和之后调用的通知。","知识点":"缺省知识点","答案":"ABCD","选项C":"after-returning:\u2002仅当方法成功完成后执行的通知。","选项B":"after:\u2002在方法执行之后调用的通知，无论方法执行是否成功。","选项A":"before\u2002：前置通知，在一个方法执行前被调用。","类型":"2-多选"},{"题干":"下列是属于Spring的BeanFactory的实现类的是","选项D":"以上都是","知识点":"缺省知识点","答案":"AC","选项C":"FileSystemXmlApplication","选项B":"ApplicationContext","选项A":"ClassPathXmlApplicationContext","类型":"2-多选"},{"题干":"@Basic表示属性是到数据库表的字段的映射。如果实体的字段上没有任何注解，默认即为@Basic。","选项D":null,"知识点":"缺省知识点","答案":"A","选项C":null,"选项B":null,"选项A":null,"类型":"0-判断"},{"题干":"@Transient表示该属性是一个到数据库表的字段的映射，表示持久化属性","选项D":null,"知识点":"缺省知识点","答案":"B","选项C":null,"选项B":null,"选项A":null,"类型":"0-判断"},{"题干":"类可以实现很多个接口，但是只能继承一个抽象类","选项D":null,"知识点":"缺省知识点","答案":"A","选项C":null,"选项B":null,"选项A":null,"类型":"0-判断"},{"题干":"在JDK1.7中接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。","选项D":null,"知识点":"缺省知识点","答案":"A","选项C":null,"选项B":null,"选项A":null,"类型":"0-判断"},{"题干":"Java 接口中声明的变量默认都是 final 的。抽象类可以包含非 final 的变量。","选项D":null,"知识点":"缺省知识点","答案":"A","选项C":null,"选项B":null,"选项A":null,"类型":"0-判断"},{"题干":"构造方法是不能被子类重写的，但是构造方法可以重载","选项D":null,"知识点":"缺省知识点","答案":"A","选项C":null,"选项B":null,"选项A":null,"类型":"0-判断"},{"题干":"HashMap内部是通过一个数组实现的，只是这个数组比较特殊，数组里存储的元素是一个Entry实体(在JAVA8中为Node)，这个Entry实体主要包含key、value以及一个指向自身的next指针。","选项D":null,"知识点":"缺省知识点","答案":"A","选项C":null,"选项B":null,"选项A":null,"类型":"0-判断"},{"题干":"Hashtable允许键和值是null，而HashMap不允许键或者值是null。","选项D":null,"知识点":"缺省知识点","答案":"B","选项C":null,"选项B":null,"选项A":null,"类型":"0-判断"},{"题干":"Hashtable是同步(线程安全)的，而HashMap不是同步(非线程安全)。因此，HashMap更适合于单线程环境，而Hashtable适合于多线程环境","选项D":null,"知识点":"缺省知识点","答案":"A","选项C":null,"选项B":null,"选项A":null,"类型":"0-判断"},{"题干":"HashSet的实现是依赖于HashMap的，HashSet的值都是存储在HashMap中的。","选项D":null,"知识点":"缺省知识点","答案":"A","选项C":null,"选项B":null,"选项A":null,"类型":"0-判断"}],"name":"11单元"}