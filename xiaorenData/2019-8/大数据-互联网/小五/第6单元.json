{"data":[{"题干":"关于SpringCloudZuul的描述错误的是","选项D":"SpringCloudZuul对于限流不支持","知识点":"缺省知识点","答案":"D","选项C":"SpringCloudZuul可以提供动态路由的功能","选项B":"SpringCloudZuul是从设备和网站到后端应用程序所有请求的前门，为内部服务提供可配置的对外URL到服务映射关系","选项A":"SpringCloudZuul是一个微服务网关的组件","类型":"1-单选"},{"题干":"对于SpringCloudZuul的路由通配符下列说法正确的是","选项D":"？  匹配任意数量的字符","知识点":"缺省知识点","答案":"A","选项C":"\/*  匹配一个字符","选项B":"\/*  匹配任意数量的字符和路径","选项A":"\/**  匹配任意数量的字符和路径","类型":"1-单选"},{"题干":"对于以下的SpringCloudZuul的配置，说法正确的是 zuul:     routes:         client-b:             path: \/client\/**             serviceId: client-b         client-a:             path: \/client\/**             serviceId: client-a","选项D":"上述配置一个映射路径对应多个服务，按照加载顺序，最末加载的映射规则会把之前的映射规则覆盖掉","知识点":"缺省知识点","答案":"D","选项C":"该配置所有请求 \/client\/**路径的请求会均分到 client-a和client-b服务商","选项B":"上述的配置是错误的","选项A":"该配置所有请求 \/client\/**路径的请求都会映射到client-b这个服务上","类型":"1-单选"},{"题干":"关于Zuul以下那些配置可以将代理路径 \/pre 从请求路径中移除","选项D":"zuul:     prefix: \/pre         clint-a:             path: \/client-a\/**","知识点":"缺省知识点","答案":"D","选项C":"zuul:     prefix: \/pre         clint-a:             path: \/client-a\/**             stripPrefix: \/client-a","选项B":"zuul:     prefix: \/pre         clint-a:             path: \/client-a\/**             stripPrefix: \/pre","选项A":"zuul:     prefix: \/pre         clint-a:             path: \/client-a\/**             stripPrefix: false","类型":"1-单选"},{"题干":"下列关于SpringCloudZuul限流的说法正确的是","选项D":"上面的说法都是错误的","知识点":"缺省知识点","答案":"A","选项C":"限流并不能保护我们的系统免受雪崩之灾","选项B":"限流实质上是有损我们的后台服务效率的，限流对我们来说没有好处","选项A":"限流可以防止过多的请求或者是异常的请求击垮我们的后台服务","类型":"1-单选"},{"题干":"下面一段代码的运行结果 public class Test {   public int aMethod() {       static int i = 0;  \/\/错误的语法       i++;       return i;   }   public static void main (String args[]) {       Test test = new Test();       test.aMethod();       int j = test.aMethod();       System.out.println(j);   } }","选项D":"编译失败","知识点":"缺省知识点","答案":"D","选项C":"2","选项B":"1","选项A":"0","类型":"1-单选"},{"题干":"一下的选项的描述说法是正确的","选项D":"实例方法可直接调用超类的类方法  `有可能是私有方法不可以调用`","知识点":"缺省知识点","答案":"C","选项C":"实例方法可直接调用本类的类方法","选项B":"实例方法可直接调用其他类的实例方法 `不可以`","选项A":"实例方法可直接调用超类的实例方法  ` 如果超类没有被重写就可以`  ","类型":"1-单选"},{"题干":"下面关于Servlet的处理请求的方式说法正确的是","选项D":"以程序的方式","知识点":"缺省知识点","答案":"B","选项C":"以响应的方式","选项B":"以线程的方式  Servlet容器默认是采用单实例多线程的方式处理多个请求的","选项A":"以进程的方式","类型":"1-单选"},{"题干":"下列是JDBC中用于标识数据库连接的对象是","选项D":"Connection  建立与数据库的连接 ","知识点":"缺省知识点","答案":"D","选项C":"DriverManager  该方法将建立与数据库的连接 ","选项B":"PreparedStatement","选项A":"Statement  连接的实例，执行sql","类型":"1-单选"},{"题干":"如下代码当Float对象在第11行被创建后, 什么时候能够被垃圾回收 10. public Object m() { 11.   Object o = new Float(3.14F); 12.   Object [] oa = new Object[1]; 13.   oa[0] = o; 14.   o = null; 15.   oa[0] = null; 16.   print 'return 0'; 17. }","选项D":"16行以后","知识点":"缺省知识点","答案":"C","选项C":"15行以后","选项B":"14行以后","选项A":"13行以后","类型":"1-单选"},{"题干":"下列哪个方法在Servlet的生命周期中只会被调用一次","选项D":"destroy","知识点":"缺省知识点","答案":"B","选项C":"getServletConfig","选项B":"init","选项A":"service","类型":"1-单选"},{"题干":"下列有关Java引用的说法正确的是","选项D":"一个对象只能被一个引用所指引","知识点":"缺省知识点","答案":"B","选项C":"引用就是对象本身","选项B":"引用本身是Primitive（原始数据）","选项A":"引用实际上就是指针","类型":"1-单选"},{"题干":"在一个线程中Sleep（1000）方法，将使得该线程在多少时间后获得对CPU的控制（假设睡眠过程中不会有其他事件唤醒该线程）？","选项D":"不一定","知识点":"缺省知识点","答案":"C","选项C":" =>1000毫秒 1000ms之后","选项B":"1000毫秒不到","选项A":"正好1000毫秒","类型":"1-单选"},{"题干":"关于下面的语句运行后输出的什么? System.out.println(4&7);","选项D":"8","知识点":"缺省知识点","答案":"A","选项C":"7","选项B":"5","选项A":"4","类型":"1-单选"},{"题干":"如下代码的执行结果是： public static void main(String[] args) throws Exception {       Thread t = new Thread(){           public void run(){               pong();           }       };       t.run(); \/\/只是调用线程的run方法，还在当前线程执行       System.out.println(\"pppp\");     }      static void pong(){         System.out.println(\"qqqq\");     }   ","选项D":"都不输出","知识点":"缺省知识点","答案":"B","选项C":"ppppqqqq和qqqqpppp都有可能","选项B":"qqqqpppp","选项A":"ppppqqqq","类型":"1-单选"},{"题干":"下列那个流类是字符输入流","选项D":"BufferedWriter","知识点":"缺省知识点","答案":"A","选项C":"FileInputStream","选项B":"ObjectInputStream","选项A":"InputStreamReader","类型":"1-单选"},{"题干":"ArrayList list = new ArrayList(40);中的list扩充几次","选项D":"3","知识点":"缺省知识点","答案":"A","选项C":"2 ","选项B":"1","选项A":"0","类型":"1-单选"},{"题干":"选项中哪一行代码可以替换题目中\/\/this  code而不产生编译错误？ public abstract class MyClass {       public int constInt = 5;      \/\/this  code      public void method() {      } }","选项D":"public abstract void anotherMethod() {}","知识点":"缺省知识点","答案":"C","选项C":"public abstract void method(int a); ","选项B":"public int method(); ","选项A":"constInt = constInt + 5; ","类型":"1-单选"},{"题干":"下面的接口类中那个是不属于集合体系的","选项D":"java.util.Hashtable","知识点":"缺省知识点","答案":"B","选项C":"java.util.Vector","选项B":"java.util.Collections","选项A":"java.util.Map","类型":"1-单选"},{"题干":"以下哪个最准确描述synchronized关键字?","选项D":"保证在某时刻只有一个线程可访问方法或对象；  ","知识点":"缺省知识点","答案":"D","选项C":"允许两线程并行运行，而且互相通信；  ","选项B":" 保证允许两个或更多处理同时开始和结束；  ","选项A":"保证两个或更多线程同时开始和结束。","类型":"1-单选"},{"题干":"下列属于SpringCloudZuul的通配符的是","选项D":"=","知识点":"缺省知识点","答案":"ABC","选项C":"?","选项B":"\/*","选项A":"\/**","类型":"2-多选"},{"题干":"下列属于SpringCloudZuul的通配符的是","选项D":"=","知识点":"缺省知识点","答案":"ABC","选项C":"?","选项B":"\/*","选项A":"\/**","类型":"2-多选"},{"题干":"下列属于SpringCloudZuul的通配符的是","选项D":"=","知识点":"缺省知识点","答案":"ABC","选项C":"?","选项B":"\/*","选项A":"\/**","类型":"2-多选"},{"题干":"利用SpringCloudZuul我们可以完成的功能，下列选项中包含的是","选项D":"鉴权","知识点":"缺省知识点","答案":"ABCD","选项C":"灰度发布","选项B":"动态路由","选项A":"限流","类型":"2-多选"},{"题干":"下列哪些选项可以正确的声明一个一维数组","选项D":"String a[10]","知识点":"缺省知识点","答案":"AB","选项C":"char a[][]","选项B":"String a[]","选项A":"String [] a","类型":"2-多选"},{"题干":"下面哪几项在编译时候，会出现错误提示？","选项D":"int a=Integer.parseInt('a');","知识点":"缺省知识点","答案":"ACD","选项C":"int a=int('我');","选项B":"int a=(int)'我';  ","选项A":"int a=Integer.parseInt(abc789);","类型":"2-多选"},{"题干":"下列的选项中错误的是","选项D":"java函数支持重载，但函数必须至少有一个参数或返回值的类型不同或个数不同","知识点":"缺省知识点","答案":"ABCD","选项C":" java函数的参数传递规定，所有的原始类型（如整数）和对象（使用new来创建的）都为地址传递。 ","选项B":"判断一个对象是否可以被垃圾回收的条件为是否还有对该对象的引用。 ","选项A":"用New运算符来创建的对象，在JVM退出时才会被做垃圾回收。 ","类型":"2-多选"},{"题干":"下面是ArrayList和Vector的区别期中那个是错误的","选项D":"ArrayList底层是数组结构，Vector底层是链表结构 ","知识点":"缺省知识点","答案":"ACD","选项C":" ArrayList底层是数组结构，Vector底层是链表结构 ","选项B":"ArrayList是线程不安全的，Vector是线程安全的","选项A":"ArrayList是线程安全的，Vector是线程不安全 ","类型":"2-多选"},{"题干":"下面是对于HashMap集合说法错误的是","选项D":"不可以存储null值和null键","知识点":"缺省知识点","答案":"ABD","选项C":" 可以存储null值和null键 ","选项B":"底层是数组结构","选项A":"底层是链表结构 ","类型":"2-多选"},{"题干":"Java中的集合类包括ArrayList、LinkedList、HashMap等类，下列关于集合类描述正确的是","选项D":"HashMap实现Map接口，它允许任何类型的键和值对象，并允许将null用作键或值","知识点":"缺省知识点","答案":"ABD","选项C":" 添加和删除元素时，ArrayList的表现更佳 ","选项B":"ArrayList的查询速度比LinkedList快  ","选项A":"ArrayList和LinkedList均实现了List接口 ","类型":"2-多选"},{"题干":"SpringCloudZuul网关不支持重试","选项D":null,"知识点":"缺省知识点","答案":"B","选项C":null,"选项B":null,"选项A":null,"类型":"0-判断"},{"题干":"Zuul的核心逻辑是一系列紧密配合工作的Filter实现的","选项D":null,"知识点":"缺省知识点","答案":"A","选项C":null,"选项B":null,"选项A":null,"类型":"0-判断"},{"题干":"SpringCloudZuul可以实现限流的功能","选项D":null,"知识点":"缺省知识点","答案":"A","选项C":null,"选项B":null,"选项A":null,"类型":"0-判断"},{"题干":"Zuul的内部默认使用Ribbon来远程调用服务","选项D":null,"知识点":"缺省知识点","答案":"A","选项C":null,"选项B":null,"选项A":null,"类型":"0-判断"},{"题干":"默认情况下因为Zuul是使用Ribbon来调用远程服务的但是默认Zuul上下文是饥饿加载的","选项D":null,"知识点":"缺省知识点","答案":"B","选项C":null,"选项B":null,"选项A":null,"类型":"0-判断"},{"题干":"SpringCloudZuul的底层实现是Filter","选项D":null,"知识点":"缺省知识点","答案":"A","选项C":null,"选项B":null,"选项A":null,"类型":"0-判断"},{"题干":"下面程序能正常运行 public static void haha(){         System.out.println(\"haha\");     }     public static void main(String[] args) {         ((EncodeDemo)null).haha();     }","选项D":null,"知识点":"缺省知识点","答案":"A","选项C":null,"选项B":null,"选项A":null,"类型":"0-判断"},{"题干":"在编译Java源程序时，计算机根本不会去识别各个变量名的具体含义，因此命名规范对编写 Java程序而言不是必要的。","选项D":null,"知识点":"缺省知识点","答案":"B","选项C":null,"选项B":null,"选项A":null,"类型":"0-判断"},{"题干":"Java语言中，类的成员变量在整个类内都有效，其有效性与它在类体中的位置无关，方法中的局部变量的有效性与它在方法体中的位置无关。","选项D":null,"知识点":"缺省知识点","答案":"B","选项C":null,"选项B":null,"选项A":null,"类型":"0-判断"},{"题干":"不论是否捕捉到异常try{}catch ){} finaly{}语句中finally块中的代码总要被执行。","选项D":null,"知识点":"缺省知识点","答案":"A","选项C":null,"选项B":null,"选项A":null,"类型":"0-判断"}],"name":"6单元"}