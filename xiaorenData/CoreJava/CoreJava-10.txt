[{"题干":"关于java构造方法，以下描述错误的是（\u00A0\u00A0）。","选项F":"","选项E":"","选项D":"一个类中不显式写出构造方法时，会有一个默认的构造方法","答案":"C","选项C":"构造方法的返回类型是void","选项B":"构造方法不能声明返回类型","选项A":"构造方法名与类名完全相同","类型":"1-单选"},{"题干":"如果希望成员变量只能在本类中访问，应当使用的访问修饰符是（  ）。","选项F":"","选项E":"","选项D":"protected","答案":"A","选项C":"public","选项B":"default","选项A":"private","类型":"1-单选"},{"题干":"Java语言中访问控制修饰符从小到大依次为（  ）。","选项F":"","选项E":"","选项D":"default<protected<private<public","答案":"B","选项C":"defaul<private<protected<public","选项B":"private<default<protected<public","选项A":"private<protected<default<public","类型":"1-单选"},{"题干":"大数据-下列关于this关键字，以下说法错误的是（  ）。","选项F":"","选项E":"","选项D":"在类里面使用this关键字，可以调用本类里的成员变量","答案":"A","选项C":"在类里面使用this关键字，可以调用本类里的构造器","选项B":"在类里面使用this关键字，可以调用本类里的方法","选项A":"不能通过this关键调用构造器","类型":"1-单选"},{"题干":"public class A {\n    public void run() {}\n}\npublic class B extends A {\n}\npublic class TestClass {\n    public static void main(String[] args) {\n        A a = new A();\n        B b = new B();\n    }\n}\n关于以上代码，下列描述错误的是","选项F":"","选项E":"","选项D":"A类是B类的子类","答案":"D","选项C":"a对象拥有run()方法","选项B":"B类是A类的子类","选项A":"b对象拥有run()方法","类型":"1-单选"},{"题干":"下列方法定义中，方法头错误的是（\u00A0\u00A0）。","选项F":"","选项E":"","选项D":"public\u00A0int\u00A0x(){…}","答案":"B","选项C":"void\u00A0x(double\u00A0d){…}","选项B":"public\u00A0static\u00A0x(double\u00A0a){…}","选项A":"public\u00A0static\u00A0int\u00A0x(double\u00A0y){…}","类型":"1-单选"},{"题干":"在Java语言中，哪种包中的类是自动导入的","选项F":"","选项E":"","选项D":"java.lang","答案":"D","选项C":"java.io","选项B":"java.sql","选项A":"java.util","类型":"1-单选"},{"题干":"在定义成员变量时，如果访问修饰符为protected则该变量的访问范围是（  ）。","选项F":"","选项E":"","选项D":"本包+不同包的子类","答案":"D","选项C":"所有包","选项B":"本包","选项A":"本类","类型":"1-单选"},{"题干":"关于Java中类的继承以下说法错误的是（  ）。","选项F":"","选项E":"","选项D":"在定义类时如果使用了final进行修饰，则该类不能被继承","答案":"B","选项C":"一个类可以有多个子类","选项B":"一个类可以有多个父类","选项A":"一个类只能有一个父类","类型":"1-单选"},{"题干":"以下代码的输出结果是（  ）。\nint a=1;\nwhile(a<5){\nswitch(a){\ncase 0:\ncase 3:a=a+1;\ncase 1:\ncase 2:a=a+2;\n}\n}\nSystem.out.print(a);","选项F":"","选项E":"","选项D":"6","答案":"D","选项C":"5","选项B":"4","选项A":"2","类型":"1-单选"},{"题干":"如下员工类User有几个构造器。\npublic class User { \n    private String name;\n    private int age;\n    public static int ncount = 81;\n\n    public User(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n}","选项F":"","选项E":"","选项D":"4","答案":"B","选项C":"2","选项B":"1","选项A":"0","类型":"1-单选"},{"题干":"大数据-阅读以下代码，分析代码，输出的结果是______。\nint a [] = new int [5] ;     \nSystem.out.println(++ a[3]) ;","选项F":"","选项E":"","选项D":"5","答案":"B","选项C":"3","选项B":"1","选项A":"0","类型":"1-单选"},{"题干":"java面向对象中，继承需要使用到哪个关键字","选项F":"","选项E":"","选项D":"implements","答案":"C","选项C":"extends","选项B":"static","选项A":"final","类型":"1-单选"},{"题干":"如果想设置对象的属性在外部访问时只能读取而不能修改，以下选项中代码正确的是（\u00A0\u00A0）。","选项F":"","选项E":"","选项D":"class�Person{�public�int�age;�public�int�getAge()�{�return�age;�}�public�void�setAge(int�age)�{�this.age�=�age;�}�}","答案":"C","选项C":"class�Person{�private�int�age;�public�int�getAge()�{�return�age;�}�}","选项B":"class�Person{�private�int�age;�public�int�getAge()�{�return�age;�}�public�void�setAge(int�age)�{�this.age�=�age;�}�}","选项A":"class�Person{�public�int�age;�public�int�getAge()�{�return�age;�}�}","类型":"1-单选"},{"题干":"大数据-在定义成员变量时，如果访问修改符为protected则该变量的访问范围为（\u00A0\u00A0）。","选项F":"","选项E":"","选项D":"本包","答案":"B","选项C":"所有包","选项B":"本包+不同包的子类","选项A":"本类","类型":"1-单选"},{"题干":"大数据-下列代码是调用父类构造器的是（  ）。","选项F":"","选项E":"","选项D":"new super()","答案":"A","选项C":"super.say(\"小王\");","选项B":"super.say();","选项A":"super(\"小王\");","类型":"1-单选"},{"题干":"大数据-如果希望成员变量只能在本类中访问，应当使用的访问修饰符是（\u00A0\u00A0）。","选项F":"","选项E":"","选项D":"public","答案":"A","选项C":"protected","选项B":"protected","选项A":"private","类型":"1-单选"},{"题干":"以下关于this关键字，以下说法错误的是（\u00A0\u00A0）。","选项F":"","选项E":"","选项D":"不能通过this关键调用构造器","答案":"D","选项C":"在类里面使用this关键字，可以调用本类里的成员变量","选项B":"在类里面使用this关键字，可以调用本类里的构造器","选项A":"在类里面使用this关键字，可以调用本类里的方法","类型":"1-单选"},{"题干":"大数据-有一个类B，下面为其构造方法的声明，正确的是（  ）。","选项F":"","选项E":"","选项D":"B(int x) {}","答案":"D","选项C":"b(int x){}","选项B":"void B(int x) {}","选项A":"void b(int x) {}","类型":"1-单选"},{"题干":"为了让成员变量和成员方法只能在本类中访问，需要使用的访问修饰符为（）。","选项F":"","选项E":"","选项D":"public","答案":"A","选项C":"default","选项B":"protected","选项A":"private","类型":"1-单选"},{"题干":"在定义成员变量时，如果访问修改符为protected则该变量的访问范围为（）。","选项F":"","选项E":"","选项D":"本包+不同包的子类","答案":"D","选项C":"所有包","选项B":"本包","选项A":"本类","类型":"1-单选"},{"题干":"下面关于构造方法的说法中，正确的是（）。","选项F":"","选项E":"","选项D":"Java中构造方法的方法名可以自己定义，只要符合标识符命名规范就行。","答案":"A","选项C":"Java规定构造方法没有返回值，可以用void声明","选项B":"Java中构造方法不可以重载","选项A":"Java中的构造方法名必须和类名相同","类型":"1-单选"},{"题干":"下列关于static关键字的使用，说法正确的是：","选项F":"","选项E":"","选项D":"static修饰的方法称为静态方法。","答案":"ABCD","选项C":"static修饰的属性称为静态属性。","选项B":"static修饰的方法称为类方法。","选项A":"static修饰的属性称为类属性。","类型":"2-多选"},{"题干":"大数据-以下语句是正确的Java导包语句的是（  ）。","选项F":"","选项E":"","选项D":"import java.io.File","答案":"CD","选项C":"import java.io.*","选项B":"include java.io.File;","选项A":"include java.*;","类型":"2-多选"},{"题干":"以下关于包的作用说法正确的有（  ）。","选项F":"","选项E":"","选项D":"方便扩展","答案":"AB","选项C":"有助于压缩文件大小","选项B":"避免命名冲突","选项A":"易于管理文件","类型":"2-多选"},{"题干":"关于导包的场景，以下选项说方错误的有（）。","选项F":"","选项E":"","选项D":"如果想要访问含有以private修饰的属性、方法的类时需要导包","答案":"BCD","选项C":"只有访问jdk中提供的类时才需要导包，自定义的类即使在不同包中相互访问也不需要导包","选项B":"A类在com.bawei.a 包中，B类在com.bawei包中相互访问不需要导包","选项A":"同一包中的类互相不需要导包","类型":"2-多选"},{"题干":"以下关于重写的描述，正确的有（  ）。","选项F":"","选项E":"","选项D":"重写只针对方法而言，不针对属性来说","答案":"ABD","选项C":"重写时，修饰符不能发生改变","选项B":"重写的好处是增加代码的灵活性","选项A":"重写时，方法的修饰符不能比继承过来此方法时更严格","类型":"2-多选"},{"题干":"对以下代码描述正确的是\npublic class Student {\n    public String school;\n    public static String team;\n// 省略setter、getter方法\n}\npublic class Main {\n    public static void main(String[] args) {\n        Student p1 = new Student();\n        Student p2 = new Student();\n        p1.setSchool(\"八维\");\n        p2.setTeam(\"Core Java\");\n    }\n}","选项F":"","选项E":"","选项D":"p2.getTeam();\u00A0取到的值为：Core\u00A0Java","答案":"BCD","选项C":"p1.getTeam();\u00A0取到的值为：Core\u00A0Java","选项B":"p1.getSchool();\u00A0取到的值为：八维","选项A":"p2.getSchool();\u00A0取到的值为：八维","类型":"2-多选"},{"题干":"下列关于super关键字，哪几个说法是正确的？","选项F":"","选项E":"","选项D":"在类里面使用super关键字，可以调用父类里的属性","答案":"CD","选项C":"在类里面使用super关键字，可以调用父类里的构造器","选项B":"在类里面使用super关键字，可以调用本类里的方法","选项A":"不能通过super关键调用构造器","类型":"2-多选"},{"题干":"大数据-关于构造方法，以下描述正确的是（\u00A0\u00A0）。","选项F":"","选项E":"","选项D":"一个类中不显式写出构造方法时，会有一个默认的构造方法","答案":"ACD","选项C":"构造方法不能声明返回类型","选项B":"构造方法的返回类型是void","选项A":"构造方法名与类名完全相同","类型":"2-多选"},{"题干":"在重写过程中，子类方法有哪些必须和父类方法相同（  ）。","选项F":"","选项E":"","选项D":"参数","答案":"CD","选项C":"名称","选项B":"修饰符","选项A":"返回值","类型":"2-多选"},{"题干":"大数据-关于Java中的类继承以下说法正确的是（  ）。","选项F":"","选项E":"","选项D":"在定义类时如果使用了final进行修饰，则该类不能被继承","答案":"ACD","选项C":"一个类可以有多个子类","选项B":"一个类可以有多个父类","选项A":"一个类只能有一个父类","类型":"2-多选"},{"题干":"大数据-下列方法定义中，方法头正确的有（  ）。","选项F":"","选项E":"","选项D":"public int x(){…}","答案":"ABD","选项C":"public static x(double a){…}","选项B":"void x(double d){…}","选项A":"public static int x(double y){…}","类型":"2-多选"},{"题干":"访问权限最小的是default。","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"如果java修饰的属性或方法只可以被本类中使用，应选择private修饰符","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"java面向对象中，继承需要使用到的关键字是implements。","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"子类不可以继承父类的构造方法。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Java 源程序文件编译后产生的文件称为字节码文件,其扩展名为.class。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"}]