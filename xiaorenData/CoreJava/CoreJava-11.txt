[{"题干":"ublic\u00A0class\u00A0Count\u00A0{\n\u00A0\u00A0\u00A0\u00A0int\u00A0i=5;\n\u00A0\u00A0\u00A0\u00A0public\u00A0int\u00A0add1(int\u00A0i)\u00A0{\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0return\u00A0i+i;\n\u00A0\u00A0\u00A0\u00A0}\n\n\u00A0\u00A0\u00A0\u00A0public\u00A0int\u00A0add2(int\u00A0i)\u00A0{\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0return\u00A0i;\n\u00A0\u00A0\u00A0\u00A0}\n\u00A0\u00A0\u00A0\u00A0public\u00A0int\u00A0add3(int\u00A0i)\u00A0{\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0return\u00A0i\u00A0+\u00A0add2(i);\n\u00A0\u00A0\u00A0\u00A0}\n\n\u00A0\u00A0\u00A0\u00A0public\u00A0int\u00A0add4(int\u00A0i)\u00A0{\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0return\u00A0i+4;\n\u00A0\u00A0\u00A0\u00A0}\n}\n以下信息描述正确的是：：","选项F":"","选项E":"","选项D":"给add4方法不管传入的数字为几，返回的结果值都为9。","答案":"A","选项C":"给add1方法传入参数为数字10时，返回的结果值为15。","选项B":"add3方法编写有误。","选项A":"给add2方法传入参数为数字7时，返回的结果值为7。","类型":"1-单选"},{"题干":"哪个是错误的继承和对象转型的说法？","选项F":"","选项E":"","选项D":"Object是所有类的父类","答案":"A","选项C":"定义类时如果没有明确指定父类，则默认继承Object类","选项B":"所有类型的对象都可以转成Object类型的对象","选项A":"所有的父类对象都可以通过转型转成子类对象","类型":"1-单选"},{"题干":"public\u00A0class\u00A0A\u00A0{\n\u00A0\u00A0\u00A0\u00A0public\u00A0void\u00A0run()\u00A0{}\n}\n\npublic\u00A0class\u00A0B\u00A0extends\u00A0A\u00A0{\n}\n\npublic\u00A0class\u00A0Test\u00A0{\n\u00A0\u00A0\u00A0\u00A0public\u00A0static\u00A0void\u00A0main(String[]\u00A0args)\u00A0{\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0A\u00A0a\u00A0=\u00A0new\u00A0A();\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0B\u00A0b\u00A0=\u00A0new\u00A0B();\n\u00A0\u00A0\u00A0\u00A0}\n}关于以上代码，下列描述错误的是：","选项F":"","选项E":"","选项D":"B类是A类的子类。","答案":"B","选项C":"b对象拥有run()方法。","选项B":"A类是B类的子类","选项A":"a对象拥有run()方法。","类型":"1-单选"},{"题干":"以下关于方法重载的说法中正确的是（  ）。","选项F":"","选项E":"","选项D":"访问权限一定相同","答案":"A","选项C":"形参列表一定相同","选项B":"返回值类型一定相同","选项A":"方法名一定相同","类型":"1-单选"},{"题干":"阅读以下代码，分析代码，选择正确选项（）\n\tpublic static void main(String[]args){\n\t\tFather f=Son.out();\n\t\tSystem.out.println(f.money);\n\t}\n------------------------------\nclass Father {\n\tprotected int money=100000;\n\tprotected static Father out(){\n\t\treturn new Father();\n\t}\n}\nclass Son extends Father{\n\tprotected int money=100;\n\tpublic static Son out(){\n\t\treturn new Son();\n\t}\n}","选项F":"","选项E":"","选项D":"输出结果：1000","答案":"C","选项C":"输出结果：100000","选项B":"输出结果：100","选项A":"程序报错","类型":"1-单选"},{"题干":"为了阻止子类重写父类中的方法，可以使用以下哪个修饰符修饰父类中的方法（  ）。","选项F":"","选项E":"","选项D":"protected","答案":"B","选项C":"const","选项B":"final","选项A":"static","类型":"1-单选"},{"题干":"3、关于重写，遵循的规则以下选项描述错误的有（\u00A0\u00A0）。","选项F":"","选项E":"","选项D":"D\u00A0\u00A0重写方法必须和被重写方法具有相同的参数列表，返回类型必须和被重写方法的返\n回类型相同或者是返回类型的子类型","答案":"A","选项C":"C\u00A0\u00A0普通方法能被重写，父类中的final方法不能被重写","选项B":"B\u00A0\u00A0重写方法的访问控制修饰符不能比被重写方法更严格","选项A":"A\u00A0\u00A0final修饰的方法可以被子类重写","类型":"1-单选"},{"题干":"java中，哪个是创建对象的关键字？","选项F":"","选项E":"","选项D":"class","答案":"A","选项C":"public","选项B":"int","选项A":"new","类型":"1-单选"},{"题干":"在Java语言中,以下哪个包时自动导入的（  ）。","选项F":"","选项E":"","选项D":"java.awt","答案":"C","选项C":"java.lang","选项B":"java.util","选项A":"java.io","类型":"1-单选"},{"题干":"数组定义不正确的是：：","选项F":"","选项E":"","选项D":"int[]a[];","答案":"C","选项C":"int[5]�a;","选项B":"int[][]�a;","选项A":"String�a[];","类型":"1-单选"},{"题干":"下列对构造方法的说法中错误的有（\u00A0\u00A0）。","选项F":"","选项E":"","选项D":"子类不能继承父类的构造器","答案":"C","选项C":"每一个类里都至少有一个无参构造方法。","选项B":"构造方法又叫构造器，它们指的是同一事物。","选项A":"每一个类里至少有一个构造方法。","类型":"1-单选"},{"题干":"java面向对象中，继承需要使用到的关键字有（\u00A0\u00A0）。","选项F":"","选项E":"","选项D":"static","答案":"B","选项C":"implements","选项B":"extends","选项A":"extend","类型":"1-单选"},{"题干":"java中，关于继承的说法，哪种说法是正确的","选项F":"","选项E":"","选项D":"如果子类从父类继承来的方法不能满足子类的需要，子类可以重写该方法","答案":"D","选项C":"子类不能继承父类的方法","选项B":"子类只能继承父类的方法，而不能重写父类的方法","选项A":"子类中不能定义和父类中同名的成员变量","类型":"1-单选"},{"题干":"以下关于方法重写的说法错误的是（  ）。","选项F":"","选项E":"","选项D":"方法重写实际上是在子类中重写从父类中继承来的方法","答案":"C","选项C":"返回值类型一定相同","选项B":"形参列表一定相同","选项A":"方法名一定相同","类型":"1-单选"},{"题干":"java数组描述正确的是","选项F":"","选项E":"","选项D":"数组中可以存放不同的数据类型","答案":"C","选项C":"数组类中有排序的方法sort()","选项B":"数组类中有求长度的方法length()","选项A":"数组长度定义后可以改变","类型":"1-单选"},{"题干":"下面关于构造方法的说法，正确的是（\u00A0\u00A0\u00A0\u00A0\u00A0）：","选项F":"","选项E":"","选项D":"Java语言规定构造方法没有返回值，可以用void声明","答案":"B","选项C":"类的私有方法也可以被其他类直接访问","选项B":"Java中的构造方法名必须和类名相同","选项A":"Java语言中构造方法不可以重载","类型":"1-单选"},{"题干":"下列不属于构造方法作用的是","选项F":"","选项E":"","选项D":"初始化属性值","答案":"C","选项C":"声明对象","选项B":"创建实例","选项A":"开辟内存空间","类型":"1-单选"},{"题干":"以下对转型描述错误的是（  ）。","选项F":"","选项E":"","选项D":"父类对象如果是通过子类实例化的，则可以通过此子类进行强转","答案":"A","选项C":"父类对象如果是通过父类实例化的，则不能强转成子类对象","选项B":"子类对象一定能交给父类对象直接引用","选项A":"父类对象一定能交给子类对象直接引用","类型":"1-单选"},{"题干":"定义一个公有double型常量PAI，下列哪句是正确的：：","选项F":"","选项E":"","选项D":"public�final�static�double�PAI;","答案":"A","选项C":"public�static�double�PAI=3.14;","选项B":"public�final�double�PAI;","选项A":"public�final�static�double�PAI=3.14;","类型":"1-单选"},{"题干":"如果父类中有一个方法的访问修饰符为protected，则在子类中重写该方法时可以使用的访问修饰符有（  ）。","选项F":"","选项E":"","选项D":"public","答案":"CD","选项C":"protected","选项B":"default","选项A":"private","类型":"2-多选"},{"题干":"下列对构造方法的说法中正确的有（  ）。","选项F":"","选项E":"","选项D":"每一个类里都至少有一个无参构造方法","答案":"ABC","选项C":"子类不能继承父类的构造器","选项B":"构造方法又叫构造器，它们指的是同一事物","选项A":"每一个类里至少有一个构造方法","类型":"2-多选"},{"题干":"java中，当子类重写从父类中继承来的方法时，必须相同的部分有哪几种","选项F":"","选项E":"","选项D":"方法的返回值类型","答案":"BC","选项C":"形参列表","选项B":"方法名称","选项A":"访问修饰符","类型":"2-多选"},{"题干":"属于关键字是","选项F":"","选项E":"","选项D":"final","答案":"BCD","选项C":"public","选项B":"static","选项A":"main","类型":"2-多选"},{"题干":"以下关于构造器语法格式描述正确的是（）：","选项F":"","选项E":"","选项D":"构造器名称可以根据业务进行自定义","答案":"AC","选项C":"使用修饰符修饰，也可以省略修饰符","选项B":"构造器返回值类型必须定义为void","选项A":"构造器名必须和类名相同","类型":"2-多选"},{"题干":"以下选项中，对于包命名不规范的是（）","选项F":"","选项E":"","选项D":"com.1309a.task","答案":"ACD","选项C":"Com.Environment.Task","选项B":"com.environment.task","选项A":"com.values-object.task","类型":"2-多选"},{"题干":"有一个类B，下面为其构造方法的声明，错误的是（）","选项F":"","选项E":"","选项D":"void�B(int�x)�{}","答案":"BCD","选项C":"void�b(int�x)�{}","选项B":"b(int�x)","选项A":"B(int�x)�{}","类型":"2-多选"},{"题干":"下列不属于构造方法特点的是","选项F":"","选项E":"","选项D":"有返回值","答案":"AD","选项C":"有参数","选项B":"有修饰符","选项A":"有返回类型","类型":"2-多选"},{"题干":"以下关于重写遵循的规则描述正确的有（  ）。","选项F":"","选项E":"","选项D":"重写方法必须和被重写方法具有相同的参数列表，返回类型必须和被重写方法的返\n回类型相同或者是返回类型的子类型","答案":"BCD","选项C":"普通方法能被重写，父类中的final方法不能被重写","选项B":"重写方法的访问控制修饰符不能比被重写方法更严格","选项A":"final修饰的方法可以被子类重写","类型":"2-多选"},{"题干":"阅读以下代码，选项中正确的是（）\npublic\u00A0static\u00A0void\u00A0main(String[]\u00A0args){\n\u00A0\u00A0StringBuffer\u00A0sb\u00A0=\u00A0new\u00A0StringBuffer();\n\u00A0\u00A0sb\u00A0+= \"I\";\n\u00A0\u00A0sb.append(\" am\u00A0\");\n\u00A0\u00A0sb.append(true);\n\u00A0\u00A0System.out.println(sb);\n}","选项F":"","选项E":"","选项D":"StringBuffer对象不能使用+=赋值","答案":"AD","选项C":"代码运行结果是：I\u00A0am\u00A0true","选项B":"append方法参数只能是String类型变量","选项A":"StringBuffer构造方法中可以传入String类型变量","类型":"2-多选"},{"题干":"阅读以下代码，选项中正确的是（）\npublic\u00A0class\u00A0Test1\u00A0{\n\u00A0\u00A0\u00A0public\u00A0static\u00A0void\u00A0main(String[]\u00A0args)\u00A0{\n\u00A0\u00A0\u00A0int\u00A0a=5;\n\u00A0\u00A0\u00A0Integer\u00A0num=new\u00A0Integer(a);\n\u00A0\u00A0\u00A0int\u00A0b=num.intValue();\n\u00A0\u00A0\u00A0a++;\n\u00A0\u00A0\u00A0num++;\n\u00A0\u00A0\u00A0System.out.println(b);\n\u00A0\u00A0}\n}","选项F":"","选项E":"","选项D":"输出结果是：6","答案":"AC","选项C":"输出结果是：5","选项B":"输出结果是：7","选项A":"num是包装类Integer的对象","类型":"2-多选"},{"题干":"以下（）属于java的访问控制控制符","选项F":"","选项E":"","选项D":"protected","答案":"ACD","选项C":"public","选项B":"static","选项A":"private","类型":"2-多选"},{"题干":"以下对类的名称命名规范说法正确的是","选项F":"","选项E":"","选项D":"类名可以数字开头,但命名规范中不提倡","答案":"ABC","选项C":"类名中可以用大写或小写英文字母开头，推荐用大写字母。","选项B":"类名可以“_”开头,但命名规范中不提倡。","选项A":"类名可以以“$”开头,但命名规范中不提倡。","类型":"2-多选"},{"题干":"以下关于重载方法的说法中正确的是（\u00A0\u00A0）。","选项F":"","选项E":"","选项D":"如果两个方法是重载方法，则它们的形参列表一定相同","答案":"AB","选项C":"如果两个方法是重载方法它们的方法名一定不同","选项B":"如果两个方法是重载方法，则它们的形参列表一定不同","选项A":"如果两个方法是重载方法，它们的方法名一定相同","类型":"2-多选"},{"题干":"区分类中重载方法的依据是采用不同的参数名。","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"在方法重写过程中，子类中与父类中定义的方法名和参数个数和参数类型必须相同。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"java区分类中重载方法的依据是采用不同的形参列表。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"}]