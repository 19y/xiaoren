[{"题干":"abstract\u00A0class和interface的区别是，描述错误的是（\u00A0\u00A0\u00A0\u00A0）","选项F":"","选项E":"","选项D":"抽象类中的抽象方法的访问类型可以是public,protected和默认类型,,但接口的抽象方法只能是public,默认即为public\u00A0abstract类型","答案":"C","选项C":"抽象类和接口没有区别，两者可以混用。","选项B":"抽象类可以有构造方法,接口不可以,\u00A0抽象类可以包含静态方法,但接口不可以","选项A":"抽象类中可以有普通的成员变量,普通的非抽象方法.接口不可以","类型":"1-单选"},{"题干":"关于抽象类与接口区别的说法，以下描述错误的是（）：","选项F":"","选项E":"","选项D":"接口中不定义任何与实现相关的内容，在抽象类中可以定义具有具体实现的方法","答案":"B","选项C":"接口是对行为的抽象，如：“可以飞”\u00A0是个接口，它是对各种可飞的实体的行为的抽象","选项B":"抽象类比接口定义更灵活，可以完全代替接口","选项A":"抽象类是对实体的抽象，如交通工具就是一个抽象类，它是对各式各样的交通工具的抽象","类型":"1-单选"},{"题干":"关于抽象说法错误的是","选项F":"","选项E":"","选项D":"抽象类不能直接实例化对象","答案":"C","选项C":"抽象类，必须有抽象方法","选项B":"有抽象方法的类，需要定义为抽象类","选项A":"抽象方法不可以有{}实现","类型":"1-单选"},{"题干":"java中，接口中的成员变量可以使用的访问修饰符是（  ）。","选项F":"","选项E":"","选项D":"private","答案":"A","选项C":"default","选项B":"protected","选项A":"public","类型":"1-单选"},{"题干":"当方法不需要返回值时，方法的返回值类型应该是","选项F":"","选项E":"","选项D":"void","答案":"D","选项C":"null","选项B":"\"\"","选项A":"不写","类型":"1-单选"},{"题干":"声明抽象类和抽象方法用到的关键字是（）。","选项F":"","选项E":"","选项D":"extends","答案":"A","选项C":"interface","选项B":"class","选项A":"abstract","类型":"1-单选"},{"题干":"若有如下接口A的定义，下列哪个类下确实现了该接口？（）\ninterface\u00A0A\u00A0{\u00A0\u00A0\n    void\u00A0method1(int\u00A0i);\u00A0\n    void\u00A0method2(int\u00A0j);\u00A0\n}","选项F":"","选项E":"","选项D":"class�B�implements�A{�\npublic��void�method1(int�x�)�{�}�\npublic�void�method2(int�y�)�{�}�\n}","答案":"D","选项C":"class�B�implements�A�{�\n�void�method1(int�i�)�{�}�\n�void�method2(int�j�)�{�}�\n}","选项B":"class�B�{�\n�void�method1(int�i�)�{�}�\n�void�method2(int�j�)�{�}�\n}","选项A":"class�B�implements�A{�\n�void�method1(�)�{�}�\n�void�method2(�)�{�}�\n}","类型":"1-单选"},{"题干":"若有如下接口A的定义，下列哪个类实现了该接口（\u00A0\u00A0）\u00A0\u00A0\u00A0interface\u00A0\u00A0A\u00A0{\u00A0\u00A0void\u00A0method1(int\u00A0i);\u00A0void\u00A0method2(int\u00A0j);\u00A0}\u00A0：","选项F":"","选项E":"","选项D":"class�B�{�void�method1(int�i�)�{�}�void�method2(int�j�)�{�}�}","答案":"C","选项C":"class�B�implements�A�{public�void�method1(int�i�)�{�}�public�void�method2(int�j�)�{�}�}","选项B":"class�B�implements�A{�public�void�method1(int�x�)�{�}�}","选项A":"class�B�implements�A{�void�method1(�)�{�}�void�method2(�)�{�}�}","类型":"1-单选"},{"题干":"关于接口的定义和实现，以下描述正确的是()。","选项F":"","选项E":"","选项D":"如果一个类实现一个接口，则必须实现该接口中的所有方法，但方法不必声明为 public。","答案":"A","选项C":"如果一个接口由多个类来实现，则这些类在实现该接口中的方法时应采用统一的代码。","选项B":"接口定义中的变量都必须写明 final 和 static。","选项A":"接口定义中的方法都只有定义没有实现。","类型":"1-单选"},{"题干":"java中，以下关于接口的说法中正确的是（  ）。","选项F":"","选项E":"","选项D":"一个接口可以有多个父接口","答案":"D","选项C":"接口之间不能有继承关系","选项B":"一个类不可以实现多个接口","选项A":"一个接口只能有一个父接口","类型":"1-单选"},{"题干":"阅读以下代码，从选项中选择正确重写父类方法的选项（  ）。\nclass A {\nprotected int method1(int a, int b) { return 0; }\n}\npublic class B extends A{ \n//选项中选择...\n}","选项F":"","选项E":"","选项D":"protected int method1(int a, long b) { return 0; }","答案":"B","选项C":"protected long method1(int a, int b) { return 0; }","选项B":"public int method1(int a, int b) { return 0; }","选项A":"private int method1(int a, int b) { return 0; }","类型":"1-单选"},{"题干":"java中，正确的关于接口说法是哪个","选项F":"","选项E":"","选项D":"接口中的属性可以定义为private","答案":"C","选项C":"接口中的属性都是常量，不能修改值","选项B":"接口中的方法可以定义为private","选项A":"接口中的方法都是抽象的，所以必须显式的用abstract修饰，不能有实现","类型":"1-单选"},{"题干":"下列对于抽象类的使用描述有误的是()。","选项F":"","选项E":"","选项D":"抽象类里只可以定义常量，不可以定义普通变量。","答案":"D","选项C":"抽象类声明的对象必须依靠子类进行实例化才能使用。","选项B":"不能直接实例化抽象类","选项A":"可以使用抽象类来声明对象","类型":"1-单选"},{"题干":"下面有关接口的说法中正确的是()。","选项F":"","选项E":"","选项D":"普通类实现一个接口必须实现接口的所有方法。","答案":"D","选项C":"接口之间不能有继承关系。","选项B":"一个类不可以实现多个接口。","选项A":"接口与抽象类是相同的概念。","类型":"1-单选"},{"题干":"java中，对抽象类正确的描述是哪个","选项F":"","选项E":"","选项D":"既不能用以创建对象，也不可用来派生新类","答案":"B","选项C":"既可用以创建对象，也可用以派生新类","选项B":"只能用以派生新类，不能用以创建对象","选项A":"只能用以创建对象，不能用以派生新类","类型":"1-单选"},{"题干":"封装的目的","选项F":"","选项E":"","选项D":"私有化数据，可以保证数据的安全性","答案":"D","选项C":"代码复用","选项B":"简化代码","选项A":"所有的方法都必须是公共的方法，提供访问","类型":"1-单选"},{"题干":"下面的接口或类定义正确的是（  ）。","选项F":"","选项E":"","选项D":"public class A { \nprivate int x; \npublic getx(){ return x; } \n}","答案":"C","选项C":"public abstract class A { \nprivate int x; \npublic abstract int getx(); \npublic int amethod() { return 0; }\n}","选项B":"public class A { \nprivate int x;\npublic abstract int getx(); \n}","选项A":"public interface A { \nprivate int x;\npublic int getx() { return x; }\n}","类型":"1-单选"},{"题干":"以下对面向接口编程的说法错误的是()。","选项F":"","选项E":"","选项D":"提高可维护性降低耦合","答案":"B","选项C":"提高编程的灵活性","选项B":"增加了代码量，并且封装了具体实现，很难理解，这是语言设计的缺陷","选项A":"更加抽象 ，更加面向对象","类型":"1-单选"},{"题干":"int j=1;\nfor( int i=j++; i<3; i++){\n\tSystem.out.print(i);\n}\n输出结果是","选项F":"","选项E":"","选项D":"2","答案":"B","选项C":"234","选项B":"12","选项A":"123","类型":"1-单选"},{"题干":"java中，抽象方法的描述，哪些是正确的？","选项F":"","选项E":"","选项D":"对于抽象方法方法体可有可无","答案":"C","选项C":"抽象方法没有方法体","选项B":"abstract修饰符可修饰字段、方法和类","选项A":"抽象方法的方法体必须用一对大括号{\u00A0}包住","类型":"1-单选"},{"题干":"接口是Java面向对象的实现机制之一，以下关于接口的说法中正确的是（  ）。","选项F":"","选项E":"","选项D":"在Java中一个类可只能有一个父类，也只能实现一个接口","答案":"B","选项C":"在Java中一个类可以有多个父类，但是只能实现一个接口","选项B":"在Java中一个类可只能有一个父类，但是可以实现多个接口","选项A":"Java中一个类可以有多个父类，也可以实现多个接口","类型":"1-单选"},{"题干":"以下修饰符可用于修饰接口中的变量的有（  ）。","选项F":"","选项E":"","选项D":"abstract","答案":"BC","选项C":"final","选项B":"static","选项A":"protected","类型":"2-多选"},{"题干":"以下修饰符可以用于修饰接口中的变量的是","选项F":"","选项E":"","选项D":"abstract","答案":"BC","选项C":"final","选项B":"static","选项A":"protected","类型":"2-多选"},{"题干":"super说法错误的是：","选项F":"","选项E":"","选项D":"super代表当前类实例","答案":"BCD","选项C":"super()代表调用本类无参数构造方法","选项B":"super()和this()可以在同一个构造方法中同时使用，互不影响","选项A":"默认情况下，类的所有构造方法默认都有super(),表示默认调用父类无参数构造方法","类型":"2-多选"},{"题干":"java中，哪几种说法是错误的","选项F":"","选项E":"","选项D":"类的名字一般由大写字母开头","答案":"ABC","选项C":"构造方法不能有返回值，所以返回类型应该是void","选项B":"String[]\u00A0str;\u00A0就已经创建了数组，开辟了堆内存地址","选项A":"子类在重写继承过来的方法时，要求修饰符、返回类型、方法名称、参数列表必须和父类中的完全一样。","类型":"2-多选"},{"题干":"若有如下接口A的定义，下列哪个类没实现了该接口（\u00A0\u00A0）\u00A0\u00A0\u00A0\ninterface\u00A0\u00A0A\u00A0{\n    void\u00A0method1(int\u00A0i);\n    void\u00A0method2(int\u00A0j);\n}","选项F":"","选项E":"","选项D":"class�B�{\n    void�method1(int�i�)�{�}\n    void�method2(int�j�)�{�}\n}","答案":"ABD","选项C":"class�B�implements�A�{\n    public�void�method1(int�i�)�{�}\n    public�void�method2(int�j�)�{�}\n}","选项B":"class�B�implements�A{\n    public�void�method1(int�x�)�{�}\n}","选项A":"class�B�implements�A{\n    void�method1(�)�{�}\n    void�method2(�)�{�}\n}","类型":"2-多选"},{"题干":"访问修饰符说法正确的是：","选项F":"","选项E":"","选项D":"protected访问范围为不同包的子类","答案":"ABCD","选项C":"public任何范围可访问","选项B":"default为相同包内可访问","选项A":"private只能在本类内访问","类型":"2-多选"},{"题干":"下列代码是调用父类构造器的有（  ）。","选项F":"","选项E":"","选项D":"super.say();","答案":"AC","选项C":"super();","选项B":"super.say(\"小王\");","选项A":"super(\"小王\");","类型":"2-多选"},{"题干":"以下修饰符可以用于修饰接口中的方法的有（  ）。","选项F":"","选项E":"","选项D":"abstract","答案":"AD","选项C":"final","选项B":"static","选项A":"public","类型":"2-多选"},{"题干":"以下修饰符可以用于修饰接口中的方法的是","选项F":"","选项E":"","选项D":"abstract","答案":"AD","选项C":"final","选项B":"static","选项A":"public","类型":"2-多选"},{"题干":"下面学生类Student的构造方法正确的是：：","选项F":"","选项E":"","选项D":"Student(){}","答案":"CD","选项C":"public�Student(){}","选项B":"public�student(String�name){}","选项A":"public�void�Student(){}","类型":"2-多选"},{"题干":"java中下列对抽象类的描述正确的有（\u00A0\u00A0）。","选项F":"","选项E":"","选项D":"不能通过抽象类本身进行实例化对象","答案":"BD","选项C":"不能使用抽象类声明对象","选项B":"抽象类里面有构造器","选项A":"抽象类里面没有构造器","类型":"2-多选"},{"题干":"关于重写，遵循的规则以下选项描述正确的有（）：","选项F":"","选项E":"","选项D":"D\u00A0普通方法能被重写，父类中的final方法不能被重写。","答案":"ACD","选项C":"C\u00A0重写方法必须和被重写方法具有相同的参数列表，返回类型必须和被重写方法的返回类型相同或者是返回类型的子类型。","选项B":"B\u00A0final修饰的方法是可以被子类重写","选项A":"A\u00A0重写方法的访问控制修饰符不能比被重写方法更严格（比如一个在父类中声明为public的方法重写成一个protected的方法）","类型":"2-多选"},{"题干":"关于this说法正确的是","选项F":"","选项E":"","选项D":"this可以在成员方法中使用","答案":"BD","选项C":"this代表父类的实例","选项B":"this代表当前类的实例","选项A":"this可以在静态方法中使用","类型":"2-多选"},{"题干":"关于static说法正确的是","选项F":"","选项E":"","选项D":"静态方法可以直接使用成员变量","答案":"ABC","选项C":"静态方法可以直接使用静态变量","选项B":"静态变量被类的所有对象共享","选项A":"成员方法可以直接使用静态变量","类型":"2-多选"},{"题干":"实现接口的类不能是抽象类。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"一个类可以实现多个接口，接口可以实现“多重继承”。","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Java语言中，构造方法是可以继承的。","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"}]