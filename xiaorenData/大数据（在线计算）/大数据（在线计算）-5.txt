[{"题干":"以下代码输出结果为Array(1,2,3,4,5).map(_*2).foreach(print(_))","选项F":"","选项E":"","选项D":"246810","答案":"D","选项C":"13579","选项B":"12345","选项A":"2，4，6，8，10","类型":"1-单选"},{"题干":"定义类 Class Person（private val name: String）{},以下说法正确是？","选项F":"","选项E":"","选项D":"name是类私有字段，可以在类内部被改变","答案":"B","选项C":"name是类公有字段，有公有的getter和setter方法","选项B":"name是类私有字段，有私有的getter方法","选项A":"name是对象私有字段","类型":"1-单选"},{"题干":"scala 中，关于类和函数，以下说法错误是","选项F":"","选项E":"","选项D":"scala 中， 可以在函数中定义类","答案":"C","选项C":"scala 中， 不可以在类中定义object","选项B":"scala 中， 可以在函数中定义函数。","选项A":"scala 中， 可以在类中定义类。","类型":"1-单选"},{"题干":"下面关于override修饰符的描述错误的是？","选项F":"","选项E":"","选项D":"Scala里如果子类是抽象类则子类的同名成员不可以使用这个修饰符","答案":"D","选项C":"Scala里如果子类中并未重载或实现什么基类里的成员则禁用这个修饰符","选项B":"Scala里如果子类成员实现的是同名的抽象成员则这个修饰符是可选的","选项A":"Scala里所有重载了父类具体成员的成员都需要这样的修饰符","类型":"1-单选"},{"题干":"Scala里，final修饰符的描述正确的是？","选项F":"","选项E":"","选项D":"以上说法都是错误的","答案":"B","选项C":"类的声明上添加final修饰符确保成员只能被子类重载一次","选项B":"类的声明上添加final修饰符把整个类声明为final，这个类不能被继承","选项A":"类的声明上添加final修饰符确保成员不被子类重载","类型":"1-单选"},{"题干":"高阶函数是指？","选项F":"","选项E":"","选项D":"执行时间长的函数。","答案":"C","选项C":"函数参数为函数或返回结果为函数的函数。","选项B":"将函数作为参数，并返回结果为函数的函数。","选项A":"在程序中应该首先被定义的函数。","类型":"1-单选"},{"题干":"下列关于类和单例对象间差别的说法正确的是","选项F":"","选项E":"","选项D":"单例对象不可以继承，而类可以","答案":"B","选项C":"单例对象不可以定义私有属性，而类可以","选项B":"单例对象不可以带参数，而类可以","选项A":"单例对象不可以定义方法，而类可以","类型":"1-单选"},{"题干":"以下关于集合的说法哪个不正确","选项F":"","选项E":"","选项D":"为了顾及安全性问题，Scala仅支持不可变集合而不支持可变集合。","答案":"D","选项C":"List中的值是有先后次序的","选项B":"Map是一组(键，值)对偶。","选项A":"Set是一组没有先后次序的值。","类型":"1-单选"},{"题干":"关于scala中的类和它的伴生对象，以下说法不正确的是","选项F":"","选项E":"","选项D":"类和它的伴生对象可以互相访问私有特性","答案":"B","选项C":"类和它的伴生对象的名称必须相同","选项B":"类和它的伴生对象可以有不同的名称","选项A":"类和它的伴生对象定义在同一个文件中","类型":"1-单选"},{"题干":"以下使用scala语言，定义一个List，其中语法不正确的是？","选项F":"","选项E":"","选项D":"val list = List[String]()","答案":"C","选项C":"val list = List[String](‘a’,’b’,’c’)","选项B":"val list = List[Int](1,2,3)","选项A":"val list = List(1,2,3)","类型":"1-单选"},{"题干":"reduce求和输出结果为\n  var list1 = list1(1,2,3,4)\n     var sum =  list1.reduce(_ + _) \n     println(sum)","选项F":"","选项E":"","选项D":"以上答案都不对","答案":"A","选项C":"4","选项B":"1","选项A":"10","类型":"1-单选"},{"题干":"reduce求减的输出结果为\n     var list = List(1,2,3,4)\n     var jian =  list.reduce(_ - _) \n     println(jian)","选项F":"","选项E":"","选项D":"以上答案都不对","答案":"A","选项C":"4","选项B":"10","选项A":"-8","类型":"1-单选"},{"题干":"reduceRitht计算输出结果正确的为\n    var list = List(1, 2, 3, 4)\n    var js = list.reduceRight(_ - _)\n    println(js)","选项F":"","选项E":"","选项D":"以上答案都不对","答案":"B","选项C":"-8","选项B":"-2","选项A":"10","类型":"1-单选"},{"题干":"reduceRight通过如下程序块其输出结果为\n    var list = List(1, 2, 99, 4,100)\n    var js = list.reduceRight(_ max _)\n    println(js)","选项F":"","选项E":"","选项D":"以上答案都不对","答案":"B","选项C":"206","选项B":"100","选项A":"$1","类型":"1-单选"},{"题干":"通过如下程序块可以知道其输出结果为\n    var list = List(1, 2, 99, 4,100)\n    var js = list.reduceRight(_ min _)\n    println(js)","选项F":"","选项E":"","选项D":"以上答案都不对","答案":"B","选项C":"206","选项B":"1","选项A":"100","类型":"1-单选"},{"题干":"以下的计算结果选项中那个正确\n    var list = List(1, 2, 3, 4,5)\n    var js = list.fold(100)(_ + _)\n    println(js)","选项F":"","选项E":"","选项D":"85","答案":"A","选项C":"5","选项B":"15","选项A":"115","类型":"1-单选"},{"题干":"在scala中fold的输出结果为\n    var lb = List(1, 2, 3, 4,5)\n    var js = lb.fold(100)(_ - _)\n    println(js)","选项F":"","选项E":"","选项D":"85","答案":"D","选项C":"5","选项B":"115","选项A":"15","类型":"1-单选"},{"题干":"var list = List(1, 2, 3, 4,5)\n    var js = list.foldRight(100)(_ - _)\n    println(js)","选项F":"","选项E":"","选项D":"85","答案":"C","选项C":"-97","选项B":"115","选项A":"15","类型":"1-单选"},{"题干":"scala语言中，下列关于函数说法正确的是","选项F":"","选项E":"","选项D":"函数不能赋值给变量","答案":"AB","选项C":"不能独立定义","选项B":"可以独立定义","选项A":"一等公民","类型":"2-多选"},{"题干":"常见的scala高阶函数有哪些","选项F":"","选项E":"","选项D":"main","答案":"ABC","选项C":"reduce","选项B":"flatMap","选项A":"map","类型":"2-多选"},{"题干":"以下对map函数说法错误的是","选项F":"","选项E":"","选项D":"对传入元素进行条件判断，没有返回值","答案":"BCD","选项C":"对传入元素进行条件判断，必须返回布尔值","选项B":"对每个元素都处理，没有返回值","选项A":"对传入的每个元素都进行映射，返回一个处理后的元素","类型":"2-多选"},{"题干":"关于foreach函数说法正确的是","选项F":"","选项E":"","选项D":"没有返回值","答案":"AD","选项C":"返回值为布尔型","选项B":"和map函数没有区别","选项A":"对传入的每个元素都进行处理","类型":"2-多选"},{"题干":"以下有返回值的函数有哪些","选项F":"","选项E":"","选项D":"filter","答案":"ABD","选项C":"foreach","选项B":"flatMap","选项A":"map","类型":"2-多选"},{"题干":"以下选项中正确的是\n    var lbiao = List(1, 2, 3, 4,5)\n    var js = lbiao.foldRight(100)(_ - _);println(js)","选项F":"","选项E":"","选项D":"fold表示数据从左往右进行迭代按括号内的逻辑进行操作,与foldRight是一个相反的过程","答案":"ACD","选项C":"foldRight表示数据从右往左进行迭代按括号内的逻辑进行操作","选项B":"foldRight与fold没有区别","选项A":"foldRight第一个参数为种子的初始值，计算过程会从右往左拿第一个数减去种子数得到的数据，拿第二个数再减去刚才的合计值，依次类推","类型":"2-多选"},{"题干":"对于以下列表的操作，那些说法说法正确\n    var c = List(1,2,3,4,5,99,101)\n    var gs = c.count(_>3)","选项F":"","选项E":"","选项D":"以上答案都不对","答案":"AB","选项C":"count表示按照括号内的函数进行求和计算，本题表示在列表中元素大于3的个数求合计，其结果为299","选项B":"count表示按照括号内的函数进行计算，本题表示在列表中元素大于3的个数计算","选项A":"变量gs的结果为4","类型":"2-多选"},{"题干":"函数必须有名字","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"函数可以作为其他函数的参数","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"函数不能作为返回值","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"高阶函数不能自动推断参数类型","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"一个参数的函数，可以省去小括号","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Set集合是无序不重复的集合","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"SortedSet集合是有序不重复的集合，是set的子类","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Map为一系列的key value键值对","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"SortedMap为Map的子类，其中有排序的特点","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Scala的集合分为可变与不可变集合2种","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"}]