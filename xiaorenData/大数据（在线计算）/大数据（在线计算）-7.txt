[{"题干":"下列哪些语句关于Java内存回收的说明是正确的","选项F":"","选项E":"","选项D":"内存回收程序负责释放无用内存","答案":"D","选项C":"内存回收程序允许程序员直接释放内存","选项B":"内存回收程序可以在指定的时间释放内存对象","选项A":"程序员必须创建一个线程来释放内存？","类型":"1-单选"},{"题干":"在Scala中属于map赋值（）：","选项F":"","选项E":"","选项D":"add","答案":"B","选项C":"=》","选项B":"->","选项A":"+！","类型":"1-单选"},{"题干":"Scala结合了（）和函数式的编程语言：","选项F":"","选项E":"","选项D":"python","答案":"A","选项C":"非纯面向对象","选项B":"对象过程","选项A":"面向对象","类型":"1-单选"},{"题干":"在scala中属于匿名函数（）：","选项F":"","选项E":"","选项D":"->","答案":"A","选项C":"<-","选项B":"=》","选项A":"=>","类型":"1-单选"},{"题干":"Scala始于（）年，由那个学校研发：","选项F":"","选项E":"","选项D":"2001\u00A0洛桑联邦理工学院","答案":"D","选项C":"2000\u00A0洛桑联邦理工学院","选项B":"2000\u00A0伦敦大学","选项A":"1998\u00A0\u00A0克林顿大学","类型":"1-单选"},{"题干":"在Scala中，函数与类、对象一样，关系为（）","选项F":"","选项E":"","选项D":"以上都不对","答案":"A","选项C":"类高于函数","选项B":"函数高于类","选项A":"一等公民","类型":"1-单选"},{"题干":"在scala中定义方法使用关键字","选项F":"","选项E":"","选项D":"class","答案":"A","选项C":"object","选项B":"main","选项A":"def","类型":"1-单选"},{"题干":"在scala中添加方法的返回值为空应该使用哪个关键字","选项F":"","选项E":"","选项D":"void","答案":"A","选项C":"Double","选项B":"Int","选项A":"Unit","类型":"1-单选"},{"题干":"下列哪个选项是scala中所有类的父类","选项F":"","选项E":"","选项D":"AnyVal","答案":"A","选项C":"AnyRef","选项B":"AnyInt","选项A":"Any","类型":"1-单选"},{"题干":"spark是由以下哪个机构研发出来的","选项F":"","选项E":"","选项D":"复旦大学","答案":"B","选项C":"麻省理工大学","选项B":"美国伯克利分校","选项A":"阿里学院","类型":"1-单选"},{"题干":"1535516484834nginx组件的作用","选项F":"","选项E":"","选项D":"集体均衡","答案":"B","选项C":"复合均衡","选项B":"软件负载均衡","选项A":"硬件负载均衡","类型":"1-单选"},{"题干":"1535516509296lvs组件的作用","选项F":"","选项E":"","选项D":"集体均衡","答案":"B","选项C":"复合均衡","选项B":"软件负载均衡","选项A":"硬件负载均衡","类型":"1-单选"},{"题干":"1535516517495f5服务器的作用","选项F":"","选项E":"","选项D":"集体均衡","答案":"A","选项C":"复合均衡","选项B":"软件负载均衡","选项A":"硬件负载均衡","类型":"1-单选"},{"题干":"hadoop中的namenode的作用","选项F":"","选项E":"","选项D":"删除数据","答案":"B","选项C":"写入数据","选项B":"管理集群中的节点","选项A":"存储数据","类型":"1-单选"},{"题干":"hadoop中datanode的在作用","选项F":"","选项E":"","选项D":"删除数据","答案":"A","选项C":"写入数据","选项B":"管理集群中的节点","选项A":"存储数据","类型":"1-单选"},{"题干":"yarn中nodemanager的作用","选项F":"","选项E":"","选项D":"读取数据","答案":"B","选项C":"存储数据","选项B":"管理本机节点的资源","选项A":"管理集群中整体节点的资源情况","类型":"1-单选"},{"题干":"解压.tar.gz结尾的HBase压缩包使用的Linux命令是","选项F":"","选项E":"","选项D":"tar�-nf","答案":"A","选项C":"tar�-s","选项B":"tar�-zx","选项A":"tar�-zxvf","类型":"1-单选"},{"题干":"HBase依赖（）提供强大的计算能力","选项F":"","选项E":"","选项D":"Chubby","答案":"B","选项C":"BigTable","选项B":"MapReduce","选项A":"The�Google�File�System","类型":"1-单选"},{"题干":"文件权限读、写、执行的三种标志符号依次是","选项F":"","选项E":"","选项D":"srw","答案":"A","选项C":"rdx","选项B":"xrw","选项A":"rwx","类型":"1-单选"},{"题干":"下列哪些选项是安装HBase前所必须安装的","选项F":"","选项E":"","选项D":"tomact","答案":"B","选项C":"Shell�Script","选项B":"JDK","选项A":"Java�Code","类型":"1-单选"},{"题干":"hdfs默认的备份数量","选项F":"","选项E":"","选项D":"4","答案":"C","选项C":"3","选项B":"2","选项A":"1","类型":"1-单选"},{"题干":"hdfs备份的策略是","选项F":"","选项E":"","选项D":"读取感应","答案":"A","选项C":"存储感应","选项B":"写入呼应","选项A":"机架感应","类型":"1-单选"},{"题干":"1535516694940以下关于maven说法正确的是","选项F":"","选项E":"","选项D":"maven能存储业务数据","答案":"B","选项C":"maven是一个数据仓库","选项B":"maven是一个jar包管理工具","选项A":"maven只是一个目录","类型":"1-单选"},{"题干":"zookeeper的默认端口号是","选项F":"","选项E":"","选项D":"8989","答案":"A","选项C":"8888","选项B":"2180","选项A":"2181","类型":"1-单选"},{"题干":"1535516708535maven查找jar包的顺序是","选项F":"","选项E":"","选项D":"中央资源库--局网资源库--本地资源库","答案":"A","选项C":"局网资源库--本地资源库--中央资源库","选项B":"本地资源库--中央资源库--局网资源库","选项A":"本地资源库--局网资源库--中央资源库","类型":"1-单选"},{"题干":"1535516713497使用maven加载jar包依赖加载必须使用哪个标签","选项F":"","选项E":"","选项D":"junit.version","答案":"A","选项C":"property","选项B":"properties","选项A":"dependency","类型":"1-单选"},{"题干":"1535516720323maven工程必须有一个()文件","选项F":"","选项E":"","选项D":"java类","答案":"C","选项C":"pom.xml文件","选项B":"doc文件","选项A":"xmls文件","类型":"1-单选"},{"题干":"1535516725781maven是一个()管理工具","选项F":"","选项E":"","选项D":"xml文件","答案":"A","选项C":"项目处理","选项B":"pom文件","选项A":"jar包","类型":"1-单选"},{"题干":"下面那些对于lazy关键字说话错误的是？","选项F":"","选项E":"","选项D":"变量加上lazy后，与没有加上lazy没有区别","答案":"D","选项C":"如果不使用lazy关键字对变量修饰，那么变量是立即实例化的","选项B":"惰性变量只能是不可变变量，并且只有在调用惰性变量时，才会去实例化这个变量","选项A":"Scala中使用关键字lazy来定义惰性变量，实现延迟加载(懒加载)","类型":"1-单选"},{"题干":"有一段如下代码，其中打印出来结果先后顺序为\n println(\"lazy变量演示\")\n lazy val ls= { println(\"I'mtoo lazy\") } \n println(\"after lazyVal\") \n val show=ls","选项F":"","选项E":"","选项D":"after lazyVal\nlazy变量演示\nI'mtoo lazy","答案":"A","选项C":"I'mtoo lazy\nlazy变量演示\nafter lazyVal","选项B":"lazy变量演示\nI'mtoo lazy\nafter lazyVal","选项A":"lazy变量演示\nafter lazyVal\nI'mtoo lazy","类型":"1-单选"},{"题干":"有关插值器说法如下不正确的是","选项F":"","选项E":"","选项D":"插值器f 表示是Float的输出","答案":"D","选项C":"以下代码输出为 I love baway\n var temp =\"baway\"\n println(f\" I love  $temp%s\")","选项B":"$符具有在String中直接拼接 字符串和数字等类型","选项A":"print方法中的s，f代表插入器 下面的操作为字符串链接操作","类型":"1-单选"},{"题干":"有一段如下代码，输出结果那个选项正确\n    var name=123;var age =22;\n    var nameNew = \"字符操作测试\" + name + age\n    println(name+age+\"你好\")\n    println(\"你好\"+name+age)\n    println(nameNew)","选项F":"","选项E":"","选项D":"145你好\n你好145\n字符操作测试145","答案":"A","选项C":"145你好\n你好145\n字符操作测试12322","选项B":"12322你好\n你好12322\n字符操作测试12322","选项A":"145你好\n你好12322\n字符操作测试12322","类型":"1-单选"},{"题干":"scala中下面对于For循环打印出来说法正确的是？","选项F":"","选项E":"","选项D":"for(int i=1;i<=10;i++){\n      print(i)\n    }\n输出1-10 10个数字","答案":"A","选项C":"for(i <- 1.to(10)){\n      print(i)\n    }\n 程序编译有错误没有.to(10)这种写法","选项B":"for(i <- 1 until 10){\n      print(i)\n    }\n输出1-10 10个数字","选项A":"for(i <- 1 to 10){\n      print(i)\n    }\n输出1-10 10个数字","类型":"1-单选"},{"题干":"对于scala for循环块用到的关键字to与until说法不正确的是","选项F":"","选项E":"","选项D":"to 与until用法一致，包括循环次数也一样","答案":"D","选项C":"until和to的不同之处在于不包括最后一个元素。","选项B":"until：左闭右开 循环体中包括左边的数值，不包括右边的数值","选项A":"to:左闭右闭 循环体中包括左边与右边的数值","类型":"1-单选"},{"题干":"下面有关集合说法错误的是？","选项F":"","选项E":"","选项D":"元组下标与别的一样也是从0开始","答案":"D","选项C":"元组是不同类型的值的集合","选项B":"Map 是一种把键对象和值对象映射的集合，它的每一个元素都包含一对键对象和值对象","选项A":"Set是最简单的一种集合。集合中的对象不按特定的方式排序，并且没有重复对象","类型":"1-单选"},{"题干":"下面有关迭代器说法错误的是？","选项F":"","选项E":"","选项D":"Scala Iterator（迭代器）是一个集合","答案":"D","选项C":"Scala Iterator（迭代器）不是一个集合，它是一种用于访问集合的方法","选项B":"调用 迭代器next() 会返回迭代器的下一个元素，并且更新迭代器的状态","选项A":"迭代器 it 的两个基本操作是 next 和 hasNext","类型":"1-单选"},{"题干":"下面有关方法与函数的定义差别错误的是?","选项F":"","选项E":"","选项D":"方法与函数可以互相转化，没有本质的区别。","答案":"D","选项C":"Scala 中使用 val 语句可以定义函数，def 语句定义方法","选项B":"Scala 方法是类的一部分，而函数是一个对象可以赋值给一个变量","选项A":"方法是以def开头，函数的标志为=>","类型":"1-单选"},{"题干":"有关scala安装错误的是？","选项F":"","选项E":"","选项D":"Scala 语言可以运行在Mac OS X系统上","答案":"B","选项C":"Scala 语言可以运行在Linux、Unix等系统上","选项B":"Scala是基于java之上，大量使用java的类库和变量，使用 Scala 可以使用先安装 Java 1.4版本","选项A":"Scala 语言可以运行在Window系统上","类型":"1-单选"},{"题干":"Spark也可以不依赖于第三方的资源管理和调度器，它实现了()作为其内置的资源管理和调度框架","选项F":"","选项E":"","选项D":"redis","答案":"A","选项C":"Mesos","选项B":"YARN","选项A":"Standalone","类型":"1-单选"},{"题干":"Spark支持除（）以下选项中三种语言的API","选项F":"","选项E":"","选项D":"go","答案":"D","选项C":"Python","选项B":"SCALA","选项A":"JAVA","类型":"1-单选"},{"题干":"spark是由以下哪个大学研发出来的","选项F":"","选项E":"","选项D":"复旦大学","答案":"B","选项C":"麻省理工大学","选项B":"美国伯克利分校","选项A":"阿里学院","类型":"1-单选"},{"题干":"1536889451在js中能够匹配所有 input, textarea, select 和 button 元素的选择器是：","选项F":"","选项E":"","选项D":"button选择器","答案":"B","选项C":"select选择器","选项B":"input选择器","选项A":"text选择器","类型":"1-单选"},{"题干":"以下关于mesos叙述正确的是","选项F":"","选项E":"","选项D":"以上都不是","答案":"A","选项C":"mesos是发送系统","选项B":"mesos是任务调度平台","选项A":"mesos是资源调度平台","类型":"1-单选"},{"题干":"下面哪个资源管理器组件与mesos是相类似的组件","选项F":"","选项E":"","选项D":"以上都不对","答案":"A","选项C":"mapreduce","选项B":"hdfs","选项A":"yarn","类型":"1-单选"},{"题干":"任何一个架构要用yarn来进行资源管理，必须和以下哪个接口做结合","选项F":"","选项E":"","选项D":"以上都不是","答案":"A","选项C":"taskMaster","选项B":"jobMaster","选项A":"ApplicationMaster","类型":"1-单选"},{"题干":"yarn组件中的resourceManager的作用是","选项F":"","选项E":"","选项D":"以上都不是","答案":"B","选项C":"数据接口","选项B":"为nodemanager的管理进行调度","选项A":"存储数据","类型":"1-单选"},{"题干":"以下哪个组件和Tachyon是类似的组件","选项F":"","选项E":"","选项D":"mapreduce","答案":"A","选项C":"spark","选项B":"yarn","选项A":"hdfs","类型":"1-单选"},{"题干":"以下关于spark streaming说法正确的是","选项F":"","选项E":"","选项D":"spark streaming分布式实时计算架构","答案":"A","选项C":"spark streaming是普通存储架构","选项B":"spark streaming实时存储架构","选项A":"spark streaming分布式微批架构","类型":"1-单选"},{"题干":"spark是基于()运行的计算框架","选项F":"","选项E":"","选项D":"网络","答案":"A","选项C":"内存加磁盘","选项B":"磁盘","选项A":"内存","类型":"1-单选"},{"题干":"与spark基于内存相比，mapreduce是基于()运行的计算框架","选项F":"","选项E":"","选项D":"网络","答案":"B","选项C":"内存加磁盘","选项B":"磁盘","选项A":"内存","类型":"1-单选"},{"题干":"关于高阶函数描述错误的是：","选项F":"","选项E":"","选项D":"函数的方法体比较长","答案":"CD","选项C":"执行时间长的函数","选项B":"将函数作为参数其他函数的参数使用","选项A":"在程序中应该首先被定义的函数","类型":"2-多选"},{"题干":"Scala异常处理：","选项F":"","选项E":"","选项D":"singleton=false","答案":"AB","选项C":"抛插值器","选项B":"Throw出去","选项A":"Case匹配的方式处理","类型":"2-多选"},{"题干":"Scala中，Object相当于class的一个实例，通常在里面放一些静态的（）：","选项F":"","选项E":"","选项D":"Source","答案":"AB","选项C":"管理块服务器","选项B":"Method","选项A":"Field","类型":"2-多选"},{"题干":"下列选项中，哪些是scala中到的关键字","选项F":"","选项E":"","选项D":"AnyVal","答案":"ACD","选项C":"AnyRef","选项B":"AnyInt","选项A":"Any","类型":"2-多选"},{"题干":"下列关于scala中的object描述正确的是","选项F":"","选项E":"","选项D":"scala中的object是一个伴生对象","答案":"ACD","选项C":"object本身就是一个单例对象","选项B":"scala中的object和java中的object是一样的","选项A":"object是scala的关键字","类型":"2-多选"},{"题干":"1535516548600以下属于lucene技术的升级实现的是","选项F":"","选项E":"","选项D":"memcache","答案":"AB","选项C":"lvs","选项B":"elasticsearch","选项A":"solr","类型":"2-多选"},{"题干":"1535516556962以下可以做缓存的技术有","选项F":"","选项E":"","选项D":"mysql","答案":"ABC","选项C":"session","选项B":"memcache","选项A":"redis","类型":"2-多选"},{"题干":"1536889451cookie不再热门使用的原因是","选项F":"","选项E":"","选项D":"不在维护","答案":"AB","选项C":"技术不更新","选项B":"存储大小","选项A":"安全问题","类型":"2-多选"},{"题干":"1536889451访问hbase\u00A0table中的行，以下可行的是","选项F":"","选项E":"","选项D":"通过列族来访问","答案":"ABC","选项C":"全表扫描","选项B":"通过row\u00A0key的range","选项A":"通过单个row\u00A0key访问","类型":"2-多选"},{"题干":"下面哪些概念是HBase框架中使用的","选项F":"","选项E":"","选项D":"EXT3","答案":"AC","选项C":"Zookeeper","选项B":"GridFS","选项A":"HDFS","类型":"2-多选"},{"题干":"文件exer1的访问权限为rw-r--r--,现要增加所有用户的执行权限和同组用户的写权限,下列命令正确的是","选项F":"","选项E":"","选项D":"chmod�g�w�exer1","答案":"AB","选项C":"chmod�765exer1","选项B":"chmod�775�exer1","选项A":"chmod�a+x,�g+w�exer1","类型":"2-多选"},{"题干":"以下关于Namenode的说法正确的是：：","选项F":"","选项E":"","选项D":"管理文件系统的命名空间。","答案":"ABCD","选项C":"记录\u00A0每个文件数据快在各个Datanode上的位置和副本信息。","选项B":"记录命名空间内的改动或者空间本省属性的改动。","选项A":"协调客户端对文件的访问。","类型":"2-多选"},{"题干":"1535516743758以下选项这种哪些可以作为注册中心使用？","选项F":"","选项E":"","选项D":"mysql","答案":"ABC","选项C":"Multicast","选项B":"zppkeeper","选项A":"redis","类型":"2-多选"},{"题干":"maven项目打包的方式有哪几种","选项F":"","选项E":"","选项D":"xml包","答案":"ABC","选项C":"pom包","选项B":"war包","选项A":"jar包","类型":"2-多选"},{"题干":"maven在pom.xml文件中配置的三个核心标签是","选项F":"","选项E":"","选项D":"Monitor","答案":"ABC","选项C":"version","选项B":"artifactId","选项A":"groupId","类型":"2-多选"},{"题干":"当我们在scala语言中书写for循环块用到的关键字to与until说法正确的是","选项F":"","选项E":"","选项D":"to 与until用法一致，包括循环次数也一样","答案":"ABC","选项C":"until和to的不同之处在于不包括最后一个元素。","选项B":"until：左闭右开 循环体中包括左边的数值，不包括右边的数值","选项A":"to:左闭右闭 循环体中包括左边与右边的数值","类型":"2-多选"},{"题干":"下面那些对于lazy关键字说法正确的选项包括如下几个？","选项F":"","选项E":"","选项D":"变量加上lazy后，与没有加上lazy没有区别","答案":"ABC","选项C":"如果不使用lazy关键字对变量修饰，那么变量是立即实例化的","选项B":"惰性变量只能是不可变变量，并且只有在调用惰性变量时，才会去实例化这个变量","选项A":"Scala中使用关键字lazy来定义惰性变量，实现延迟加载(懒加载)","类型":"2-多选"},{"题干":"用scala求10以内的偶数下面那些写法正确","选项F":"","选项E":"","选项D":"for(i <- 0.to(10) if(i%2==0)){\n      print(i +\"  \")\n    }","答案":"ABCD","选项C":"for(i <- 0 to 10 ){\n      if(i%2==0)\n      {\n       print(i +\"  \")\n      }\n    }","选项B":"for(i <- 0 to 10 ){\n      if(i%2==0) print(i +\"  \")\n    }","选项A":"for(i <- 0 to 10 if(i%2==0)){\n      print(i +\"  \")\n    }","类型":"2-多选"},{"题干":"有关scala集合说法正确的是","选项F":"","选项E":"","选项D":"不可变集合你仍然可以模拟添加，移除或更新操作。但是这些操作将在每一种情况下都返回一个新的集合，同时使原来的集合不发生改变","答案":"ABCD","选项C":"而不可变集合类，相比之下，永远不会改变","选项B":"可变集合可以在适当的地方被更新或扩展。这意味着你可以修改，添加，移除一个集合的元素","选项A":"Scala 集合分为可变的和不可变的集合","类型":"2-多选"},{"题干":"SCALA有以下哪些特点？","选项F":"","选项E":"","选项D":"SCALA 语言简洁优雅大方，很多大数据底层框架采用scala去实现与编程","答案":"ABCD","选项C":"Scala 源代码被编译成Java字节码，所以它可以运行于JVM之上，并可以调用现有的Java类库","选项B":"Scala 运行在Java虚拟机上，并兼容现有的Java程序","选项A":"Scala 是一门多范式（multi-paradigm）的编程语言，设计初衷是要集成面向对象编程和函数式编程的各种特性","类型":"2-多选"},{"题干":"创建rdd可以有如下几种？","选项F":"","选项E":"","选项D":"以上说法都不对","答案":"ABC","选项C":"比如所有Hadoop支持的数据集，比如HDFS、Cassandra、Hbase","选项B":"由一个已经存在的Scala集合创建","选项A":"由外部存储系统的数据集创建，包括本地的文件系统","类型":"2-多选"},{"题干":"以下哪个算子与别的算子不同？","选项F":"","选项E":"","选项D":"reduce","答案":"D","选项C":"flatMap","选项B":"filter","选项A":"map","类型":"2-多选"},{"题干":"下面那些属于转化算子？","选项F":"","选项E":"","选项D":"count","答案":"ABC","选项C":"groupByKey","选项B":"distinct","选项A":"union","类型":"2-多选"},{"题干":"以下哪些属于动作算子","选项F":"","选项E":"","选项D":"map","答案":"ABC","选项C":"count","选项B":"reduce","选项A":"foreach","类型":"2-多选"},{"题干":"以下哪些属于持久化算子？","选项F":"","选项E":"","选项D":"count","答案":"ABC","选项C":"checkpoint","选项B":"persist","选项A":"cache","类型":"2-多选"},{"题干":"RDD特性包含如下哪些？","选项F":"","选项E":"","选项D":"一个列表，存储存取每个Partition的优先位置（preferred location）","答案":"ABCD","选项C":"RDD之间的依赖关系","选项B":"一个计算每个分区的函数","选项A":"一组分片（Partition），即数据集的基本组成单位","类型":"2-多选"},{"题干":"在scala中关于高阶函数描述错误的是：","选项F":"","选项E":"","选项D":"函数的方法体比较长","答案":"CD","选项C":"执行时间长的函数","选项B":"将函数作为参数其他函数的参数使用","选项A":"在程序中应该首先被定义的函数","类型":"2-多选"},{"题干":"下列选项中是spark组件的有？","选项F":"","选项E":"","选项D":"spark sql","答案":"ABCD","选项C":"Grophx","选项B":"spark streaming","选项A":"spark core","类型":"2-多选"},{"题干":"spark 框架的API支持哪种语言进行开发","选项F":"","选项E":"","选项D":"go","答案":"ABC","选项C":"scala","选项B":"python","选项A":"java","类型":"2-多选"},{"题干":"spark架构中支持以下哪些运行模式","选项F":"","选项E":"","选项D":"基于java的运行模式","答案":"ABC","选项C":"基于mesos模式的运行","选项B":"基于yarn的运行模式","选项A":"基于standalone模式到的运行","类型":"2-多选"},{"题干":"spark的源码由下面选项中哪几种语言编写完成的","选项F":"","选项E":"","选项D":"r","答案":"AB","选项C":"go","选项B":"scala","选项A":"java","类型":"2-多选"},{"题干":"mapreduce整个生命周期由以下哪几部分组成","选项F":"","选项E":"","选项D":"maps","答案":"AB","选项C":"shuffer","选项B":"reduce端","选项A":"map端","类型":"2-多选"},{"题干":"scala中val定义的变量，赋值后不能改变","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"scala中String类没有插值器的概念","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"scala中var定义的变量,赋值后不能改变","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"AnyVal是scala中基本类型的父类","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"AnyRef是scala中的String类的父类","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"yarn是一个资源调度平台","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"hdfs是一个基于内存的计算模型","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"tail和head一样，后面直接跟文件名，则显示文件最后十行。如果加-n选项则显示文件最后n行","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"卸载一个rpm包的命令为\u00A0rpm\u00A0-e\u00A0filename","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"java中的continue的作用是跳过本次循环","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"maven加载jar包是通过pom.xml文件中的groupId，artifactId，version来进行jar包查找的","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"基于maven的项目，有且必须有一个pom.xml文件","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"maven项目是通过pom.xml文件来进行依赖jar包的加载的","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"闭包是一个函数，返回值依赖于声明在函数外部的一个或多个变量","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"var\u00A0factor\u00A0=\u00A03\u00A0\u00A0\n\u00A0val\u00A0multiplier\u00A0=\u00A0(i:Int)\u00A0=>\u00A0i\u00A0*\u00A0factor\u00A0\n\u00A0这里我们引入一个自由变量\u00A0factor，这个变量定义在函数外面,这就是闭包","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"用 private 关键字修饰，带有此标记的成员仅在包含了成员定义的类或对象内部可见，同样的规则还适用内部类","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"在 scala 中，对保护（Protected）成员的访问比 java 更严格一些。因为它只允许保护成员在定义了该成员的的类的子类中被访问","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Scala中，如果没有指定任何的修饰符，则默认为 public","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Spark是一种快速、通用、可扩展的大数据分析引擎，2009年诞生于加州大学伯克利分校AMPLab","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Spark生态系统已经发展成为一个包含多个子项目的集合，其中包含SparkSQL、Spark Streaming、GraphX、MLlib等子项目","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Spark是基于内存计算的大数据并行计算框架。Spark基于内存计算，提高了在大数据环境下数据处理的实时性，同时保证了高容错性和高可伸缩性","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"与Hadoop的MapReduce相比，Spark基于内存的运算要快100倍以上，基于硬盘的运算也要快10倍以上","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Spark支持Java、Python和Scala的API，还支持超过80种高级算法，使用户可以快速构建不同的应用","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Spark提供了统一的解决方案。Spark可以用于批处理、交互式查询（Spark SQL）、实时流处理（Spark Streaming）、机器学习（Spark MLlib）和图计算（GraphX）","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Spark可以使用Hadoop的YARN和Apache Mesos作为它的资源管理和调度器，并且可以处理所有Hadoop支持的数据，包括HDFS、HBase和Cassandra等","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"RDD（Resilient Distributed Dataset）叫做分布式数据集，是Spark中最基本的数据抽象，它代表一个不可变、可分区、里面的元素可并行计算的集合","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"RDD允许用户在执行多个查询时显式地将工作集缓存在内存中，后续的查询能够重用工作集，这极大地提升了查询速度","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"RDD中的所有转换都是通过转化算子延迟加载的，也就是说，它们并不会直接计算结果","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"countByKey为针对(K,V)类型的RDD，返回一个(K,Int)的map，表示每一个key对应的元素个数","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"foreach算子在数据集的每一个元素上，运行函数func进行操作","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"take算子返回一个由数据集的前n个元素组成的数组","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"count算子返回RDD的元素个数","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"collect算子在驱动程序中，以数组的形式返回数据集的所有元素，要谨慎使用","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"cogroup算子在类型为(K,V)和(K,W)的RDD上调用，返回一个(K,(Iterable<V>,Iterable<W>))类型的RDD","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"map算子返回一个新的RDD，该RDD由每一个输入元素经过func函数转换后组成","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"filter算子返回一个新的RDD，该RDD由经过函数计算后返回值为true的输入元素组成","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"union算子对源RDD和参数RDD求并集后返回一个新的RDD","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"groupByKey算子在一个(K,V)的RDD上调用，返回一个(K, Iterator[V])的RDD","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"flatMap类似于map，但是每一个输入元素可以被映射为0或多个输出元素（所以func应该返回一个序列，而不是单一元素）,所有元素会被压瘪","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"mapPartitions算子类似于map，但独立地在RDD的每一个分片上运行，因此在类型为T的RDD上运行时，func的函数类型必须是Iterator[T] => Iterator[U]","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"sample(withReplacement, fraction, seed)算子根据fraction指定的比例对数据进行采样，可以选择是否使用随机数进行替换，seed用于指定随机数生成器种子","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"interSection算子对源RDD和参数RDD求交集后返回一个新的RDD","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"distinct 算子对源RDD进行去重后返回一个新的RDD","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"reduceByKey算子在一个(K,V)的RDD上调用，返回一个(K,V)的RDD，使用指定的reduce函数，将相同key的值聚合到一起","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"sortByKey算子在一个(K,V)的RDD上调用，K必须实现Ordered接口，返回一个按照key进行排序的(K,V)的RDD","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"join算子在类型为(K,V)和(K,W)的RDD上调用，返回一个相同key对应的所有元素对在一起的(K,(V,W))的RDD","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"reduce动作算子通过func函数聚集RDD中的所有元素，这个功能必须是可交换且可并联的","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"saveAsText算子将数据集的元素以textfile的形式保存到HDFS文件系统或者其他支持的文件系统，对于每个元素，Spark将会调用toString方法，将它装换为文件中的文本","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"saveAsSequenceFile动作算子将数据集中的元素以Hadoop sequencefile的格式保存到指定的目录下，可以使HDFS或者其他Hadoop支持的文件系统","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"RDD和它依赖的父RDD（s）的关系有两种不同的类型，即窄依赖（narrow dependency）和宽依赖（wide dependency）","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"窄依赖指的是每一个父RDD的Partition最多被子RDD的一个Partition使用\n总结：窄依赖我们形象的比喻为独生子女","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"宽依赖指的是多个子RDD的Partition会依赖同一个父RDD的Partition\n总结：窄依赖我们形象的比喻为超生","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"RDD通过persist方法或cache方法可以将前面的计算结果缓存，但是并不是这两个方法被调用时立即缓存，而是触发后面的action时，该RDD将会被缓存在计算节点的内存中，并供后面重用","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"对于宽依赖，由于有Shuffle的存在，只能在父RDD处理完成后，才能开始接下来的计算，因此宽依赖是划分Stage的依据","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"在scala语言中val定义的变量，赋值后不能改变","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"spark比mapreduce快的原因仅是因为内存","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Hive中的输入如果存储在内表中，删除数据时真正删除的东西是数据和表结构","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"spark是基于内存的计算框架","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"Spark是用Scala语言实现的，并且其API也支持scala语言开发","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"spark是由spark core、spark sql、spark streaming组成的","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"}]