[{"题干":"对于以下代码描述有误的是？\nval data = Map(1 -> \"One\", 2 -> \"Two\")\nval res = for((k, v) <- data; if(k > 1)) yield v","选项F":"","选项E":"","选项D":"其中的if(k > 1)是一个守卫表达式。","答案":"B","选项C":"对映射data中的每一个(键，值)对，k被绑定对键，而v则被绑定到值。","选项B":"运行后res的结果为List(\"One\", \"Two\")。","选项A":"运行后res的结果为List(\"Two\")。","类型":"1-单选"},{"题干":"以下关于特质的说法错误的是？","选项F":"","选项E":"","选项D":"当将多个特质叠加在一起时，顺序很重要——其方法先被执行的特质排在更后面。","答案":"C","选项C":"与Java接口(Interface)相同，Scala特质也可以提供方法和字段的实现。","选项B":"特质可以要求实现它们的类具备特定的字段、方法或超类。","选项A":"类可以实现任意数量的特质。","类型":"1-单选"},{"题干":"关于Scala中不支持多重继承的原因描述正确的是？","选项F":"","选项E":"","选项D":"以上均正确。","答案":"D","选项C":"通过使用Trait可以达到多重继承的类似效果。","选项B":"若多重继承的两个基类具有相同的字段或方法，就会引发菱形继承问题，造成问题的复杂性。","选项A":"在实际使用中，真正必须使用多重继承的时机很少。","类型":"1-单选"},{"题干":"关于Scala中的trait和Java中的Interface描述错误的是？","选项F":"","选项E":"","选项D":"Trait可以写方法的实现","答案":"A","选项C":"Java只能在类层面上添加接口的实现，而Scala可以在类和对象层面上“混入”特质。","选项B":"Scala和Java都不允许多重继承，但可以叠加多个特质或接口。","选项A":"Scala特质和Java接口都可以包含抽象方法和具体实现。","类型":"1-单选"},{"题干":"以下关于Scala中函数的描述错误的是?","选项F":"","选项E":"","选项D":"可以将函数作为参数，传递给其它函数。","答案":"B","选项C":"支持非具名函数，也即匿名函数。","选项B":"可以将函数赋值给变量，如val fun = scala.math.ceil。","选项A":"函数是“头等公民”，就和数字一样。","类型":"1-单选"},{"题干":"现有元组val t = (1, 3.14, \"Fred\")，关于元组t的说法错误的是？","选项F":"","选项E":"","选项D":"t._0无法访问， 会抛出异常","答案":"A","选项C":"val (first, second, _) = t\u00A0// second 等于 3.14","选项B":"t 的类型为 Tuple3[Int, Double, java.lang.String]","选项A":"t._0\u00A0等于 1","类型":"1-单选"},{"题干":"以下有关元组Tuple说法有哪些是不正确的","选项F":"","选项E":"","选项D":"访问元组第一个元素的方式为 pair._1","答案":"C","选项C":"元组最多只有3个元素","选项B":"元组是不可变的","选项A":"元组的可以包含不同类型的元素","类型":"1-单选"},{"题干":"以下关于集合的说法不正确的是","选项F":"","选项E":"","选项D":"为了顾及安全性问题，Scala仅支持不可变集合而不支持可变集合。","答案":"D","选项C":"List中的值是有先后次序的","选项B":"Map是一组(键，值)对偶。","选项A":"Set是一组没有先后次序的值。","类型":"1-单选"},{"题干":"在scala语言中，关于类和它的伴生对象，说法不正确的是","选项F":"","选项E":"","选项D":"类和它的伴生对象可以互相访问私有特性","答案":"B","选项C":"类和它的伴生对象的名称必须相同","选项B":"类和它的伴生对象可以有不同的名称","选项A":"类和它的伴生对象定义在同一个文件中","类型":"1-单选"},{"题干":"对以下set集合进行操作\"Set(2, 0, 1) + 1 + 1 - 1\"之后，最终的结果是","选项F":"","选项E":"","选项D":"已上均不正确。","答案":"C","选项C":"Set(2, 0)","选项B":"Set(2, 0, 1)","选项A":"Set(2, 0, 1, 1)","类型":"1-单选"},{"题干":"下列程序输出结果为\n    var c = Array(1,2,3,4,9,5)\n    var max = c.max;println(max)","选项F":"","选项E":"","选项D":"4","答案":"B","选项C":"5","选项B":"9","选项A":"1","类型":"1-单选"},{"题干":"下列程序输出结果为\n    var c = Array(1,2,3,4,9,5);var min = c.min\n    println(min)","选项F":"","选项E":"","选项D":"4","答案":"A","选项C":"5","选项B":"9","选项A":"1","类型":"1-单选"},{"题干":"2个数组，调用zip函数会将2个数组变成元组，这就是函数zip拉链的含义，请说出下列程序输出结果为\n    var  key1 = Array(\"java\",\"oracle\",\"c++\",\"dephile\")\n    var  grade1 = Array(1,2,3,4)\n    var class2Grade = key1.zip(grade1)\n    for(j <- class2Grade)\n      {\n        println(j)\n      }","选项F":"","选项E":"","选项D":"以上答案都不对","答案":"A","选项C":"(java,1，oracle,2，c++,3，dephile,4)","选项B":"(1，java)\n(2，oracle)\n(3，c++)\n(4，dephile)","选项A":"(java,1)\n(oracle,2)\n(c++,3)\n(dephile,4)","类型":"1-单选"},{"题干":"reverse会将所给的对象的顺序反转，请说出下列程序输出结果为\n    val arr = Array(1,2,3,4,5)\n    //带下标的for循环\n    for (i <- (0 to 4).reverse) print(arr(i) + \" \")","选项F":"","选项E":"","选项D":"1 2 3 4 5","答案":"A","选项C":"3 2 1 5 4","选项B":"4 3 2 1  5","选项A":"5 4 3 2 1","类型":"1-单选"},{"题干":"sorted会将所给的对象进行排序，请说出下列程序输出结果为\n    val  a3 = Array(1,2,3,4,5,100,7)\n    val cs = a3.sorted;for(j<- cs ) print(j + \" \")","选项F":"","选项E":"","选项D":"100 7 5 4 3 2 1","答案":"A","选项C":"4 5 7 100 1 2 3","选项B":"2 3 4 5 7 100 1","选项A":"1 2 3 4 5 7 100","类型":"1-单选"},{"题干":"sortWith会将所给的对象进行给定升降序排序，请说出下列程序输出结果为\n    val  a3 = Array(4,5,100,7)\n    val cs = a3.sortWith(_>_);for(j<- cs ) print(j + \" \")","选项F":"","选项E":"","选项D":"5 4 100 7","答案":"A","选项C":"7 5 4  100","选项B":"4 5 7 100","选项A":"100 7 5 4","类型":"1-单选"},{"题干":"for 循环中的 yield 会把当前的元素记下来，保存在集合中，请说出下列程序输出结果为\n    val c = Array(1,2,3)\n    var kk = for(j<-c) yield  j*2\n    for(j<- kk) print(j + \" \")","选项F":"","选项E":"","选项D":"3 2 1","答案":"A","选项C":"6 4 2","选项B":"1 2 3","选项A":"2 4 6","类型":"1-单选"},{"题干":"以下对list 的操作take说法正确的是\nvar t = List(1,8,3,5,5)；println(t.take(2))","选项F":"","选项E":"","选项D":"以上答案都不对","答案":"A","选项C":"打印列表的从下表2开始的所有元素，结果为List(3，5，5)","选项B":"打印列表的后2个元素，结果为List(5，5)","选项A":"打印列表的前2个元素，结果为List(1, 8)","类型":"1-单选"},{"题干":"以下对list 的操作distinct说法正确的是\nvar t = List(1,8,3,5,5)\nprintln(t.distinct)","选项F":"","选项E":"","选项D":"List为可变列表，返回的是一个新的去重的新的可变列表List(1,8,3,5)","答案":"A","选项C":"List为可变列表，没有这个distinct方法返回,编译出现错误的是一个新的去重的新的可变列表List","选项B":"distinct为去重操作，返回的是在原基础的列表List(1,8,3,5)","选项A":"distinct为去重操作，返回一个新的结果为List(1,8,3,5)","类型":"1-单选"},{"题干":"以下对于操作说法正确的是\nvar t = List(1,8,3,5,5);println(t.filter { x => x>3 })","选项F":"","选项E":"","选项D":"对可变列表没有这个filter方法，编译错误","答案":"A","选项C":"对可变列表进行元素大于3的操作，返回新的可变列表List(8,5,5)并打印出来","选项B":"对不可变列表进行元素大于3的操作，返回过滤后的列表List(8,5,5)并打印出来，不产生新列表","选项A":"对不可变列表进行元素大于3的操作，返回新的列表List(8,5,5)并打印出来","类型":"1-单选"},{"题干":"在scala中对于列表操作以下对于这些列表操作正确的是\n  var t = List(1,2,3)\n  var t2 = t.+:(\"test\")","选项F":"","选项E":"","选项D":"以上说法都不对","答案":"A","选项C":"不同类型的元素不能进行列表相加","选项B":"返回结果为 List(1,2,3,\"test\")","选项A":"返回结果为 List(\"test\",1,2,3)","类型":"1-单选"},{"题干":"以下对于这些列表操作正确的是\n  var t = List(1,2,3)\n  var t2 = t.:+(\"test\")","选项F":"","选项E":"","选项D":"以上说法都不对","答案":"B","选项C":"不同类型的元素不能进行列表相加","选项B":"返回结果为 List(1,2,3,\"test\")","选项A":"返回结果为 List(\"test\",1,2,3)","类型":"1-单选"},{"题干":"对于以下2个列表的操作，那些说法说法不正确\n  var t = List(1,2,3)\n  var t2 = List(4,5)","选项F":"","选项E":"","选项D":"var t3 = t.:::(t2) 得到List(1,2,3,4,5)","答案":"D","选项C":"var t3 = t ::: t2得到List(1,2,3,4,5)","选项B":"var t3 = List.concat(t,t2)得到List(1,2,3,4,5)","选项A":"var t3 = t ++ t2 得到List(1,2,3,4,5)","类型":"1-单选"},{"题干":"下面输出结果为\nobject Ys {\n  def add(i:Int)(implicit y:Int=100):Int=i+y\n  def main(args: Array[String]): Unit = {\n     var add2=add(2)(3) ;println(add2)\n  }\n}","选项F":"","选项E":"","选项D":"105","答案":"A","选项C":"103","选项B":"102","选项A":"5","类型":"1-单选"},{"题干":"下面隐式转化输出结果为\nobject Ys {\n  def add(i:Int)(implicit y:Int=100):Int=i+y\n  def main(args: Array[String]): Unit = {\n     var add2=add(2) ;println(add2)\n  }\n}","选项F":"","选项E":"","选项D":"105","答案":"B","选项C":"103","选项B":"102","选项A":"5","类型":"1-单选"},{"题干":"下面输出结果为\nobject Ys {\n  def add(i:Int)(implicit y:Int=100):Int=i+y\n  def main(args: Array[String]): Unit = {\n    implicit val abc:Int=300\n    var add2=add(2)(3) ;println(add2)\n  }\n}","选项F":"","选项E":"","选项D":"105","答案":"A","选项C":"103","选项B":"102","选项A":"5","类型":"1-单选"},{"题干":"下面输出结果为\nobject Ys {\n  def add(i:Int)(implicit y:Int=100):Int=i+y\n  def main(args: Array[String]): Unit = {\n    implicit val abc:Int=300\n    var add2=add(2) ;println(add2)\n  }\n}","选项F":"","选项E":"","选项D":"105","答案":"B","选项C":"103","选项B":"302","选项A":"102","类型":"1-单选"},{"题干":"object Ys {\n  def add(i:Int)(implicit y:Int=100):Int=i+y\n  def main(args: Array[String]): Unit = {\n    implicit val abc:Int=300\n    implicit val a:Int=300\n    var add2=add(2) ;println(add2)\n  }\n}","选项F":"","选项E":"","选项D":"编译出现错误，有2个相同类型的隐式值","答案":"D","选项C":"103","选项B":"102","选项A":"5","类型":"1-单选"},{"题干":"object Ys {\n  def add(i:Int)(implicit y:Int=100):Int=i+y\n  def main(args: Array[String]): Unit = {\n    implicit val abc:Int=300\n    implicit val a:Double=300.0\n    var add2=add(2)(101) ;println(add2)\n  }\n}","选项F":"","选项E":"","选项D":"编译出现错误，有3个相同类型的隐式值","答案":"B","选项C":"302","选项B":"103","选项A":"102","类型":"1-单选"},{"题干":"对于元组val t = (1, 3.14, \"Fred\")说法错误的是？","选项F":"","选项E":"","选项D":"t._0无法访问， 会抛出异常","答案":"A","选项C":"val (first, second, _) = t // second 等于 3.14","选项B":"t 的类型为 Tuple3[Int, Double, java.lang.String]","选项A":"t._0 等于 1","类型":"1-单选"},{"题干":"以下关于scala语言中的函数的说法中，其中正确的是","选项F":"","选项E":"","选项D":"函数不能赋值给变量","答案":"AB","选项C":"不能独立定义","选项B":"可以独立定义","选项A":"一等公民","类型":"2-多选"},{"题干":"在scala中定义一个List，以下语法正确的是","选项F":"","选项E":"","选项D":"val list = List[Int](\"a\",\"b\")","答案":"AB","选项C":"val list = List[String](‘a’,’b’,’c’)","选项B":"val list = List[Int](1,2,3)","选项A":"val list = List(4,7,3)","类型":"2-多选"},{"题干":"以下有关集合的说法中，其中正确的是","选项F":"","选项E":"","选项D":"Set集合和List集合没有区别","答案":"AC","选项C":"Map集合是键值对的形式存储的数据","选项B":"Set集合中数据可以重复","选项A":"List集合中数据可以重复","类型":"2-多选"},{"题干":"在scala中的模式匹配可以匹配哪些类型","选项F":"","选项E":"","选项D":"构造函数匹配等","答案":"ABCD","选项C":"变量匹配","选项B":"常量匹配","选项A":"通配符匹配","类型":"2-多选"},{"题干":"以下有关scala语言中的伴生类和伴生对象的说法，正确的是","选项F":"","选项E":"","选项D":"不与伴生类同名的单例对象称为孤立对象","答案":"ABCD","选项C":"伴生对象和伴生类可以互相访问其私有成员","选项B":"伴生类和伴生对象要在同一个源文件中定义","选项A":"单例对象与类同名时，这个单例对象被称为这个类的伴生对象，而这个类被称为这个单例对象的伴生类","类型":"2-多选"},{"题干":"对于以下2个列表的操作，下面那些说法说法正确\n\u00A0\u00A0var\u00A0t\u00A0=\u00A0List(1,2,3)\n\u00A0\u00A0var\u00A0t2\u00A0=\u00A0List(4,5)","选项F":"","选项E":"","选项D":"var\u00A0t3\u00A0=\u00A0t.:::(t2)\u00A0得到List(4,5,1,2,3)","答案":"ABCD","选项C":"var\u00A0t3\u00A0=\u00A0t\u00A0:::\u00A0t2得到List(1,2,3,4,5)","选项B":"var\u00A0t3\u00A0=\u00A0List.concat(t,t2)得到List(1,2,3,4,5)","选项A":"var\u00A0t3\u00A0=\u00A0t\u00A0++\u00A0t2\u00A0得到List(1,2,3,4,5)","类型":"2-多选"},{"题干":"在scala中对于列表的操作，那些说法说法正确\n  var t = List(1,2,3)\n  var t2 = List(4,5)","选项F":"","选项E":"","选项D":"var t3 = t2.:::(t)得到List(1,2,3,4,5)","答案":"ABCD","选项C":"var t3 = t ::: t2得到List(1,2,3,4,5)","选项B":"var t3 = List.concat(t,t2)得到List(1,2,3,4,5)","选项A":"var t3 = t ++ t2 得到List(1,2,3,4,5)","类型":"2-多选"},{"题干":"在scala中对于以下2个列表的操作，那些说法说法正确\n  var t = List(1,2,3)\n  var t2 = List(4,5)","选项F":"","选项E":"","选项D":"var t3 = t.:::(t2) 得到List(1,2,3,4,5)","答案":"ABC","选项C":"var t3 = t ::: t2得到List(1,2,3,4,5)","选项B":"var t3 = List.concat(t,t2)得到List(1,2,3,4,5)","选项A":"var t3 = t ++ t2 得到List(1,2,3,4,5)","类型":"2-多选"},{"题干":"以下对于reduce操作说法严格一样正确的是\nvar t = List(1,2,3,4,5)\nprintln(t.reduce( (a,b) => a+b ))","选项F":"","选项E":"","选项D":"println(t.reduceRight(_+_))是用通配符代表前后2个元素相加，但是累加顺序从右边开始，与题干不一致","答案":"AB","选项C":"println(t.reduceRight( (a,b) => a+b ))是用通配符代表前后2个元素相加，但是累加顺序从右边开始，与题干不一致","选项B":"println(t.reduceLeft(_+_))reduceLeft与reduce一致，通配符表示前后2个元素相加，与题干一致","选项A":"println(t.reduce(_+_))是用通配符代表前后2个元素相加，与题干一致","类型":"2-多选"},{"题干":"提供一个列表，要对其所有元素全部加2得到一个新的列表，下面那些选项正确\n  var t = List(1,8,3,5,5)","选项F":"","选项E":"","选项D":"以上做法都不对","答案":"ABC","选项C":"其中A选项是通过一个匿名函数进行操作，B选项是通过更加简写的通配符+2表示所有元素进行加2处理，所以都正确","选项B":"t.map( _ + 2)","选项A":"t.map( x => {x+2})","类型":"2-多选"},{"题干":"函数在scala中的地位说法正确的有哪些选项","选项F":"","选项E":"","选项D":"函数不能赋值给变量","答案":"AB","选项C":"不能独立定义","选项B":"可以独立定义","选项A":"一等公民","类型":"2-多选"},{"题干":"scala语言中集合说法正确的包括如下选项","选项F":"","选项E":"","选项D":"Set集合和List集合没有区别","答案":"AC","选项C":"Map集合是键值对的形式存储的数据","选项B":"Set集合中数据可以重复","选项A":"List集合中数据可以重复","类型":"2-多选"},{"题干":"函数可以没有名字","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"函数不能作为其他函数的参数","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"函数可以作为返回值","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"在scala中，只有主构造函数才可以写参数","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"在scala中，如果要重写一个非抽象方法，则必须使用override修饰符","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"for 循环中的 yield 会把当前的元素记下来，保存在集合中","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"scala提供了许多方法如max,min,sum能自动得到比如集合中的最大最小与合计，不用自己再去写方法做计算","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":":: 该方法被称为cons，意为构造，向队列的头部追加数据，创造新的列表","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"++ 该方法用于连接两个集合，list1++list2","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"::: 该方法只能用于连接两个List类型的集合","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"通过如下程序块可以知道，在list 中的构造中，可以通过::进行列表的构造\n   val site: List[String] = List(\"Runoob\", \"Google\", \"Baidu\")\n   val site1: List[String] = \"Runoob\":: (\"Google\")::( \"Baidu\"::Nil) ;","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"val site: List[String] = List(\"Runoob\", \"Google\", \"Baidu\")\n   println(site.head + site.tail)\n   可以知道head 返回列表第一个元素，tail 返回除第一个元素外的所有元素","选项F":"","选项E":"","选项D":"","答案":"A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"列表A.:::(列表B)得到的新的列表，其中列表B的元素在列表A的前面","选项F":"","选项E":"","选项D":"","答案":" A","选项C":"","选项B":"","选项A":"","类型":"0-判断"},{"题干":"只有主构造函数才可以写参数，进行参数的初始化","选项F":"","选项E":"","选项D":"","答案":"B","选项C":"","选项B":"","选项A":"","类型":"0-判断"}]